<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[python解leetcode动态规划(2)]]></title>
    <url>%2F2019%2F08%2F20%2Fpython_leetcode-dynamic-programming(3)%2F</url>
    <content type="text"><![CDATA[动态规划主要方法是画网格⭐。 递归 + 记忆化 ——&gt; 递推（动态规划） 状态的定义：数组 opt[n], dp[n], fib[n] 状态转移方程：opt[n] = best_of(opt[n-1], opt[n-2], …) 从前面的n-1个值得到最优的第n个值 最优子结构 学习内容： 0-1 背包问题🚩 ❓自我实现 ❓Palindrome Partitioning II(132) 单词拆分 分割等和子集 322. 零钱兑换 ❓377 ❓474 ❓140 ❓494 139. 单词拆分 给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。 说明： 拆分时可以重复使用字典中的单词。 你可以假设字典中没有重复的单词。 示例 1： 123输入: s = &quot;leetcode&quot;, wordDict = [&quot;leet&quot;, &quot;code&quot;]输出: true解释: 返回 true 因为 &quot;leetcode&quot; 可以被拆分成 &quot;leet code&quot;。 示例 2： 1234输入: s = &quot;applepenapple&quot;, wordDict = [&quot;apple&quot;, &quot;pen&quot;]输出: true解释: 返回 true 因为 &quot;applepenapple&quot; 可以被拆分成 &quot;apple pen apple&quot;。 注意你可以重复使用字典中的单词。 示例 3： 12输入: s = &quot;catsandog&quot;, wordDict = [&quot;cats&quot;, &quot;dog&quot;, &quot;sand&quot;, &quot;and&quot;, &quot;cat&quot;]输出: false 方法 S能拆成功的话，说明前一部分和后一部分能拆开。每一部分也分别可能分解为可拆开的一小部分。 123456789class Solution: def wordBreak(self, s: str, wordDict: List[str]) -&gt; bool: dp = [False] * (len(s)+1) dp[0] = True for i in range(1,len(s)+1): for j in range(i): if dp[j] and s[j:i] in wordDict: dp[i] = True return dp.pop() 416. 分割等和子集 给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。 注意: 每个数组中的元素不会超过 100 数组的大小不会超过 200 示例 1: 123输入: [1, 5, 11, 5]输出: true解释: 数组可以分割成 [1, 5, 5] 和 [11]. 示例 2: 123输入: [1, 2, 3, 5]输出: false解释: 数组不能分割成两个元素和相等的子集. 方法 提示：0-1 背包问题，思路是：物品一个一个加进来。 状态：dp[i][j]：考虑索引是 [0,i] 这个区间的物品是否能够填充容量为 j 的背包。 Python 代码：这是用二维数组的写法，试试看能不能用一维数组写出来 1234567891011121314151617class Solution: def canPartition(self, nums: List[int]) -&gt; bool: _sum = sum(nums) if _sum % 2 == 1: return False #总和不是偶数 half = _sum//2 N = len(nums) dp = [[0 for _ in range(half+1)] for _ in range(N)] # 先填第 1 行，即 nums[0] 这个物品，是不是能够填满 0，1，。。。，half 的背包 for j in range(half+1): dp[0][j] = True if nums[0]==j else False # 再填后面几行 for i in range(1,N): for j in range(half+1): # 不放这个物品 、 放这个物品,达到总和sum都可以设为True dp[i][j] = dp[i-1][j] or dp[i-1][j-nums[i]] return dp[-1][-1] 322. 零钱兑换 给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。 示例 1: 123输入: coins = [1, 2, 5], amount = 11输出: 3 解释: 11 = 5 + 5 + 1 示例 2: 12输入: coins = [2], amount = 3输出: -1 说明: 你可以认为每种硬币的数量是无限的。 方法：动态规划 dp[i]表示凑够i元所需要的最少硬币数, 那再加一个面值为c的硬币，dp[i + c] = min(dp[i] + 1, dp[i + c]) 123456789101112class Solution: def coinChange(self, coins: List[int], amount: int) -&gt; int: dp = [0]+[-1]*amount # 初始化，第一个值为0，其余全是-1 for i in range(amount): if dp[i]&lt;0: #跳过一些无需计算的值 continue for c in coins: if i+c &gt; amount: continue # 越界，跳出循环，换下一种硬币 if dp[i+c]&gt;dp[i]+1 or dp[i+c]&lt;0: dp[i+c] = dp[i]+1 return dp[amount] 参考 LeetCode 动态规划专题 7：面试中的 0-1 背包问题]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>LeetCode</tag>
        <tag>数据结构</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python实现排序算法]]></title>
    <url>%2F2019%2F08%2F19%2Fpython-leetcode-sorting(1)%2F</url>
    <content type="text"><![CDATA[学习目标： 最大数 179. 最大数 给定一组非负整数，重新排列它们的顺序使之组成一个最大的整数。 示例 1: 12输入: [10,2]输出: 210 示例 2: 123输入: [3,30,34,5,9]输出: 9534330说明: 输出结果可能非常大，所以你需要返回一个字符串而不是整数。 方法 如果AB&gt;BA，那么我们规定A&gt;B，也就是最后拼接时A放在B之前. 注意的是可能参数是多个0，此时字符串拼接的结果是一串0，不符合常规的表达方法，要将其改为0。 123456from functools import cmp_to_keyclass Solution: def largestNumber(self, nums: List[int]) -&gt; str: sorted_nums = sorted(map(str, nums), key=cmp_to_key(lambda x, y: int(y + x) - int(x + y))) result = ''.join(sorted_nums).lstrip('0') return result or '0']]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>LeetCode</tag>
        <tag>数据结构</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《剑指offer》第3章16-26题(python)]]></title>
    <url>%2F2019%2F08%2F15%2Fcoding-interviews_chapter3problem16-26%2F</url>
    <content type="text"><![CDATA[3.数组中重复的数字 牛客网 online judge 地址 在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。 3.1 可以修改原始数组 方法：交换数字 交换数字到对应位置 1234567891011121314151617class Solution: # 这里要特别注意~找到任意重复的一个值并赋值到duplication[0] # 函数返回True/False def duplicate(self, numbers, duplication): if len(numbers)&lt;2: duplication[0] = -1 return False for i in range(len(numbers)): while i != numbers[i]: if numbers[i] == numbers[numbers[i]]: duplication[0] = numbers[i] return True # 注意这里不能直接multiple assignment temp = numbers[i] numbers[i] = numbers[numbers[i]] numbers[temp] = temp return False 3.2 不能修改原始数组 方法一：二分查找 类似于二分查找，多了一步计数 123456789101112131415161718192021class Solution: # 这里要特别注意~找到任意重复的一个值并赋值到duplication[0] # 函数返回True/False def duplicate(self, numbers, duplication): if len(set(numbers)) == len(numbers): duplication[0] = -1 return False left = 1 right = len(numbers)-1 while left &lt; right: mid = left + (right-left+1)//2 count = 0 for num in numbers: if num &lt; mid: count += 1 if count &lt; mid:# 右半边有重复 left = mid else: # 左半边有重复 right = mid -1 duplication[0] = left return True 方法二：快慢指针 使用快慢指针，判断数组中是否有逻辑上的环存在。寻找环的起点。 注意：题目的返回方式、快慢指针的初始化方式。 123456789101112131415161718class Solution: # 这里要特别注意~找到任意重复的一个值并赋值到duplication[0] # 函数返回True/False def duplicate(self, nums, duplication): if len(set(nums)) == len(nums): duplication[0] = -1 return False fast = nums[nums[0]] slow = nums[0] while fast != slow: fast = nums[nums[fast]] slow = nums[slow] fast = 0 while fast != slow: fast = nums[nums[fast]] slow = nums[slow] duplication[0] = nums[fast] return True]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python解leetcode二叉树(3)]]></title>
    <url>%2F2019%2F08%2F14%2Fpython_leetcode-binary-tree(3)%2F</url>
    <content type="text"><![CDATA[二叉树中第二小的节点 二叉搜索树中第K小的元素 二叉搜索树的最近公共祖先 671. 二叉树中第二小的节点 给定一个非空特殊的二叉树，每个节点都是正数，并且每个节点的子节点数量只能为 2 或 0。如果一个节点有两个子节点的话，那么这个节点的值不大于它的子节点的值。 给出这样的一个二叉树，你需要输出所有节点中的第二小的值。如果第二小的值不存在的话，输出 -1 。 示例 1: 123456789输入: 2 / \ 2 5 / \ 5 7输出: 5说明: 最小的值是 2 ，第二小的值是 5 。 示例 2: 1234567输入: 2 / \ 2 2输出: -1说明: 最小的值是 2, 但是不存在第二小的值。 方法一 遍历所有值，找最小，再找次小 使用了一个中序遍历，把所有的值放入到set里，然后我们先找最小值，然后删除掉它之后，再求一次最小值就是次小值。 1234567891011121314151617181920# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def findSecondMinimumValue(self, root: TreeNode) -&gt; int: self.res = set() self.inOrder(root) if len(self.res) &lt;= 1: return -1 min1 = min(self.res) self.res.remove(min1) return min(self.res) def inOrder(self, root): if not root:return self.inOrder(root.left) self.res.add(root.val) self.inOrder(root.right) 方法二 所有的值的最小值一定是root的值。 可以使用一个变量，时刻保存现在遇到的比最小值大并且比次小值小的值作为第二小的值。 123456789101112131415class Solution: def findSecondMinimumValue(self, root: TreeNode) -&gt; int: if not root: return -1 self.res = float("inf") self.min = root.val self.inOrder(root) return self.res if self.res != float("inf") else -1 def inOrder(self, root): if not root: return self.inOrder(root.left) if self.min &lt; root.val &lt; self.res: self.res = root.val self.inOrder(root.right) 230. 二叉搜索树中第K小的元素 方法：递归 提到BST就应该想到它的中序遍历是有序的，因此，最简单的想法就是获取中序遍历的list，直接得到第k个数即可。方法很简单，注意中序遍历的写法，以及，获取第k个数的List标号是k-1. 当K比较小的时候，没必要获取得到所有的中序遍历结果之后再停止，可以直接记数到了k停止即可，这样后面的结果就不用统计了。 我们需要做的是有一个全局的变量保存现在已经遍历了多少节点了，或者还剩多少个节点需要遍历。 1234567891011121314class Solution: def kthSmallest(self, root: TreeNode, k: int) -&gt; int: self.res = 0 self.count = 0 self.inOrder(root, k) return self.res def inOrder(self, root, k): if not root:return self.inOrder(root.left, k) self.count += 1 if self.count == k: self.res = root.val return self.inOrder(root.right, k) 235. 二叉搜索树的最近公共祖先 Lowest Common Ancestor of a Binary Search Tree 给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。” 例如，给定如下二叉搜索树: root = [6,2,8,0,4,7,9,null,null,3,5] 示例 1: 123输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8输出: 6 解释: 节点 2 和节点 8 的最近公共祖先是 6。 示例 2: 123456789101112131415161718192021输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4输出: 2解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。``` 说明:- 所有节点的值都是唯一的。- p、q 为不同节点且均存在于给定的二叉搜索树中。## 方法:递归BST本身的属性，所以比较节点的值和根节点的值的大小就知道下一步去哪里查找了。```pythonclass Solution: def lowestCommonAncestor(self, root: &apos;TreeNode&apos;, p: &apos;TreeNode&apos;, q: &apos;TreeNode&apos;) -&gt; &apos;TreeNode&apos;: if min(p.val, q.val) &lt;= root.val and max(p.val, q.val) &gt;= root.val: return root elif p.val &lt; root.val and q.val &lt; root.val: return self.lowestCommonAncestor(root.left, p, q) elif p.val &gt; root.val and q.val &gt; root.val: return self.lowestCommonAncestor(root.right, p, q) 这个题是236. 二叉树的最近公共祖先 的特例，所以可以直接使用236的代码就能通过。 236. 二叉树的最近公共祖先 给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。” 例如，给定如下二叉树: root = [3,5,1,6,2,0,8,null,null,7,4] 示例 1: 123输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1输出: 3解释: 节点 5 和节点 1 的最近公共祖先是节点 3。 示例 2: 123输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4输出: 5解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。 说明: 所有节点的值都是唯一的。 p、q 为不同节点且均存在于给定的二叉树中。 方法 这个题的模式叫做devide and conquer. 如果当前节点等于其中的p和q某一个节点，那么找到了节点，返回该节点，否则在左右子树分别寻找。 左右子树两个返回的是什么呢？按照该递归函数的定义，即找到了左子树和右子树里p和q的公共祖先，注意祖先可以是节点自己。然后根据左右侧找到的节点做进一步的判断。 如果左右侧查找的结果都不为空，说明分别找到了p和q，那么LCA就是当前节点。否则就在不为空的那个结果就是所求。 123456789class Solution: def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -&gt; 'TreeNode': if not root or p==root or q==root: return root left = self.lowestCommonAncestor(root.left, p, q) right = self.lowestCommonAncestor(root.right, p, q) if left and right: return root return left if left else right 参考 【LeetCode】230. Kth Smallest Element in a BST 解题报告（C++ &amp; Java）]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>LeetCode</tag>
        <tag>数据结构</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python解LeetCode数组(3)]]></title>
    <url>%2F2019%2F08%2F11%2Fpython_leetcode-array(3)%2F</url>
    <content type="text"><![CDATA[寻找两个有序数组的中位数 盛最多水的容器 螺旋矩阵 螺旋矩阵 II 只出现一次的数字 有序数组的平方 搜索二维矩阵 II 搜索二维矩阵 前 K 个高频元素 和为K的子数组 4. 寻找两个有序数组的中位数 寻找两个有序数组的中位数 给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。 请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m+n))。 你可以假设 nums1 和 nums2 不会同时为空。 示例 1: 123nums1 = [1, 3]nums2 = [2]则中位数是 2.0 示例 2: 123nums1 = [1, 2]nums2 = [3, 4]则中位数是 (2 + 3)/2 = 2.5 方法一：合并，排序，除以2 对于一个有序数组，如果数组长度是奇数，那么中位数就是中间那个值，如果长度是偶数，就是中间两个数的平均数。 12345678910111213class Solution: def findMedianSortedArrays(self, nums1, nums2): """ :type nums1: List[int] :type nums2: List[int] :rtype: float """ tmp = nums1 + nums2 tmp.sort() if len(tmp)%2==1: return tmp[int(len(tmp)/2)] else: return (tmp[int(len(tmp)/2)-1] + tmp[int(len(tmp)/2)])/2.0 Time Complexity: O(n) 大于题目要求的时间复杂度 方法二：寻找划分位置 中位数的作用：将一个集合划分为两个长度相等的子集，其中一个子集中的元素总是大于另一个子集中的元素。 思路：nums1和nums2分别以i,j为界划分成左右两部分，不断调整i,j,以达成以下条件： len(nums1_左) + len(nums2_左) = len(nums1_右) + len(nums2_右) 就是说，划分后的左右两边的长度相等。 Max(nums1左、nums2左) ≤ Min(nums1右、nums2右) 就是说，左边的元素总是小于右边。 12345678910111213141516171819202122232425262728293031323334class Solution: def findMedianSortedArrays(self, nums1, nums2): """ :type nums1: List[int] :type nums2: List[int] :rtype: float """ m, n = len(nums1), len(nums2) if m &gt; n: nums1, nums2, m, n = nums2, nums1, n, m if n == 0: raise ValueError imin, imax, half_len = 0, m, (m+n+1)//2 while imin &lt;= imax: i = (imin + imax)//2 j = half_len - i if i&lt;m and nums2[j-1] &gt; nums1[i]: #i太小 imin = i+1 elif i&gt;0 and nums1[i-1]&gt;nums2[j]: #i太大 imax = i-1 else:#找到i的正确位置 if i==0: max_of_left = nums2[j-1]#临界问题，其中一个列表全在右边，左边为空 elif j==0: max_of_left = nums1[i-1] else: max_of_left = max(nums1[i-1], nums2[j-1]) if(m+n)%2 == 1: #若列表长度为奇数 return max_of_left if i==m: min_of_right = nums2[j] #临界问题，其中一个列表全在左边，右边为空 elif j==n: min_of_right = nums1[i] else: min_of_right = min(nums1[i], nums2[j]) return (max_of_left + min_of_right)/2 Time Complexity: O(log(min(m,n))) 首先，查找的区间是 [0,m]。 而该区间的长度在每次循环之后都会减少为原来的一半。 所以，我们只需要执行 (m) 次循环。由于我们在每次循环中进行常量次数的操作，所以时间复杂度为 O(log(m)) 。 由于 m≤n，所以时间复杂度是 O(log(min(m,n)))。空间复杂度：O(1)， 我们只需要恒定的内存来存储 9 个局部变量， 所以空间复杂度为 O(1)。 11. 盛最多水的容器 Container With Most Water 给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。 说明：你不能倾斜容器，且 n 的值至少为 2。 图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。 示例: 12输入: [1,8,6,2,5,4,8,3,7]输出: 49 方法一：移动指针 装水的面积取决于两条线中较短的那条的长度和两条线之间横坐标的差值。 用双指针left、right，分别指向数组height的首尾。只有较短边会对盛水量造成影响，因此移动较短边的指针，并比较当前盛水量和当前最大盛水量。直至左右指针相遇。 area在宽度变小的情况下，只有可能高度变大，面积才有可能变大 如果height[left]长度小于height[right]，无论如何移动right，短板在left，不可能找到比当前记录的 area 更大的值了，只能通过移动left来找到新的可能的更大面积。这种方式可以遍历到容量最大的情况。 12345678910111213141516171819class Solution: def maxArea(self, height): """ :type height: List[int] :rtype: int """ if height == []: return 0 left, right, area = 0, len(height)-1, 0 while left&lt;right: area = max(area, min(height[left], height[right]) * (right-left)) if height[left]&lt;height[right]:#area的高取决于左指针 left+=1 else: #area的高取决于右指针 right-=1 return area Time Complexity: O(n) O(n)O(n) 方法一改进 123456789101112131415161718192021class Solution(object): def maxArea(self, height): """ :type height: List[int] :rtype: int """ l = 0 r = len(height)-1 s = 0 while l &lt; r: width = r-l if height[l] &lt; height[r]: h = height[l] l += 1 else: h = height[r] r -= 1 s = max(s, h*width) return s 54. 螺旋矩阵 给定一个包含 m x n 个元素的矩阵（m 行, n 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。 示例 1: 1234567输入:[ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ]]输出: [1,2,3,6,9,8,7,4,5] 方法 12345678910111213141516171819202122232425262728293031323334353637383940class Solution: def spiralOrder(self, matrix): """ :type matrix: List[List[int]] :rtype: List[int] """ if len(matrix)==0: return res = [] # case 0,1,2,3分别表示按螺旋顺序要遍历的上、右、底、左边 case = 0 #尚未遍历的矩阵的四条边位置 up = 0 down = len(matrix)-1 left = 0 right = len(matrix[0])-1 while left&lt;=right and up&lt;=down: if case == 0: #遍历上边 for i in range(left, right+1): res.append(matrix[up][i]) up+=1 elif case == 1:#遍历右边 for i in range(up, down+1): res.append(matrix[i][right]) right -= 1 elif case == 2: #遍历底边 for i in range(left, right+1)[::-1]: res.append(matrix[down][i]) down -= 1 else: #遍历左边 for i in range(up, down+1)[::-1]: res.append(matrix[i][left]) left += 1 case = (case + 1) % 4 return res 59. 螺旋矩阵 II 给定一个正整数 n，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。 示例: 1234567输入: 3输出:[ [ 1, 2, 3 ], [ 8, 9, 4 ], [ 7, 6, 5 ]] 方法 类似于上面54题 1234567891011121314151617181920212223242526272829class Solution: def generateMatrix(self, n: int) -&gt; List[List[int]]: if n == 0: return [] res = [[0 for x in range(n)] for x in range(n)] cnt, case = 1, 0 i, j = 0, 0 weight = 1 res[0][0] = 1 while cnt &lt; n * n: if case == 0: j += 1 #横向递增 if j == n - weight: case = 1 elif case == 1: i += 1 #纵向递增 if i == n - weight: case = 2 elif case == 2: j -= 1 #横向向左 if j == weight - 1: case = 3 weight += 1 elif case == 3: i -= 1 #纵向向上 if i == weight - 1: case = 0 res[i][j] = cnt + 1 cnt += 1 return res 136. 只出现一次的数字 给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。 说明：你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？ 示例 : 12输入: [4,1,2,1,2]输出: 4 方法一：异或位运算 异或运算是可以交换顺序的运算，也就是说和元素的排列顺序无关，自己异或自己等于0,0异或别人等于别人。 1234from functools import reduceclass Solution: def singleNumber(self, nums: List[int]) -&gt; int: return reduce(lambda x, y: x^y, nums) 方法二：字典 使用Counter直接求只出现一次的数字即可 1234class Solution: def singleNumber(self, nums: List[int]) -&gt; int: count = collections.Counter(nums) return count.most_common()[-1][0] 977. 有序数组的平方 给定一个按非递减顺序排序的整数数组 A，返回每个数字的平方组成的新数组，要求也按非递减顺序排序。 示例 1： 12输入：[-4,-1,0,3,10]输出：[0,1,9,16,100] 示例 2： 12输入：[-7,-3,2,3,11]输出：[4,9,9,49,121] 提示： 1 &lt;= A.length &lt;= 10000 -10000 &lt;= A[i] &lt;= 10000 A 已按非递减顺序排序。 方法一：归并排序 用两个指针分别读取数组的非负部分与负数部分 —— 指针 i 反向读取负数部分，指针 j 正向读取非负数部分。 123456789101112131415161718192021222324252627class Solution: def sortedSquares(self, A): """ :type A: List[int] :rtype: List[int] """ N = len(A) j = 0 while A[j]&lt;0 and j&lt;N-1: j+=1 i = j-1 res = [] while 0&lt;=i and j&lt;N: # 归并操作, 谁的平方小，谁先输出 if A[i]**2 &lt; A[j]**2: res.append(A[i]**2) i-=1 else: res.append(A[j]**2) j+=1 while i&gt;=0: # 如果负数部分没有输出完，则直接输出 res.append(A[i]**2) i-=1 while j&lt;N: # 如果正数部分没有输出完，则直接输出 res.append(A[j]**2) j+=1 return res Time Complexity: O(n) O(n)O(n) 方法二：排序 12345678910111213class Solution: def sortedSquares(self, A): return sorted(x*x for x in A)``` Time Complexity: O(nlogn) O(nlogn)O(nlogn)# 240. 搜索二维矩阵 II编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target。该矩阵具有以下特性：每行的元素从左到右升序排列。每列的元素从上到下升序排列。示例: 现有矩阵 matrix 如下： [ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30]] 给定 target = 5，返回 true。 给定 target = 20，返回 false。 12345678910111213141516171819202122232425262728## 方法这个题在剑指offer有详细解释。方法是从右上角向左下角进行遍历，根据比较的大小决定向下还是向左查找。剑指offer的解释是我们从矩阵的左下角或者右上角开始遍历，这样知道了比较的结果是大还是小，就知道了对应的前进方向。```pythonclass Solution: def searchMatrix(self, matrix, target): &quot;&quot;&quot; :type matrix: List[List[int]] :type target: int :rtype: bool &quot;&quot;&quot; if not matrix or not matrix[0]: return False rows = len(matrix) cols = len(matrix[0]) row, col = 0, cols-1 #从右上角开始 while True: if row &lt; rows and col &gt;= 0: if matrix[row][col] == target: return True elif matrix[row][col] &lt; target: row += 1 else: col -= 1 else: return False 74. 搜索二维矩阵 编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性： 每行中的整数从左到右按升序排列。 每行的第一个整数大于前一行的最后一个整数。 示例 1: 12345678输入:matrix = [ [1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50]]target = 3输出: true 方法一 这个题目是240题的一个特例，所以可以直接使用240题的代码就能通过。方法是从矩阵的左下角或者右上角开始遍历。 这个题在剑指offer有详细解释。方法是从右上角向左下角进行遍历，根据比较的大小决定向下还是向左查找。 1234567891011121314151617class Solution: def searchMatrix(self, matrix: List[List[int]], target: int) -&gt; bool: if not matrix or not matrix[0]: return False rows = len(matrix) cols = len(matrix[0]) row, col = 0, cols-1 #从右上角开始 while True: if row &lt; rows and col &gt;= 0: if matrix[row][col] == target: return True elif matrix[row][col] &lt; target: row += 1 else: col -= 1 else: return False 方法二：库函数 使用库函数也可以哦，不过库函数都是针对一维数组的查找，所以我们需要把给出的数组变成一维的。在numpy中有reshape函数，幸运的是，leetcode支持Numpy. 12345import numpy as npclass Solution: def searchMatrix(self, matrix: List[List[int]], target: int) -&gt; bool: matrix = np.reshape(matrix, [1, -1]) return target in matrix 347. 前 K 个高频元素 给定一个非空的整数数组，返回其中出现频率前 k 高的元素。 示例 1: 12输入: nums = [1,1,1,2,2,3], k = 2输出: [1,2] 示例 2: 12输入: nums = [1], k = 1输出: [1] 说明： 你可以假设给定的 k 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。 你的算法的时间复杂度必须优于 O(n log n) , n 是数组的大小。 字典 这个题要求时间复杂度是O(nlogn)，就可以按照出现的次数先排个序，然后找到出现最多的k个就好。 Counter类有most_common()函数，能按出现的次数进行排序。返回的是个列表，列表中每个元素都是一个元组，元组的第一个元素是数字，第二个数字是出现的次数。 12345from collections import Counterclass Solution: def topKFrequent(self, nums: List[int], k: int) -&gt; List[int]: counter = Counter(nums).most_common() return [counter[i][0] for i in range(k)] 560. 和为K的子数组 给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。 示例 1 : 12输入:nums = [1,1,1], k = 2输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。 说明 : 数组的长度为 [1, 20,000]。 数组中元素的范围是 [-1000, 1000] ，且整数 k 的范围是 [-1e7, 1e7]。 方法：字典 使用一个字典保存数组某个位置之前的数组和，然后遍历数组求和，这样当我们求到一个位置的和的时候，向前找sum-k是否在数组中，如果在的话，更新结果为之前的结果+(sum-k出现的次数)。同时，当前这个sum出现的次数就多了一次。 这个字典的意义是什么呢？其意义就是我们在到达i位置的时候，前i项的和出现的次数的统计。我们想找的是在i位置向前的连续区间中，有多少个位置的和是k。有了这个统计，我们就不用向前一一遍历找sum - k在哪些位置出现了，而是直接得出了前面有多少个区间。所以，在每个位置我们都得到了以这个位置为结尾的并且和等于k的区间的个数，所以总和就是结果。 这个题的解法不难想出来，因为如果要降低时间复杂度，应该能想到增加空间复杂度，那么要么使用数组，要么就是用字典之类的，保留之前的结果。 时间复杂度是O(N)，空间复杂度是O(N). 12345678910111213class Solution: def subarraySum(self, nums: List[int], k: int) -&gt; int: n = len(nums) d = collections.defaultdict(int) d[0] = 1 res = 0 sum = 0 for i in range(n): sum += nums[i] if sum-k in d: res += d[sum-k] d[sum] += 1 return res 参考 LeetCode：977. Squares of a Sorted Array - Python leetcode11. Container With Most Water 盛水最多的容器]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>LeetCode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python解leetcode动态规划(2)]]></title>
    <url>%2F2019%2F08%2F10%2Fpython_leetcode-dynamic-programming(2)%2F</url>
    <content type="text"><![CDATA[动态规划主要方法是画网格⭐。 递归 + 记忆化 ——&gt; 递推（动态规划） 状态的定义：数组 opt[n], dp[n], fib[n] 状态转移方程：opt[n] = best_of(opt[n-1], opt[n-2], …) 从前面的n-1个值得到最优的第n个值 最优子结构：通过求子问题的最优解，可以获得原问题的最优解。 学习内容： 最大正方形 不同的子序列 72. 编辑距离 莱文斯坦最短编辑距离 找最长公共子串 718. 最长重复子数组 10. 正则表达式匹配 152. 乘积最大子序列 300. 最长上升子序列 解码方法 ❓279. 完全平方数 整数拆分 221. 最大正方形 在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。 示例: 12345678输入: 1 0 1 0 01 0 1 1 11 1 1 1 11 0 0 1 0输出: 4 方法 设这个DP[i][j]数组为以i, j位置为右下角顶点的能够成的最大正方形的边长。数组如果是第一行或者第一列，显然dp和matrix相等。如果是其他位置，当matrix[i][j] = 1时，能够成的正方形等于左边、上边、左上能够成的正方形边长的最小值+1.为什么是最小值？因为只要存在一个0，那么就没法构成更大的正方形，这个是很保守的策略。 时间复杂度是O(N2)，空间复杂度是O(N2)。 123456789101112131415class Solution: def maximalSquare(self, matrix: List[List[str]]) -&gt; int: if not matrix:return 0 M = len(matrix) N = len(matrix[0]) dp = [[0]*N for _ in range(M)] for i in range(M): dp[i][0] = int(matrix[i][0]) for j in range(N): dp[0][j] = int(matrix[0][j]) for i in range(1,M): for j in range(1,N): if int(matrix[i][j])==1: dp[i][j] = min(dp[i][j-1], dp[i-1][j], dp[i-1][j-1]) +1 return max(map(max, dp)) **2 115.不同的子序列 给定一个字符串 S 和一个字符串 T，计算在 S 的子序列中 T 出现的个数。 一个字符串的一个子序列是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，“ACE” 是 “ABCDE” 的一个子序列，而 “AEC” 不是） 示例 1: 12345678910111213输入: S = &quot;rabbbit&quot;, T = &quot;rabbit&quot;输出: 3解释:如下图所示, 有 3 种可以从 S 中得到 &quot;rabbit&quot; 的方案。(上箭头符号 ^ 表示选取的字母)rabbbit^^^^ ^^rabbbit^^ ^^^^rabbbit^^^ ^^^ 方法 画网格，两个字符串分别为横纵轴，预设空字符串为初始化边界，每一格表示当前位置为止所能匹配的个数。 123456789101112131415class Solution: def numDistinct(self, s: str, t: str) -&gt; int: M, N = len(s), len(t) dp = [[0]*(M+1) for _ in range(N+1)] # 加一是考虑空字符串作为边界 for j in range(M+1): dp[0][j] = 1 #T是空字符串的话，在S中匹配一个空字符串 for i in range(1, N+1): for j in range(1, M+1): # 可以把i和j分别位于纵轴T和横轴S上。 if t[i-1] == s[j-1]: # 如果相同，就可以连上左上角的匹配个数，加上左边已有的匹配个数 dp[i][j] = dp[i - 1][j - 1] + dp[i][j - 1] else: # 如果不同，则保持左边已有的匹配个数 dp[i][j] = dp[i][j-1] return dp[-1][-1] #右下角为最终匹配个数 72. 编辑距离 给定两个单词 word1 和 word2，计算出将 word1 转换成 word2 所使用的最少操作数 。 你可以对一个单词进行如下三种操作： 123插入一个字符删除一个字符替换一个字符 示例 1: 123456输入: word1 = &quot;horse&quot;, word2 = &quot;ros&quot;输出: 3解释: horse -&gt; rorse (将 &apos;h&apos; 替换为 &apos;r&apos;)rorse -&gt; rose (删除 &apos;r&apos;)rose -&gt; ros (删除 &apos;e&apos;) 示例 2: 12345678输入: word1 = &quot;intention&quot;, word2 = &quot;execution&quot;输出: 5解释: intention -&gt; inention (删除 &apos;t&apos;)inention -&gt; enention (将 &apos;i&apos; 替换为 &apos;e&apos;)enention -&gt; exention (将 &apos;n&apos; 替换为 &apos;x&apos;)exention -&gt; exection (将 &apos;n&apos; 替换为 &apos;c&apos;)exection -&gt; execution (插入 &apos;u&apos;) 方法：递归 判断最后的一个字符是否相等。 如果相等，那么只用判断前面的子串即可， 如果不等，需要前面子串变成相等之后+1(删、增、换) 把word1变成word2。 12345678910111213141516171819class Solution: def minDistance(self, word1: str, word2: str) -&gt; int: L1, L2 = len(word1), len(word2) dp = [[-1]*(L2+1) for _ in range(L1+1)] # 初始化全部小于0 return self.getDistance(word1, word2, dp, L1, L2) def getDistance(self, word1, word2, dp, pos1, pos2): if pos1 == 0: return pos2 # pos表示当前位置，也表示前面子串的长度 if pos2 == 0: return pos1 if dp[pos1][pos2] &gt;= 0: return dp[pos1][pos2] # 当前位置的操作数 res = 0 if word1[pos1-1] == word2[pos2-1]: res = self.getDistance(word1, word2, dp, pos1-1, pos2-1) else: res = 1 + min(self.getDistance(word1, word2, dp, pos1-1, pos2),#如果删除后，剩下的前面子串的操作数 self.getDistance(word1, word2, dp, pos1, pos2-1),#如果插入后，剩下的前面子串的操作数 self.getDistance(word1, word2, dp, pos1-1, pos2-1))#如果替换后，剩下的前面子串的操作数 dp[pos1][pos2] = res return res 方法：动态规划 上一个方法很容易改成动态规划。事实上，这个题的动态规划比记忆化搜索还要慢。 1234567891011121314151617class Solution: def minDistance(self, word1: str, word2: str) -&gt; int: L1, L2 = len(word1), len(word2) dp = [[0] * (L2 + 1) for _ in range(L1 + 1)] for i in range(L1 + 1): dp[i][0] = i for j in range(L2 + 1): dp[0][j] = j for i in range(1, L1 + 1): for j in range(1, L2 + 1): if word1[i - 1] == word2[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = 1 + min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) return dp[L1][L2] 718. 最长重复子数组 给两个整数数组 A 和 B ，返回两个数组中公共的、长度最长的子数组的长度。 示例 1: 12345输入:A: [1,2,3,2,1]B: [3,2,1,4,7]输出: 3解释: 长度最长的公共子数组是 [3, 2, 1]。 说明: 1 &lt;= len(A), len(B) &lt;= 1000 0 &lt;= A[i], B[i] &lt; 100 方法:动态规划 是找到当前节点之前连续的公共子串长度问题。 画格子：横纵坐标分别是A和B，对应比较，相等时，格子为1，或者左上角的数+1。 状态转移就2种，要么上一个匹配成功，要么这一个匹配成功，其他情况都为0。 我们可以用匹配矩阵来做，让行作为第一个字符串，列为第二个字符串，那么 dp[row][col] 则是第一个字符串第 row 位置和第二个字符串第 col 位置最大的匹配长度。 递推关系为，dp[i][j] = dp[i-1][j-1]+1，当A[i]== B[j]。如果不等的话，dp[i][j]为0. 123456789101112class Solution: def findLength(self, A: List[int], B: List[int]) -&gt; int: m, n = len(A), len(B) dp = [[0 for j in range(n)] for i in range(m)] for i in range(m): for j in range(n): if A[i] == B[j]: if i==0 or j==0: dp[i][j]=1 else: dp[i][j] = dp[i-1][j-1] + 1 return max(map(max,dp)) 10. 正则表达式匹配 给定一个字符串 (s) 和一个字符模式 (p)。实现支持 ‘.’ 和 ’*’ 的正则表达式匹配。 12&apos;.&apos; 匹配任意单个字符。&apos;*&apos; 匹配零个或多个前面的元素。 匹配应该覆盖整个字符串 (s) ，而不是部分字符串。 说明: s 可能为空，且只包含从 a-z 的小写字母。 p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。 示例 1: 12345输入:s = &quot;aa&quot;p = &quot;a&quot;输出: false解释: &quot;a&quot; 无法匹配 &quot;aa&quot; 整个字符串。 示例 2: 12345输入:s = &quot;aa&quot;p = &quot;a*&quot;输出: true解释: &apos;*&apos; 代表可匹配零个或多个前面的元素, 即可以匹配 &apos;a&apos; 。因此, 重复 &apos;a&apos; 一次, 字符串可变为 &quot;aa&quot;。 示例 3: 12345输入:s = &quot;ab&quot;p = &quot;.*&quot;输出: true解释: &quot;.*&quot; 表示可匹配零个或多个(&apos;*&apos;)任意字符(&apos;.&apos;)。 示例 4: 12345输入:s = &quot;aab&quot;p = &quot;c*a*b&quot;输出: true解释: &apos;c&apos; 可以不被重复, &apos;a&apos; 可以被重复一次。因此可以匹配字符串 &quot;aab&quot;。 示例 5: 1234输入:s = &quot;mississippi&quot;p = &quot;mis*is*p*.&quot;输出: false 方法：动态规划 动态方程 dp[i][j] 表示 \(s\) 中 [0, i-1] 这前 \(i\) 个字符与 \(p\) 的 [0, j-1] 这前 \(j\) 个字符组成的表示式是否匹配。 \[ dp[i+1][j+1] = \begin{cases} dp[i][j], &amp; \text{p[j] == &#39;.&#39; or (s[i] == p[j ])} \\[2ex] dp[i+1][j-1] , &amp; \text{p[j] == &#39;*&#39; and p[j-1] 匹配0次} \\[2ex] dp[i+1][j], &amp;\text{p[j] == &#39;*&#39; and p[j -1] 匹配1次} \\[2ex] dp[i][j+1],&amp;\text{p[j] == &#39;*&#39; and p[j-1] 匹配超过1次} \end{cases} \] 123456789101112131415161718class Solution: def isMatch(self, s: str, p: str) -&gt; bool: dp = [[False for _ in range(len(p)+1)] for _ in range(len(s)+1)] dp[0][0] = True for j in range(len(p)): if p[j]=='*': # 星号匹配空 dp[0][j+1] = dp[0][j-1] for i in range(len(s)): for j in range(len(p)): if p[j] == s[i] or p[j]=='.':# 按位比较，相等 dp[i+1][j+1] = dp[i][j] if p[j] =='*':# 星号分两种情况 if p[j-1] != s[i] and p[j-1]!='.': #匹配0次 dp[i+1][j+1] = dp[i+1][j-1] else: # 匹配多次、1次、0次 dp[i+1][j+1] = (dp[i][j+1] or dp[i+1][j] or dp[i+1][j-1]) return dp[len(s)][len(p)] 152. 乘积最大子序列 给定一个整数数组 nums ，找出一个序列中乘积最大的连续子序列（该序列至少包含一个数）。 示例 1: 123输入: [2,3,-2,4]输出: 6解释: 子数组 [2,3] 有最大乘积 6。 示例 2: 123输入: [-2,0,-1]输出: 0解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。 方法：动态规划 思路与 53. 求连续子数组的最大和 相似，都是采用动态规划，maxvalue[i]表示以a[i]为结尾的子数组中最大乘积，同时维护一个全局最大值globalmax。与求子数组的最大和不同的是，还需要维记录子数组最小乘积minvalue[i]，因为可能会出现 负 × 负 = 正的情况。并且最大最小乘积只可能出现在 maxvalue[i−1]×a[i], minvalue[i−1]×a[i], a[i]三者之间。 12345678910class Solution: def maxProduct(self, nums: List[int]) -&gt; int: maxvalue = minvalue = nums[0] globalmax = nums[0] for i in range(1, len(nums)): lastmax = maxvalue maxvalue = max(minvalue * nums[i], lastmax * nums[i], nums[i])#当前最大 minvalue = min(minvalue * nums[i], lastmax * nums[i], nums[i])#当前最小 globalmax = max(globalmax, maxvalue) # 全局最大 return globalmax 300. 最长上升子序列 给定一个无序的整数数组，找到其中最长上升子序列的长度。 示例: 123输入: [10,9,2,5,3,7,101,18]输出: 4 解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。 说明: 可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。 你算法的时间复杂度应该为 O(n2) 。 进阶: 你能将算法的时间复杂度降低到 O(n log n) 吗? 方法：动态规划 数组 dp 的 dp[i] 是保存到第 i 位置为止的最长递增子序列的长度。 最后求所有位置的最大值，而不是 dp 的最后元素。 递推式： 123循环位置i之前的所有元素 j ： 如果 num[j] &lt; nums[i]: 当前最大dp[i] = max&#123;dp[i], dp[j]+1&#125;,此时dp[j]已经是j位置为止的最大长度 12345678910class Solution: def lengthOfLIS(self, nums: List[int]) -&gt; int: if not nums: return 0 dp = [1]*len(nums) for i in range(1, len(nums)): for j in range(0,i): if nums[j] &lt; nums[i]: dp[i] = max(dp[i], dp[j]+1) return max(dp) 91. 解码方法 一条包含字母 A-Z 的消息通过以下方式进行了编码： 1234&apos;A&apos; -&gt; 1&apos;B&apos; -&gt; 2...&apos;Z&apos; -&gt; 26 给定一个只包含数字的非空字符串，请计算解码方法的总数。 示例 1: 123输入: &quot;12&quot;输出: 2解释: 它可以解码为 &quot;AB&quot;（1 2）或者 &quot;L&quot;（12）。 示例 2: 123输入: &quot;226&quot;输出: 3解释: 它可以解码为 &quot;BZ&quot; (2 26), &quot;VF&quot; (22 6), 或者 &quot;BBF&quot; (2 2 6) 。 方法 和爬楼梯的题目非常像，直接使用dp。 dp[i]代表解析s[:i]字符串所有可能的方式数目 12345678910class Solution: def numDecodings(self, s: str) -&gt; int: dp = [0]*(len(s)+1) dp[0] = 1 for i in range(1, len(dp)): if s[i-1] != '0': dp[i] = dp[i-1] if i!=1 and '09'&lt;s[i-2:i]&lt;'27': dp[i] += dp[i-2] return dp[-1] 279. 完全平方数 给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。 示例 1: 输入: n = 12 输出: 3 解释: 12 = 4 + 4 + 4. 示例 2: 输入: n = 13 输出: 2 解释: 13 = 4 + 9. 方法 343. 整数拆分 给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。 示例 1: 123输入: 2输出: 1解释: 2 = 1 + 1, 1 × 1 = 1。 示例 2: 1234输入: 10输出: 36解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。说明: 你可以假设 n 不小于 2 且不大于 58。 分析 暴力解法：回溯遍历将一个数做分割的所有可能性。O(2^n) 方法一 观察n从2到13时的情形： 1234567891011122 -&gt; 1 * 13 -&gt; 2 * 14 -&gt; 2 * 25 -&gt; 3 * 26 -&gt; 3 * 37 -&gt; 3 * 2 * 28 -&gt; 3 * 3 * 29 -&gt; 3 * 3 * 310 -&gt; 3 * 3 * 2 * 211 -&gt; 3 * 3 * 3 * 212 -&gt; 3 * 3 * 3 * 313 -&gt; 3 * 3 * 3 * 2 * 2 从上面可以找到如下规律： 12345n / 3 &lt;= 1 时，分为两个数的乘积，尽量均摊n / 3 &gt; 1 时，分为若干个3和2的乘积n % 3 == 0 时，分为n个3的乘积n % 3 == 1 时，分为n-1个3和两个2的乘积n % 3 == 2 时，分为n个3和一个2的乘积 数学证明可以参考LeetCode Discuss：https://leetcode.com/discuss/98276/why-factor-2-or-3-the-math-behind-this-problem 123456789101112class Solution: def integerBreak(self, n: int) -&gt; int: div = n // 3 if div &lt;= 1: return (n // 2) * (n // 2 + n % 2) mod = n % 3 if mod == 0: return 3 ** div elif mod == 1: return 3 ** (div - 1) * 4 elif mod == 2: return 3 ** div * 2 方法二：动态规划 dp[i]表示整数i拆分可以得到的最大乘积，则dp[i]只与dp[i - 2], dp[i - 3]两个状态有关得到状态转移方程： dp[x] = max(3 * dp[x - 3], 2 * dp[x - 2]) 当x &lt;= 3时，需要对结果进行特判。 12345678class Solution: def integerBreak(self, n: int) -&gt; int: if n &lt;= 3: return n - 1 dp = [0] * (n + 1) dp[2], dp[3] = 2, 3 for x in range(4, n + 1): dp[x] = max(3 * dp[x - 3], 2 * dp[x - 2]) return dp[n]]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>LeetCode</tag>
        <tag>数据结构</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python解leetcode图的最短路径问题]]></title>
    <url>%2F2019%2F08%2F07%2Fpython_leetcode%E5%9B%BE%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[学习目标： Dijkstra算法 Floyd-Warshall算法 Bellman-Ford算法 spfa算法 leetcode743. 网络延迟时间 leetcode787. K 站中转内最便宜的航班 Dijkstra(迪杰斯特拉)算法 典型的单源最短路径算法，用于计算一个节点到其他所有节点的最短路径。主要特点是以起始点为中心向外层层扩展，直到扩展到终点为止。注意该算法要求图中不存在负权边。时间复杂度O(n^2) 具体步骤： 找出路径最近的节点S，即可在最短时间内前往的节点 对于该节点的所有邻居，检查是否有经过S前往它们的更短路径，若有，就更新其路径距离。 重复前两步，直到对每个节点都这样做了。 计算最终距离。 Floyd-Warshall（弗洛伊德算法） 又称为插点法，是一种利用动态规划的思想寻找给定的加权图中多源点之间最短路径的算法，与Dijkstra算法类似。 时间复杂度O(n^3) Bellman-Ford算法 是求含负权图的单源最短路径的一种算法，效率较低，代码难度较小。其原理为连续进行松弛，在每次松弛时把每条边都更新一下，若在n-1次松弛后还能更新，则说明图中有负环，因此无法得出结果，否则就完成。 初始化：将除源点外的所有顶点的最短距离估计值 d[v] ——&gt;+∞, d[s]——&gt;0; 迭代求解：反复对边集E中的每条边进行松弛操作，使得顶点集V中的每个顶点v的最短距离估计值逐步逼近其最短距离；（运行|v|-1次） 检验负权回路：判断边集E中的每一条边的两个端点是否收敛。如果存在未收敛的顶点，则算法返回false，表明问题无解；否则算法返回true，并且从源点可达的顶点v的最短距离保存在 d[v]中。 743. 网络延迟时间 有 N 个网络节点，标记为 1 到 N。 给定一个列表 times，表示信号经过有向边的传递时间。 times[i] = (u, v, w)，其中 u 是源节点，v 是目标节点， w 是一个信号从源节点传递到目标节点的时间。 现在，我们向当前的节点 K 发送了一个信号。需要多久才能使所有节点都收到信号？如果不能使所有节点收到信号，返回 -1。 注意: N 的范围在 [1, 100] 之间。 K 的范围在 [1, N] 之间。 times 的长度在 [1, 6000] 之间。 所有的边 times[i] = (u, v, w) 都有 1 &lt;= u, v &lt;= N 且 0 &lt;= w &lt;= 100。 题目大意 单源有向加权图中，求源节点K到所有其它目标节点的最短路径，取最大值。如果有节点不可抵达，返回-1. 方法1：Dijkstra算法 时间复杂度是 O(N ^ 2 + E)，空间复杂度是O(N+E). 12345678910111213141516171819class Solution: def networkDelayTime(self, times: List[List[int]], N: int, K: int) -&gt; int: K -= 1 # 起点 nodes = collections.defaultdict(list) # 存储节点的邻接点和相连边的权重。 for u,v,w in times: nodes[u-1].append((v-1, w)) dist = [float('inf')] * N # 起点到所有节点距离。 dist[K] = 0 done = set() # 记录处理过的节点 for _ in range(N): # 获取离起点最近的节点 smallest = min((d,i) for (i,d) in enumerate(dist) if i not in done)[1] for v,w in nodes[smallest]:#找最近点的所有邻接点。 if v not in done and dist[smallest]+w &lt; dist[v]: # 更新邻接点的距离 dist[v] = dist[smallest]+w done.add(smallest) # 该节点标记为处理过 return -1 if float('inf') in dist else max(dist) 方法2:Floyd-Warshall算法。 这个算法超时 Time Limit Exceed(TLE). 时间复杂度O(n^3)， 空间复杂度O(n^2)。 12345678910111213class Solution: def networkDelayTime(self, times: List[List[int]], N: int, K: int) -&gt; int: d = [[float('inf')] * N for _ in range(N)] # 二维矩阵 for time in times: u, v, w = time[0] - 1, time[1] - 1, time[2] d[u][v] = w for i in range(N): d[i][i] = 0 for k in range(N): # 遍历更新距离 for i in range(N): for j in range(N): d[i][j] = min(d[i][j], d[i][k] + d[k][j]) return -1 if float('inf') in d[K - 1] else max(d[K - 1]) 方法3：Bellman-Ford算法 这个算法超时TLE。 时间复杂度O(ne)， 空间复杂度O(n)。 1234567891011class Solution: def networkDelayTime(self, times: List[List[int]], N: int, K: int) -&gt; int: dist = [float('inf')] * N dist[K - 1] = 0 for _ in range(N): for time in times: u = time[0] - 1 v = time[1] - 1 w = time[2] dist[v] = min(dist[v], dist[u] + w) return -1 if float('inf') in dist else max(dist) 787. K 站中转内最便宜的航班 有 n 个城市通过 m 个航班连接。每个航班都从城市 u 开始，以价格 w 抵达 v。 现在给定所有的城市和航班，以及出发城市 src 和目的地 dst，你的任务是找到从 src 到 dst 最多经过 k 站中转的最便宜的价格。 如果没有这样的路线，则输出 -1。 示例 1: 1234输入: n = 3, edges = [[0,1,100],[1,2,100],[0,2,500]]src = 0, dst = 2, k = 1输出: 200 提示： n 范围是 [1, 100]，城市标签从 0 到 n - 1. 航班数量范围是 [0, n * (n - 1) / 2]. 每个航班的格式 (src, dst, price). 每个航班的价格范围是 [1, 10000]. k 范围是 [0, n - 1]. 航班没有重复，且不存在环路 方法：队列+BFS 可以直接判断在指定的k步以内能不能走到dst，不会进行更多的搜索了，因此这个方法要快很多。 这个队列存放的是当我们进行第step次搜索时，搜索到的当前的节点，以及走到当前节点的花费。所以当当前节点走到dst时，更新最小花费。 时间复杂度是O(KN)，空间复杂度是O(N). 123456789101112131415161718192021class Solution: def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, K: int) -&gt; int: graph = collections.defaultdict(dict) for u, v, e in flights: graph[u][v] = e ans = float('inf') que = collections.deque() que.append((src, 0)) step = 0 while que: for i in range(len(que)): cur, cost = que.popleft() if cur == dst: ans = min(ans, cost) #走到dst,更新最小花费 for v, w in graph[cur].items(): # 所有邻居点 if cost + w &gt; ans: continue que.append((v, cost + w)) # 走到当前节点的更小的花费 if step &gt; K: break step += 1 return -1 if ans == float('inf') else ans]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>LeetCode</tag>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《剑指offer》第2章03-15题(python)]]></title>
    <url>%2F2019%2F08%2F06%2Fcoding-interviews_chapter2problem03-15%2F</url>
    <content type="text"><![CDATA[3.数组中重复的数字 4.二维数组中的查找 3.数组中重复的数字 牛客网 online judge 地址 在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。 3.1 可以修改原始数组 方法：交换数字 交换数字到对应位置 1234567891011121314151617class Solution: # 这里要特别注意~找到任意重复的一个值并赋值到duplication[0] # 函数返回True/False def duplicate(self, numbers, duplication): if len(numbers)&lt;2: duplication[0] = -1 return False for i in range(len(numbers)): while i != numbers[i]: if numbers[i] == numbers[numbers[i]]: duplication[0] = numbers[i] return True # 注意这里不能直接multiple assignment temp = numbers[i] numbers[i] = numbers[numbers[i]] numbers[temp] = temp return False 3.2 不能修改原始数组 方法一：二分查找 类似于二分查找，多了一步计数 123456789101112131415161718192021class Solution: # 这里要特别注意~找到任意重复的一个值并赋值到duplication[0] # 函数返回True/False def duplicate(self, numbers, duplication): if len(set(numbers)) == len(numbers): duplication[0] = -1 return False left = 1 right = len(numbers)-1 while left &lt; right: mid = left + (right-left+1)//2 count = 0 for num in numbers: if num &lt; mid: count += 1 if count &lt; mid:# 右半边有重复 left = mid else: # 左半边有重复 right = mid -1 duplication[0] = left return True 方法二：快慢指针 使用快慢指针，判断数组中是否有逻辑上的环存在。寻找环的起点。 注意：题目的返回方式、快慢指针的初始化方式。 123456789101112131415161718class Solution: # 这里要特别注意~找到任意重复的一个值并赋值到duplication[0] # 函数返回True/False def duplicate(self, nums, duplication): if len(set(nums)) == len(nums): duplication[0] = -1 return False fast = nums[nums[0]] slow = nums[0] while fast != slow: fast = nums[nums[fast]] slow = nums[slow] fast = 0 while fast != slow: fast = nums[nums[fast]] slow = nums[slow] duplication[0] = nums[fast] return True]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python解leetcode拓扑排序]]></title>
    <url>%2F2019%2F08%2F05%2Fpython_leetcode-topological-sort%2F</url>
    <content type="text"><![CDATA[在图论中，拓扑排序（Topological Sorting）是一个有向无环图（DAG, Directed Acyclic Graph）的所有顶点的线性序列。且该序列必须满足下面两个条件： 每个顶点出现且只出现一次。 若存在一条从顶点 A 到顶点 B 的路径，那么在序列中顶点 A 出现在顶点 B 的前面。 有向无环图（DAG）才有拓扑排序，非DAG图没有拓扑排序一说。 学习目标： - 实现拓扑排序的 Kahn 算法、DFS 算法 - Leetcode 207.课程表 - Leetcode 210.课程表 II 拓扑排序返回的结果是有向图中所有点依据有向边指向顺序的排列而成的点。 那么该如何获得一个有向图的拓扑排序的结果？ 最直观的方法步骤如下 找到图中入度（indegree）为0的点，然后记录这个点并删除这个点的所有出度（outdegree），也就是连接了这个点的其他点的入度 检查图中是否有入度为0的点，如果有重复步骤（1） 重复步骤（1）-（2）直至无法找到入度为0的点，此时如果记录的点的数目与所有点的数目相同，那么说明图中不存在闭合的环，反之则存在。 应用：拓扑排序通常用来“排序”具有依赖关系的任务。 207. 课程表 Course Schedule 现在你总共有 n 门课需要选，记为 0 到 n-1。 在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: [0,1] 给定课程总量以及它们的先决条件，判断是否可能完成所有课程的学习？ 示例 1: 123输入: 2, [[1,0]] 输出: true解释: 总共有 2 门课程。学习课程 1 之前，你需要完成课程 0。所以这是可能的。 示例 2: 123输入: 2, [[1,0],[0,1]]输出: false解释: 总共有 2 门课程。学习课程 1 之前，你需要先完成​课程 0；并且学习课程 0 之前，你还应先完成课程 1。这是不可能的。 说明: 输入的先决条件是由边缘列表表示的图形，而不是邻接矩阵。详情请参见图的表示法。 你可以假定输入的先决条件中没有重复的边。 提示: 这个问题相当于查找一个循环是否存在于有向图中。如果存在循环，则不存在拓扑排序，因此不可能选取所有课程进行学习。 通过 DFS 进行拓扑排序 - 一个关于Coursera的精彩视频教程（21分钟），介绍拓扑排序的基本概念。 拓扑排序也可以通过 BFS 完成。 方法:队列 遍历有向图中所有的边可以构造出上面提到的两个数据结构，时间复杂度为O(e) 从In-Degree array中找所有点中入度数为0的点，构成初始队列，时间复杂度O(n) 通过队首出列，调整与队首元素出度相连的所有点的入度数，并检查这些点的入度数是否为0，若是则入队列 重复步骤(3)直至队列为空，此时若从队列中出列的所有点的数目为原来有向图中所有点的数目，则图中不存在闭合的环，且出列的顺序是一种可行的遍历方法。步骤(3)(4)的时间复杂度为O(n+e) 123456789101112131415161718192021222324class Solution: def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -&gt; bool: indegree = [0 for i in range(numCourses)] # 每个元素的入度数 (先决条件数) connection = &#123;i:[] for i in range(numCourses)&#125; # 存放每个元素的出度连接的所有元素 for link in prerequisites: connection[link[1]].append(link[0]) indegree[link[0]] += 1 zero_indegree = [] # （先觉条件为0）入度数为0的元素要入队 for i in range(numCourses): if indegree[i]==0: zero_indegree.append(i) i=0 #遍历队列中的元素，出队的元素的相连接所有元素元素都可以-1减少一个先决条件 while i&lt;len(zero_indegree): for node in connection[zero_indegree[i]]: indegree[node] -= 1 if indegree[node] == 0: zero_indegree.append(node)# 入队 i += 1 if len(zero_indegree) == numCourses: return True else: return False 210. 课程表 II Course Schedule II 现在你总共有 n 门课需要选，记为 0 到 n-1。 在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: [0,1] 给定课程总量以及它们的先决条件，返回你为了学完所有课程所安排的学习顺序。 可能会有多个正确的顺序，你只要返回一种就可以了。如果不可能完成所有课程，返回一个空数组。 示例 1: 123输入: 2, [[1,0]] 输出: [0,1]解释: 总共有 2 门课程。要学习课程 1，你需要先完成课程 0。因此，正确的课程顺序为 [0,1] 。 示例 2: 1234输入: 4, [[1,0],[2,0],[3,1],[3,2]]输出: [0,1,2,3] or [0,2,1,3]解释: 总共有 4 门课程。要学习课程 3，你应该先完成课程 1 和课程 2。并且课程 1 和课程 2 都应该排在课程 0 之后。 因此，一个正确的课程顺序是 [0,1,2,3] 。另一个正确的排序是 [0,2,1,3] 。 方法 同207题的解法一样，只需要修改return即可 123456789101112131415161718192021222324class Solution: def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -&gt; List[int]: indegree = [0 for i in range(numCourses)] # 每个元素的入度数 (先决条件数) connection = &#123;i:[] for i in range(numCourses)&#125; # 存放每个元素的出度连接的所有元素 for link in prerequisites: connection[link[1]].append(link[0]) indegree[link[0]] += 1 zero_indegree = [] # （先觉条件为0）入度数为0的元素要入队 for i in range(numCourses): if indegree[i]==0: zero_indegree.append(i) i=0 #遍历队列中的元素，出队的元素的相连接所有元素元素都可以-1减少一个先决条件 while i&lt;len(zero_indegree): for node in connection[zero_indegree[i]]: indegree[node] -= 1 if indegree[node] == 0: zero_indegree.append(node)# 入队 i += 1 if len(zero_indegree) == numCourses: return zero_indegree else: return [] 参考 LeetCode 解题报告(207,210)–拓扑排序(Topological Sort)]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>LeetCode</tag>
        <tag>图</tag>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[csv文件与字典之间的转换]]></title>
    <url>%2F2019%2F08%2F03%2Fcsv%E6%96%87%E4%BB%B6%E4%B8%8E%E5%AD%97%E5%85%B8%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[csv文件转换为字典 第一行为key，其余行为value 每一行为key,value的记录 字典转换为csv文件 第一行为key，其余行为value 每一行为key,value的记录 字典转换为csv文件 每一行为key,value的记录 第一行为key，其余行为value 输出列表字典 每一行为key,value的记录 12345def dict2csv(dict,file): with open(file,'w') as f: w=csv.writer(f) # write each key/value pair on a separate row w.writerows(dict.items()) 参考 csv文件与字典，列表等之间的转换小结【Python】]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客小白月赛16题解]]></title>
    <url>%2F2019%2F07%2F13%2F%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B16%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[本文来自牛客网的小白月赛16的题 A 小石的签到题 B 小雨的三角形 C 小石的海岛之旅 D 小阳买水果 E 小雨的矩阵 F 小石的妹子 G 小石的图形 H 小阳的贝壳 I 石头剪刀布 J 小雨坐地铁 A-小石的签到题 牛客小白月赛16-A小石的签到题 小石和小阳玩游戏，一共有 \(n\) 个数，分别为 \(1∼n\) 。两人轮流取数，小石先手。对于每轮取数，都必须选择剩下数中的任意一个数 \(x\)，同时还要取走 \(x,⌊\frac{x}{2}⌋,⌊\frac{⌊\frac{x}{2}⌋}{2}⌋…\) 如果某个数不存在，就停止取数（不能一个数都不取）。谁取走最后一个数，谁就输了。小石想知道自己能否获胜。 如果小石能赢，输出 “Shi”，否则输出 “Yang”（均不输出引号）。 输入描述:共一行，输入一个数 \(n\) 。 输出描述:共一行，输出 “Shi” 或 “Yang”（不输出引号）。 示例1: 输入1，输出 Yang 说明：小石只能取走 1，小阳赢。 示例2 输入2，输出Shi 说明：若小石取走 1，则小阳只能取走 2，小石赢。 备注:\(1 ≤n≤10^3\) 方法：博弈论SG 我们发现当 \(n&gt;1\) 时先手（小石）总是赢。 如何证明：一开始有 \(1∼n\) , \(n\) 个数，假设先手必败，那么先手选 1，后手就进入了必败状态。 所以假设错误，那么先手就不是必败，先手一定有一种方式能赢。 12345n = int(input())if n==1: print('Yang')else: print('Shi') B-小雨的三角形 牛客小白月赛16-B小雨的三角形 小雨手上有一个填满了数字的三角形。这个三角形一共有 \(n\) 层，其中第 \(i\) 层共有 \(i\) 个数，且第 1 个数和第 \(i\) 个数均为 \(i\) 。其余的数中，第 \(j\) 个数是上一层中第 \(j−1\) 个数和第 \(j\) 个数的和。小雨想知道这个三角形第 \(x\) 层到第 \(y\) 层所有数的和，一共有 \(m\) 个询问。 输入描述: 第一行两个正整数 \(n,m\)，表示这个三角形的层数和询问个数。 接下来 \(m\) 行，每行两个正整数 \(x,y\)，表示一次询问。 输出描述: 输出共 \(m\) 行，每行两个整数，表示一组询问的答案，对 \(10^9+7\) 取模。 示例1 123456789101112131415161718输入5 31 21 53 5输出58378说明画出这个三角形：12 23 4 34 7 7 45 11 14 11 5 第1-2层的和为 \(1+2+2 = 5\) 第1-5层的和为 \(1+2+2+3+4+3+4+7+7+4+5+11+14+11+5 = 83\) 第3-5层的和为 \(3+4+3+4+7+7+4+5+11+14+11+5 = 78\) 备注：\(1 ≤n≤10^3, 1≤x≤y≤n\) 方法：数学 数据范围给的很小，可以 \(O(n^2)\) 暴力构造三角形，预处理出每一行的总和，每个询问把 \(x∼y\) 行的和加起来即可（若预处理出第 \(1∼i\) 行的和，则可以做到 \(O(1)\) 查询）。 更快的做法？每一行的和其实是有规律的，分别为 \(1,4,10,22,46,94⋯\)，除了第 1 行的和为 1 外，第 \(i\) 行的和为 \(6⋅2i−2−2\)，那么第 \(1∼i (i&gt;1)\) 行的和为 \[ 1+6⋅20−2+6⋅22−2+6⋅23−2+⋯+6⋅2i−2−2\\ =1+6⋅(2i−1−1)−2⋅(i−1)\\ =6⋅2i−1−2⋅i−3\\ \] 所以第 \(x∼y\) 行的和就能用前缀和计算出 \(3(2^{y}-2^{x-1}) + 2(x-y)-2\)，注意特判 \(x=1,x=2,y=1\) 的情况，这样就能够每次 \(O(log⁡n)\) 查询。 12345n,m = map(int, input().split(' '))M = int(1e9+7)for _ in range(m): x, y = map(int, input().split(' ')) print((3*(2**y - 2**(x-1)) + 2*(x-y) - 2)%M) C-小石的海岛之旅 牛客小白月赛16-C小石的海盗之旅 暑假到了，小石和小雨到海岛上玩。 从水平方向看海岛可以看成 \(n\) 个小块，每一个小块都有一个高度 \(h_i\)， 水位一开始为 0，随着水位的上升，海岛分成了若干块。现在有 \(m\) 个询问，求当水位为 \(a_i\) 时，海岛会分成多少块。 输入描述: 第一行输入两个正整数 n,m，分别表示海岛小块个数和询问个数。 第二行输入 n 个整数 \(h_i\)，表示每一块的高度。 第三行输入 m个整数 ai，表示每一个询问，保证输入的 ai 单调递增。 输出描述: 共 m 行，分别对应 m 个询问的答案。 示例1 123456789101112131415输入7 31 2 3 1 2 1 31 2 3输出320说明当水位高度为 1 时，岛屿被分成 3 块，2 3；2；3当水位高度为 2 时，岛屿被分成 2 块：3；3 。当水位高度为 3 时，岛屿全部被淹没，剩余 0 块 。 方法：枚举 123456789n, m = map(int, input().split())h = list(map(int, input().split()))a = list(map(int, input().split()))for a_i in a: ans = int(h[0] &gt; a_i) #第一块高于水位是1，低于水位是0 for j in range(1, len(h)): if h[j]&gt;a_i and h[j-1]&lt;=a_i: ans += 1 print(ans) D-小阳买水果 牛客小白月赛16-D小阳买水果 水果店里有 \(n\) 个水果排成一列。店长要求顾客只能买一段连续的水果。 小阳对每个水果都有一个喜爱程度 \(a_i\)，最终的满意度为他买到的水果的喜欢程度之和。 如果和为正（不管是正多少，只要大于 0 即可），他就满意了。 小阳想知道在他满意的条件下最多能买多少个水果。 你能帮帮他吗？ 输入描述: 第一行输入一个正整数 n，表示水果总数。 第二行输入 n 个整数 \(a_i\)，表示小阳对每个水果的喜爱程度。 输出描述: 一行一个整数表示结果。 示例1 12345输入50 0 -7 -6 1输出1 方法：和大于0的最长连续子序列 python超时很难通过，用C++ 遍历i从1-n，前i个数中，找到那个比s小的最左边位置，设为r, r-i之间的子串就是最长子串。 所有满足条件的子串的0~右边界的和 \(&gt;\) 0~左边界的和，所以要找到那个最左边的左边界。 123456789101112131415161718192021222324252627282930#include&lt;bits/stdc++.h&gt;using namespace std;int a[2000061],s,x,ans;int main()&#123; int n; scanf("%d",&amp;n); for(int i=1; i&lt;=n; i++) &#123; scanf("%d",&amp;x); s+=x; a[i]=min(a[i-1],s); int l=0,r=i-1; while(l&lt;=r) &#123; int mid=(l+r)/2; if(a[mid]&lt;s) &#123; r=mid-1; &#125; else l=mid+1; &#125; if(r!=-2) &#123; ans=max(ans,i-r-1); &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl;&#125; E-小雨的矩阵 牛客小白月赛16-E小雨的矩阵 雨有一个 n×n 的矩阵，起点在(1,1)，终点在(n,n)，只能向下或向右走，且每次只能走 1 步。矩阵上每个点都有一个点权 \(a_{i,j}\) 。 求走到终点的路径有多少不同的点权和。 输入描述: 第一行，输入一个正整数 n 。 接下来 n+1 行，每行 n 个数，表示 \(a_{i,j}\) 输出描述: 共一行，输出有多少不同的点权和。 示例1 123456输入21 52 4输出2 备注: \(1 ≤n≤8, 0 ≤a_{i,j}≤50\) 方法：遍历+递归 从 (1,1) 爆搜到(n,n)，把答案去一下重即可。 12345678910111213141516171819n = int(input())a = []for _ in range(n): a.append(list(map(int, input().split())))path = [] #不同的路径def dp(num,i,j): num+=a[i][j] if i==n-1 and j==n-1 and (num not in path) : path.append(num) return 0 if(i&lt;n-1): dp(num,i+1,j); if(j&lt;n-1): dp(num,i,j+1); dp(0,0,0)print(len(path)) G-小石的图形 牛客小白月赛16-G小石的图形 小石想在一面墙旁边建造一段长度为 n 的篱笆来围出一块地。 求最大的地的面积。 输入描述: 共一行，输入一个整数 n 。 输出描述:共一行，输出最大面积，保留 3 位小数。 示例1 12输入1输出0.159 备注:\(1 ≤n≤10^3\) 方法：数学几何 发现半圆时面积最大（显然）。 \(n=πR, R=\frac{πR^2}{2} = \frac{n^2}{2π}\) 面积 \(n=πR, R=\frac{n}{π}\) 1print("%.3f"%(int(input())**2/6.2831853)) 参考 牛客小白月赛16题解]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>牛客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python解leetcode贪心算法]]></title>
    <url>%2F2019%2F07%2F04%2Fpython_leetcode-greedy-algorithms%2F</url>
    <content type="text"><![CDATA[跳跃游戏 II 跳跃游戏 移掉K位数字 分发饼干 判断子序列（不需要连续） 贪心算法就是每次都贪心地选择当前最好的那个(局部最优解)，不去考虑以后的情况，而且选择了就不能够“反悔”了，如果原问题满足贪心选择性质和最优子结构，那么最后得到的解就是最优解。 每一步的最优解一定包含上一步的最优解。 区别于其他算法： 动态规划：每次都是综合所有子问题的解得到当前的最优解(全局最优解)，而不是贪心地选择； 回溯法：尝试选择一条路，如果选择错了的话可以“反悔”，也就是回过头来重新选择其他的试试。 45. 跳跃游戏 II 给定一个非负整数数组，你最初位于数组的第一个位置。 数组中的每个元素代表你在该位置可以跳跃的最大长度。 你的目标是使用最少的跳跃次数到达数组的最后一个位置。 示例: 输入: [2,3,1,1,4] 输出: 2 解释: 跳到最后一个位置的最小跳跃数是 2。 从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。 说明: 假设你总是可以到达数组的最后一个位置。 方法：贪心算法 我们每次贪心的找在自己当前能到达的几个位置里面，跳到哪个位置的时候，在下一步能跳的最远。然后，我们当前步就跳到这个位置上去，所以我们在这一步的跳跃时，给下一步留下了最好的结果。 所以，使用一个cur表示当前步能到达的最远位置，使用pre表示上一次能到达的最远位置。所以，我们应该遍历在上一步的覆盖范围内，当前能跳的最远位置来更新cur。一个节省计算资源的方式是，保存以前已经检查了的位置为Pos，这样每次检查的范围是pos~pre。 12345678910111213class Solution: def jump(self, nums: List[int]) -&gt; int: cur = 0 pre = 0 jump = 0 # 需要跳跃多少次 pos = 0 # 当前的位置 while cur &lt; len(nums)-1: jump +=1 #一轮跳跃一步 pre = cur # 上一步能跨越最远的位置给了pre while pos &lt;= pre: cur = max(cur,pos+nums[pos]) # cur是当前范围内能跨越最远的位置 pos += 1 return jump 55. 跳跃游戏 给定一个非负整数数组，你最初位于数组的第一个位置。 数组中的每个元素代表你在该位置可以跳跃的最大长度。 判断你是否能够到达最后一个位置。 示例 1: 123输入: [2,3,1,1,4]输出: true解释: 从位置 0 到 1 跳 1 步, 然后跳 3 步到达最后一个位置。 示例 2: 123输入: [3,2,1,0,4]输出: false解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。 方法：贪心算法 用一个变量reach保存当前能到达的最后位置索引，那么在每个位置的时候判断这个位置能不能到达，即位置的索引大于了reach说明前面无论怎么走也走不到这个位置，就返回False 12345678class Solution: def canJump(self, nums: List[int]) -&gt; bool: reach = 0 for i, num in enumerate(nums): if i&gt;reach: return False reach = max(reach, i+num) return True 402. 移掉K位数字 给定一个以字符串表示的非负整数 num，移除这个数中的 k 位数字，使得剩下的数字最小。 注意: num 的长度小于 10002 且 ≥ k。 num 不会包含任何前导零。 示例 1 : 123输入: num = &quot;1432219&quot;, k = 3输出: &quot;1219&quot;解释: 移除掉三个数字 4, 3, 和 2 形成一个新的最小的数字 1219。 示例 2 : 123输入: num = &quot;10200&quot;, k = 1输出: &quot;200&quot;解释: 移掉首位的 1 剩下的数字为 200. 注意输出不能有任何前导零。 示例 3 : 123输入: num = &quot;10&quot;, k = 2输出: &quot;0&quot;解释: 从原数字移除所有的数字，剩余为空就是0。 方法：栈 遍历数字字符串，当当前的字符比栈最后的字符小的时候，说明要把栈的最后的这个字符删除掉。然后用现在的字符进行替换，是不是数字比以前的那种情况更小了？所以同样的道理，做一个while循环！ 最后，如果K还没用完，那要删除哪里的字符呢？毋庸置疑肯定是最后的字符，因为前面的字符都是小字符。 1234567891011121314151617181920class Solution: def removeKdigits(self, num: str, k: int) -&gt; str: if len(num) == k: return '0' stack = [] for n in num: # while每轮循环删除局部最大值 while stack and k and int(stack[-1]) &gt; int(n): stack.pop() # 删除栈中最大的一个值 k -= 1 stack.append(n) # 栈里的值由小到大,新加入栈的值最大 while k: # k还有剩余 stack.pop() k -= 1 if not stack: return '0' return str(int(''.join(stack))) 455. 分发饼干 假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。对每个孩子 i ，都有一个胃口值 gi ，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j ，都有一个尺寸 sj 。如果 sj &gt;= gi ，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。 注意： 你可以假设胃口值为正。 一个小朋友最多只能拥有一块饼干。 示例 1: 12345678输入: [1,2,3], [1,1]输出: 1解释: 你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。所以你应该输出1。 示例 2: 12345678输入: [1,2], [1,2,3]输出: 2解释: 你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。你拥有的饼干数量和尺寸都足以让所有孩子满足。所以你应该输出2. 方法：贪心算法 首先对贪婪系数g、饼干尺寸s从小到大排序 令指针i指向g的末尾，指针j指向s的末尾 当g和s均≥0时，执行循环： 若g[i] ≤ s[j] 则令计数器+1，并令j -= 1 （将j号饼干分配给i号孩子，并令j指向下一个更小的饼干） 令i -= 1 （将i指向下一个贪婪系数更小的孩子） 123456789101112class Solution: def findContentChildren(self, g: List[int], s: List[int]) -&gt; int: g.sort() s.sort() # 排序 cnt = 0 i, j = len(g) - 1, len(s) - 1 while min(i, j) &gt;= 0: if g[i] &lt;= s[j]: cnt += 1 j -= 1 #下一个更小的饼干 i -= 1 #下一个胃口更小的孩子 return cnt 392. 判断子序列 方法]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>LeetCode</tag>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python解leetcode字符串(2)]]></title>
    <url>%2F2019%2F07%2F02%2Fpython_leetcode-string(2)%2F</url>
    <content type="text"><![CDATA[最长回文子串 最长公共前缀 报数 字符串相乘 最后一个单词的长度 二进制求和 验证回文串 反转字符串中的元音字母 赎金信 5. 最长回文子串 最长回文子串 给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。 示例 1： 123输入: “babad”输出: “bab”注意: “aba” 也是一个有效答案。 示例 2： 12输入: “cbbd”输出: “bb” 方法：马拉车算法 马拉车算法(Manacher’s algorithm)是用来查找一个字符串的最长回文子串的线性方法，由一个叫Manacher的人在1975年发明的，这个方法的最大贡献是在于将时间复杂度提升到了线性，这是非常了不起的。 思路： 对字符串进行预处理，两个字符之间加上特殊符号 # 用一个列表 P 来记录以每个字符 i 为中心的回文长度， 遍历整个字符串： 比较 若 i 小于最右边界：那就找它相对i的对称位置，得出回文长度，要是对称位置的回文长度更长，则选择更小的 右边界-i, 否则 P[i] 就取为0 +1循环，扩展探索 i 的边界 如果它的边界超过右边界，则取而代之 最后取得最长回文。 123456789101112131415161718192021222324252627282930313233343536class Solution: def longestPalindrome(self, s): """ :type s: str :rtype: str """ def preProcess(s): if not s: return ['^', '$'] T = ['^'] for c in s: T += ['#', c] T += ['#', '$'] return T T = preProcess(s) P = [0] * len(T) center, right = 0, 0 for i in range(1, len(T)-1): i_mirror = 2 * center-i if right &gt; i: P[i] = min(right-i, P[i_mirror]) else: P[i] = 0 while T[i + 1 + P[i]] == T[i - 1 - P[i]]: P[i] += 1 if i + P[i] &gt; right: center, right = i, i+P[i] max_i = 0 for i in range(1, len(T)-1): if P[i] &gt; P[max_i]: max_i = i start = round((max_i - 1 - P[max_i]) / 2) return s[start : start + P[max_i]] Time Complexity: O(n) Auxiliary Space: O(n) 14. 最长公共前缀 编写一个函数来查找字符串数组中的最长公共前缀。 如果不存在公共前缀，返回空字符串 “”。 示例 1: 12输入: [“flower”,“flow”,“flight”]输出: “fl” 示例 2: 123输入: [“dog”,“racecar”,“car”]输出: “”解释: 输入不存在公共前缀。 说明:所有输入只包含小写字母 a-z 。 方法：用 zip() 和 set() 函数 如果set()的长度大于1，则返回当前的最长公共前缀。enumerate(zip(*strs)) 返回每个单词的字符序号和元组。 123456789101112class Solution: def longestCommonPrefix(self, strs): """ :type strs: List[str] :rtype: str """ if not strs: return "" for i, letter_group in enumerate(zip(*strs)): if len(set(letter_group)) &gt; 1: return strs[0][:i] return min(strs) Time Complexity: O(n) 38. 报数 报数序列是一个整数序列，按照其中的整数的顺序进行报数，得到下一个数。其前五项如下： 123451. 12. 113. 214. 12115. 111221 1 被读作 “one 1” (“一个一”) , 即 11。 11 被读作 “two 1s” (“两个一”）, 即 21。 21 被读作 “one 2”, “one 1” （“一个二” , “一个一”) , 即 1211。 给定一个正整数 n（1 ≤ n ≤ 30），输出报数序列的第 n 项。 注意：整数顺序将表示为一个字符串。 示例 1: 12输入: 1输出: &quot;1&quot; 示例 2: 12输入: 4输出: &quot;1211&quot; 方法 外循环遍历序数，内循环统计个数和连接字符串 1234567891011121314151617181920class Solution: def countAndSay(self, n: int) -&gt; str: res = '1' for i in range(n-1): pre = res[0] # 初始化 count = 1 ans = '' # 对上一结果进行计数和拼接字符 for j in range(1, len(res)): cur = res[j] # 遍历res中的字符来统计个数 if cur == pre: count +=1 else: ans = ans + str(count) + str(pre) pre = cur count = 1 res = ans + str(count) + str(pre) # 拼接j循环的最后一个字符 return res 43. 字符串相乘 给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。 示例 1: 12输入: num1 = “2”, num2 = “3”输出: “6” 示例 2: 12输入: num1 = “123”, num2 = “456”输出: “56088” 说明： num1 和 num2 的长度小于110。 num1 和 num2 只包含数字 0-9。 num1 和 num2 均不以零开头，除非是数字 0 本身。 不能使用任何标准库的大数类型（比如 BigInteger）或直接将输入转换为整数来处理。 方法 按乘法运算的方式来实现 123456789101112131415161718class Solution: def multiply(self, num1: str, num2: str) -&gt; str: res = [0] * (len(num1) + len(num2)) # 初始化，存放乘积的数组 pos = len(res) - 1 for n1 in reversed(num1): tempPos = pos for n2 in reversed(num2): res[tempPos] += int(n1) * int(n2) res[tempPos - 1] += res[tempPos] // 10 # 进位 res[tempPos] %= 10 # 取余 tempPos -= 1 pos -= 1 st = 0 while st &lt; len(res) - 1 and res[st] == 0: # 统计前面有几个0 st += 1 return ''.join(map(str, res[st:])) # 去掉0，变成字符串 58. 最后一个单词的长度 给定一个仅包含大小写字母和空格 ’ ’ 的字符串，返回其最后一个单词的长度。 如果不存在最后一个单词，请返回 0 。 说明：一个单词是指由字母组成，但不包含任何空格的字符串。 示例: 输入: “Hello World” 输出: 5 方法：库函数 123class Solution: def lengthOfLastWord(self, s: str) -&gt; int: return len(s.strip().split(' ')[-1]) 67. 二进制求和 给定两个二进制字符串，返回他们的和（用二进制表示）。 输入为非空字符串且只包含数字 1 和 0。 示例 1: 12输入: a = &quot;11&quot;, b = &quot;1&quot;输出: &quot;100&quot; 示例 2: 12输入: a = &quot;1010&quot;, b = &quot;1011&quot;输出: &quot;10101&quot; 方法：进制转换函数 先将两个加数转成10进制，再把和转换成二进制返回即可。虽然速度还挺快的，但这么做忽略了可能的大整数相加的细节（因为Python帮你处理了）。 123class Solution: def addBinary(self, a: str, b: str) -&gt; str: return bin(int(a,2) + int(b,2))[2:] 125. 验证回文串 给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。 说明：本题中，我们将空字符串定义为有效的回文串。 示例 1: 12输入: &quot;A man, a plan, a canal: Panama&quot;输出: true 示例 2: 12输入: &quot;race a car&quot;输出: false 方法：列表生成式 isalnum()能判断字符是不是字母数字的，用列表表达式就能产生有效字符串，然后就可以看是不是回文。 12345class Solution: def isPalindrome(self, s: str) -&gt; bool: isvalid = lambda x : x == x[::-1] string = ''.join([x for x in s.lower() if x.isalnum()]) return isvalid(string) 方法：正则表达式 替换非字母数字字符 1234567891011121314class Solution: def isPalindrome(self, s: str) -&gt; bool: s = s.lower() s = re.sub('\W', '', s) # 正则 sub替换, \W匹配任何非单词字符。等价于 '[^A-Za-z0-9_]'。 N = len(s) left, right = 0, N-1 while left &lt;= right: if s[left] != s[right]: return False left += 1 right -= 1 return True 345. 反转字符串中的元音字母 编写一个函数，以字符串作为输入，反转该字符串中的元音字母。 示例 1: 12输入: &quot;hello&quot;输出: &quot;holle&quot; 示例 2: 12输入: &quot;leetcode&quot;输出: &quot;leotcede&quot; 说明: 元音字母不包含字母“y”。 方法：栈 这个题的意思是把收尾向中间走的时候遇到的所有元音字符换位置。也就是说 “abecui”–&gt;“ibucea”; 把某个东西进行翻转，很容易想到栈。所以把元音字符进栈，再次遍历的时候遇到元音字符就出栈即可。 123456789101112131415class Solution: def reverseVowels(self, s: str) -&gt; str: vstack = [] for c in s: if c in "aeiouAEIOU": vstack.append(c) res = [] for c in s: if c in "aeiouAEIOU": res.append(vstack.pop()) else: res.append(c) return ''.join(res) 383. 赎金信 给定一个赎金信 (ransom) 字符串和一个杂志(magazine)字符串，判断第一个字符串ransom能不能由第二个字符串magazines里面的字符构成。如果可以构成，返回 true ；否则返回 false。 (题目说明：为了不暴露赎金信字迹，要从杂志上搜索各个需要的字母，组成单词来表达意思。) 注意： 你可以假设两个字符串均只含有小写字母。 123canConstruct(&quot;a&quot;, &quot;b&quot;) -&gt; falsecanConstruct(&quot;aa&quot;, &quot;ab&quot;) -&gt; falsecanConstruct(&quot;aa&quot;, &quot;aab&quot;) -&gt; true 方法 直接Counter，然后判断前者的每个字符出现次数都小于后者即可。 12345678class Solution: def canConstruct(self, ransomNote: str, magazine: str) -&gt; bool: rcount = collections.Counter(ransomNote) mcount = collections.Counter(magazine) for r, c in rcount.items(): if c &gt; mcount[r]: return False return True 参考 LeetCode003:最长回文字符-老表Pro]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>LeetCode</tag>
        <tag>数据结构</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python解leetcode二叉树(2)]]></title>
    <url>%2F2019%2F06%2F21%2Fpython_leetcode-binary-tree(2)%2F</url>
    <content type="text"><![CDATA[相同的树 (两棵树是否相同) 对称二叉树 （一个二叉树是否对称） 二叉树的最大深度 二叉树的最小深度 路径总和 (找出树的两个节点之间的最长距离) 路径总和 II （找出和为某一值的路径） 二叉树中的最大路径和 路径总和 III 求根到叶子节点数字之和（找所有路径） 二叉树的所有路径 二叉树的直径 最长同值路径 二叉搜索树结点最小距离 二叉搜索树的范围和 100. 相同的树 给定两个二叉树，编写一个函数来检验它们是否相同。 如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。 示例 1: 1234567输入: 1 1 / \ / \ 2 3 2 3 [1,2,3], [1,2,3]输出: true 示例 2: 1234567输入: 1 1 / \ 2 2 [1,2], [1,null,2]输出: false 示例 3: 1234567输入: 1 1 / \ / \ 2 1 1 2 [1,2,1], [1,1,2]输出: false 方法:递归 1234567891011121314151617# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def isSameTree(self, p: TreeNode, q: TreeNode) -&gt; bool: if not p and not q: return True if not p or not q: return False if p.val == q.val: return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right) else: return False 101. 对称二叉树 给定一个二叉树，检查它是否是镜像对称的。 例如，二叉树 [1,2,2,3,4,4,3] 是对称的。 12345 1 / \ 2 2 / \ / \3 4 4 3 但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的: 12345 1 / \2 2 \ \ 3 3 方法一：DFS 一个二叉树遍历的过程中不一定一定只有一个参数，也可以同时传了两个参数分别是左右好处是可以直接比较，当然这个时候需要把root放到两个参数上进行比较。 递归很重要的一部分是终止条件的确定。 123456789101112131415class Solution: def isSymmetric(self, root: TreeNode) -&gt; bool: if not root: return True return self.isMirror(root.left, root.right) def isMirror(self, left, right): if not left and not right: return True if not left or not right: return False if left.val != right.val: return False return self.isMirror(left.left, right.right) and self.isMirror(left.right, right.left) 104.二叉树的最大深度 LeetCode 104. Maximum Depth of Binary Tree 给定一个二叉树，找出其最大深度。 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。 说明: 叶子节点是指没有子节点的节点。 示例： 给定二叉树 [3,9,20,null,null,15,7]， 12345 3 / \9 20 / \ 15 7 返回它的最大深度 3 。 方法一：深度优先搜索 深度优先搜索（DFS），递归求解。 12345class Solution: def maxDepth(self, root: TreeNode) -&gt; int: if not root: return 0 return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right)) 方法二：广度优先搜索 广度优先搜索（BFS），利用队列求解。 12345678910111213141516class Solution: def maxDepth(self, root: TreeNode) -&gt; int: if not root: return 0 depth = 0 q = [root] while len(q) != 0: depth += 1 for _ in range(len(q)): if q[0].left: q.append(q[0].left) if q[0].right: q.append(q[0].right) del q[0] return depth 111. 二叉树的最小深度 给定一个二叉树，找出其最小深度。 最小深度是从根节点到最近叶子节点的最短路径上的节点数量。 说明: 叶子节点是指没有子节点的节点。 示例: 12345678给定二叉树 [3,9,20,null,null,15,7], 3 / \ 9 20 / \ 15 7返回它的最小深度 2. 方法：递归 + BFS 发现这层有个叶子的话，就直接返回就行了 叶子的深度是1 1234567891011class Solution: def minDepth(self, root: TreeNode) -&gt; int: if not root: return 0 # 当root为空的时候直接返回0 left = self.minDepth(root.left) right = self.minDepth(root.right) if not left:# 判断树的深度应该到叶子节点，也就是左右子结点都为空的那个结点 return right + 1 if not right: return left + 1 return 1 + min(left, right) 112.路径总和 LeetCode 112. Path Sum 给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。 说明: 叶子节点是指没有子节点的节点。 示例: 给定如下二叉树，以及目标和 sum = 22， 1234567 5 / \ 4 8 / / \ 11 13 4 / \ \7 2 1 返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5-&gt;4-&gt;11-&gt;2。 方法一：DFS + 递归 用深度优先搜索（DFS）遍历所有可能的从根到叶的路径，要注意每深一层要从和中减去相应节点的数值。下面是递归实现的代码。 12345678class Solution: def hasPathSum(self, root: TreeNode, sum: int) -&gt; bool: if not root: return False if root.left or root.right: return self.hasPathSum(root.left, sum-root.val) or self.hasPathSum(root.right, sum-root.val) else: return True if sum == root.val else False 方法二：DFS + 栈 DFS的非递归实现，用栈实现。 1234567891011class Solution: def hasPathSum(self, root: TreeNode, sum: int) -&gt; bool: stack = [(root, sum)] while len(stack) != 0: node, tmp_sum = stack.pop() if node: if not node.left and not node.right and node.val == tmp_sum: return True stack.append((node.right, tmp_sum-node.val)) stack.append((node.left, tmp_sum-node.val)) return False 方法三：BFS + 队列 1234567891011class Solution: def hasPathSum(self, root: TreeNode, sum: int) -&gt; bool: queue = [(root, sum)] while len(queue) != 0: node, tmp_sum = queue.pop() if node: if not node.left and not node.right and node.val == tmp_sum: return True queue.insert(0, (node.right, tmp_sum-node.val)) queue.insert(0, (node.left, tmp_sum-node.val)) return False 方法四：后序遍历 + 栈 直接将路径保存在栈中，每次进入不同的层不需要记录当前的和 123456789101112131415161718192021class Solution: def hasPathSum(self, root: TreeNode, sum: int) -&gt; bool: pre, cur = None, root tmp_sum = 0 stack = [] while cur or len(stack) &gt; 0: while cur: stack.append(cur) tmp_sum += cur.val cur = cur.left # 最左子树 cur = stack[-1] if not cur.left and not cur.right and tmp_sum == sum: return True if cur.right and pre != cur.right: cur = cur.right # 右子树 else: pre = cur stack.pop() # 左子树 tmp_sum -= cur.val cur = None return False 113. 路径总和 II 给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。 说明: 叶子节点是指没有子节点的节点。 示例: 123456789101112131415给定如下二叉树，以及目标和 sum = 22， 5 / \ 4 8 / / \ 11 13 4 / \ / \ 7 2 5 1返回:[ [5,4,11,2], [5,8,4,5]] 方法:回溯 注意path传参，要写成path[:] 12345678910111213141516class Solution: def pathSum(self, root: TreeNode, sum: int) -&gt; List[List[int]]: res = [] self.dfs(root,sum,res,[]) return res def dfs(self, root, target, res, path): if not root:return path += [root.val] if sum(path) == target and not root.left and not root.right: res.append(path) return if root.left: self.dfs(root.left,target,res,path[:]) if root.right: self.dfs(root.right,target,res,path[:]) path.pop(-1) # 回溯 124. 二叉树中的最大路径和 给定一个非空二叉树，返回其最大路径和。 本题中，路径被定义为一条从树中任意节点出发，达到任意节点的序列。该路径至少包含一个节点，且不一定经过根节点。 示例 1: 1234567输入: [1,2,3] 1 / \ 2 3输出: 6 示例 2: 123456789输入: [-10,9,20,null,null,15,7] -10 / \ 9 20 / \ 15 7输出: 42 方法:递归 一条路径必定有一个节点最接近根节点，而该条路径的和就是这个节点的值加上它左右路径的和。我们现在要求最大路径和，那么就要分别得到左右两条路径的最大和。 而左路径的最大和为左节点的值加上它左右路径中较大的路径和，右路径最大和为右节点的值加上它左右路径中较大的路径和。 注意如果某条子路径的和为负，应该将该条子路径直接砍掉。 1234567891011121314class Solution: def maxPathSum(self, root: TreeNode) -&gt; int: self.maxSum = float('-inf') self._maxPathSum(root) return self.maxSum def _maxPathSum(self,root): if root is None: return 0 left = self._maxPathSum(root.left) right = self._maxPathSum(root.right) if left&lt;0: left = 0 if right&lt;0: right = 0 self.maxSum = max(self.maxSum, root.val + left + right) return max(left, right) + root.val 437. 路径总和 III 给定一个二叉树，它的每个结点都存放着一个整数值。 找出路径和等于给定数值的路径总数。 路径不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。 二叉树不超过1000个节点，且节点数值范围是 [-1000000,1000000] 的整数。 示例： 123456789101112131415root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8 10 / \ 5 -3 / \ \ 3 2 11 / \ \3 -2 1返回 3。和等于 8 的路径有:1. 5 -&gt; 32. 5 -&gt; 2 -&gt; 13. -3 -&gt; 11 方法 1234567891011121314class Solution: def pathSum(self, root: TreeNode, sum: int) -&gt; int: if not root:return 0 return self.dfs(root, sum) + self.pathSum(root.left, sum) + self.pathSum(root.right, sum) def dfs(self, root, sum): res = 0 if not root:return res sum -= root.val if sum == 0: res += 1 res += self.dfs(root.left, sum) res += self.dfs(root.right, sum) return res 129. 求根到叶子节点数字之和 给定一个二叉树，它的每个结点都存放一个 0-9 的数字，每条从根到叶子节点的路径都代表一个数字。 例如，从根到叶子节点路径 1-&gt;2-&gt;3 代表数字 123。 计算从根到叶子节点生成的所有数字之和。 说明: 叶子节点是指没有子节点的节点。 示例: 123456789101112输入: [4,9,0,5,1] 4 / \ 9 0 / \5 1输出: 1026解释:从根到叶子节点路径 4-&gt;9-&gt;5 代表数字 495.从根到叶子节点路径 4-&gt;9-&gt;1 代表数字 491.从根到叶子节点路径 4-&gt;0 代表数字 40.因此，数字总和 = 495 + 491 + 40 = 1026. 方法 和257题求所有路径是一样的。 res = 0当做参数传给函数，那么函数最后的结果不会影响到res，但是如果把res = [0]即可。 12345678910111213class Solution: def sumNumbers(self, root: TreeNode) -&gt; int: if not root:return 0 res = [0] self.dfs(root, res, root.val) return res[0] def dfs(self,root, res, path): if not root.left and not root.right: res[0] += path if root.left: self.dfs(root.left, res, path*10+root.left.val) if root.right: self.dfs(root.right, res, path*10+root.right.val) 257. 二叉树的所有路径 给定一个二叉树，返回所有从根节点到叶子节点的路径。 说明: 叶子节点是指没有子节点的节点。 示例: 12345678910输入: 1 / \2 3 \ 5输出: [&quot;1-&gt;2-&gt;5&quot;, &quot;1-&gt;3&quot;]解释: 所有根节点到叶子节点的路径为: 1-&gt;2-&gt;5, 1-&gt;3 方法 把path作为字符串，res作为数组保存字符串。 12345678910111213class Solution: def binaryTreePaths(self, root: TreeNode) -&gt; List[str]: if not root:return [] res = [] self.dfs(root, res, ''+str(root.val)) return res def dfs(self, root, res, path): if not root.left and not root.right: res.append(path) if root.left: self.dfs(root.left, res, path+'-&gt;'+str(root.left.val)) if root.right: self.dfs(root.right, res, path+'-&gt;'+str(root.right.val)) 543. 二叉树的直径 给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过根结点。 示例 : 12345678给定二叉树 1 / \ 2 3 / \ 4 5 返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。 注意：两结点之间的路径长度是以它们之间边的数目表示。 方法：递归 看叶子节点的左右子树的深度都是0，那么，它的深度是0，一个数的深度是其左右子树的最大值+1。 树总的最大宽度是其左右子树高度的和中的最大值。 求最大距离的过程需要在递归里面写，所以这个步骤比较巧妙，一个递归实现了两个作用。 123456789101112131415class Solution: def diameterOfBinaryTree(self, root: TreeNode) -&gt; int: if not root: return 0 self.diameter = 0 self.getDepth(root) return self.diameter def getDepth(self, root): if not root: return 0 left = self.getDepth(root.left) right = self.getDepth(root.right) self.diameter = max(self.diameter, left+right) return 1 + max(left, right) 687. 最长同值路径 给定一个二叉树，找到最长的路径，这个路径中的每个节点具有相同值。 这条路径可以经过也可以不经过根节点。 注意：两个节点之间的路径长度由它们之间的边数表示。 示例 1: 12345678输入: 5 / \ 4 5 / \ \ 1 1 5输出:2 示例 2: 12345678输入: 1 / \ 4 5 / \ \ 4 4 5输出:2 注意: 给定的二叉树不超过10000个结点。 树的高度不超过1000。 方法:递归 + dfs 求一个顶点到所有根节点的路径，时刻保留相等元素的最大值。相等元素的最大值是左右子树的相等元素的最大值+1，所以是递归。 定义的DFS函数是获得在通过root节点的情况下，最长单臂路径。其中更新的res是左右臂都算上的。所以这个题和普通的题是有点不一样。 12345678910111213class Solution: def longestUnivaluePath(self, root: TreeNode) -&gt; int: longest = [0] def dfs(root): if not root: return 0 left_len, right_len = dfs(root.left), dfs(root.right) left = left_len + 1 if root.left and root.left.val == root.val else 0 right = right_len + 1 if root.right and root.right.val == root.val else 0 longest[0] = max(longest[0], left + right) return max(left, right) dfs(root) return longest[0] 783. 二叉搜索树结点最小距离 该题和530. 二叉搜索树的最小绝对差 一样。可以用相同方法解题。 给定一个二叉搜索树的根结点 root, 返回树中任意两节点的差的最小值。 示例： 123输入: root = [4,2,6,1,3,null,null]输出: 1解释: 注意，root是树结点对象(TreeNode object)，而不是数组。 给定的树 [4,2,6,1,3,null,null] 可表示为下图: 12345 4 / \ 2 6 / \ 1 3 最小的差值是 1, 它是节点1和节点2的差值, 也是节点3和节点2的差值。 注意： 二叉树的大小范围在 2 到 100。 二叉树总是有效的，每个节点的值都是整数，且不重复。 方法：中序遍历+递归 中序遍历，得到有序列表，然后找出相邻的两个节点差值的最小值 1234567891011class Solution: def minDiffInBST(self, root: TreeNode) -&gt; int: vals = [] def inOrder(root): if not root: return inOrder(root.left) vals.append(root.val) inOrder(root.right) inOrder(root) return min([vals[i+1]-vals[i] for i in range(len(vals)-1)]) 938. 二叉搜索树的范围和 给定二叉搜索树的根结点 root，返回 L 和 R（含）之间的所有结点的值的和。 二叉搜索树保证具有唯一的值。 示例 1： 12输入：root = [10,5,15,3,7,null,18], L = 7, R = 15输出：32 示例 2： 12输入：root = [10,5,15,3,7,13,18,1,null,6], L = 6, R = 10输出：23 提示：树中的结点数量最多为 10000 个。最终的答案保证小于 2^31。 方法：BST+递归 1234567891011121314class Solution: def rangeSumBST(self, root: TreeNode, L: int, R: int) -&gt; int: if not root: return 0 res = 0 if L &lt;= root.val &lt;= R: res += root.val res += self.rangeSumBST(root.left, L, R) res += self.rangeSumBST(root.right, L, R) elif root.val &lt; L: res += self.rangeSumBST(root.right, L, R) elif root.val &gt; R: res += self.rangeSumBST(root.left, L, R) return res 参考 687. Longest Univalue Path 解题报告（Python &amp; C++）- 负雪明烛]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>LeetCode</tag>
        <tag>数据结构</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python解LeetCode二分查找(2)]]></title>
    <url>%2F2019%2F06%2F10%2Fpython_leetcode-binary-search(2)%2F</url>
    <content type="text"><![CDATA[在leetcode中属于简单级别的题目。 第一个错误的版本 搜索旋转排序数组 搜索旋转排序数组 II 寻找旋转排序数组中的最小值 278. 第一个错误的版本 你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。 假设你有 n 个版本 [1, 2, …, n]，你想找出导致之后所有版本出错的第一个错误的版本。 你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。 示例: 1234567给定 n = 5，并且 version = 4 是第一个错误的版本。调用 isBadVersion(3) -&gt; false调用 isBadVersion(5) -&gt; true调用 isBadVersion(4) -&gt; true所以，4 是第一个错误的版本。 方法 123456789101112131415class Solution: def firstBadVersion(self, n): """ :type n: int :rtype: int """ left = 0 right = n-1 while left &lt;= right: mid = left + (right-left)//2 if isBadVersion(mid): right = mid - 1 else: left = mid + 1 return left 33. 搜索旋转排序数组 假设按照升序排序的数组在预先未知的某个点上进行了旋转。 ( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。 搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。 你可以假设数组中不存在重复的元素。 你的算法时间复杂度必须是 O(log n) 级别。 示例 1: 12输入: nums = [4,5,6,7,0,1,2], target = 0输出: 4 示例 2: 12输入: nums = [4,5,6,7,0,1,2], target = 3输出: -1 方法 我们的二分查找的思想就是找出某个条件，这个条件给了我们移动左右指针的参考，即要判断查找的target在mid的左边还是右边。 具体到这个题目，因为给出的数组是旋转有序的，如果mid指向的位置在于pivot之后，那么mid向后部分是有序的，这个时候需要判断target在mid左边还是右边，最简单的方法就是判断target是不是在[pivot,r]区间内，如果的话就向mid后半部分搜索，否则就向mid左半部分搜索；同理，当mid在pivot之前，那么mid前面部分是有序的，根据target判断下面要向mid的左边还是右边搜索。 具体来说，假设数组是A，每次左边缘为l，右边缘为r，还有中间位置是m。在每次迭代中，分三种情况： 如果target==A[m]，那么m就是我们要的结果，直接返回； 如果A[m]&lt;A[r]，那么说明从m到r一定是有序的（没有受到rotate的影响），那么我们只需要判断target是不是在m到r之间，如果是则把左边缘移到m+1，否则就target在另一半，即把右边缘移到m-1。 如果A[m]&gt;=A[r]，那么说明从l到m一定是有序的，同样只需要判断target是否在这个范围内，相应的移动边缘即可。 注意，由于这个题目要进行和边缘元素的判断，所以没有采取[l,r)的左闭右开区间，而是使用了[l, r]双闭区间。 1234567891011121314151617181920class Solution: def search(self, nums: List[int], target: int) -&gt; int: if not nums: return -1 left = 0 right = len(nums)-1 while left &lt;= right: mid = (left + right)//2 if nums[mid] == target: return mid if nums[mid] &lt; nums[right]: # 确定右边有序 if nums[mid] &lt; target and target &lt;= nums[right]: left = mid + 1 else: right = mid - 1 else: # 确定左边有序 if nums[mid] &gt; target and target &gt;= nums[left]: right = mid - 1 else: left = mid + 1 return -1 81. 搜索旋转排序数组 II 假设按照升序排序的数组在预先未知的某个点上进行了旋转。 ( 例如，数组 [0,0,1,2,2,5,6] 可能变为 [2,5,6,0,0,1,2] )。 编写一个函数来判断给定的目标值是否存在于数组中。若存在返回 true，否则返回 false。 示例 1: 12输入: nums = [2,5,6,0,0,1,2], target = 0输出: true 示例 2: 12输入: nums = [2,5,6,0,0,1,2], target = 3输出: false 方法 是第33题的拓展题目，变的是加了一个可能含有重复数字。 这样的话，如果直接进行左右指针的比较就不知道向哪个方向搜索了， 所以，需要在正式比较之前，先移动左指针，是他指向一个和右指针不同的数字上。然后再做33题的查找。 123456789101112131415161718192021class Solution: def search(self, nums: List[int], target: int) -&gt; bool: left = 0 right = len(nums)-1 while left &lt;= right: while left &lt; right and nums[left] == nums[right]: left += 1 mid = (left + right)//2 if nums[mid] == target: return True if nums[left] &lt;= nums[mid]: # 前半部有序 if nums[left] &lt;= target and target &lt; nums[mid]: # 有一部分要写‘=’号 right = mid - 1 else: left = mid + 1 else: # 后半部分有序 if nums[mid] &lt; target and target &lt;= nums[right]: left = mid + 1 else: right = mid - 1 return False 153. 寻找旋转排序数组中的最小值 假设按照升序排序的数组在预先未知的某个点上进行了旋转。 ( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。 请找出其中最小的元素。 你可以假设数组中不存在重复元素。 示例 1: 12输入: [3,4,5,1,2]输出: 1 示例 2: 12输入: [4,5,6,7,0,1,2]输出: 0 方法 这个题是剑指offer上的原题。看到有序的数组就想到二分查找。这个是变种而已。 注意边界和循环条件。 1234567891011121314151617class Solution: def findMin(self, nums: List[int]) -&gt; int: if len(nums) == 1:return nums[0] left, right = 0, len(nums)-1 mid = left while nums[left] &gt;= nums[right]: # 左半边 大于 右半边 if left+1 == right: # 左右边相邻 mid = right break mid = (left + right)//2 if nums[left] &lt;= nums[mid]: left = mid elif nums[mid] &lt;= nums[right]: right = mid return nums[mid] 参考 【LeetCode】153. Find Minimum in Rotated Sorted Array 解题报告（Python）]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>LeetCode</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python解LeetCode链表(4)]]></title>
    <url>%2F2019%2F06%2F10%2Fpython_linklist(4)%2F</url>
    <content type="text"><![CDATA[两数相加 两数相加 II 复制带随机指针的链表 2. 两数相加 给出两个非空的链表用来表示两个非负的整数。其中，它们各自的位数是按照逆序的方式存储的，并且它们的每个节点只能存储一位数字。 如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。 您可以假设除了数字 0 之外，这两个数都不会以 0 开头。 示例： 123输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807 方法：偷懒做法 考虑：数字中是否有前置0？（除0以外，没有前置0） 有负数？ 先求和，再构建链表。这个方法比较暴力。 123456789101112131415161718192021222324# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def addTwoNumbers(self, l1: ListNode, l2: ListNode) -&gt; ListNode: num1 = '' num2 = '' while l1:#243 num1 += str(l1.val) l1 = l1.next while l2:#564 num2 += str(l2.val) l2 = l2.next add = str(int(num1[::-1]) + int(num2[::-1]))[::-1] #342+465=807---708 head = ListNode(add[0]) res = head for i in range(1,len(add)): node = ListNode(add[i]) head.next = node head = head.next return res 两数相加 II 给定两个非空链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储单个数字。将这两数相加会返回一个新的链表。 你可以假设除了数字 0 之外，这两个数字都不会以零开头。 进阶: 如果输入链表不能修改该如何处理？换句话说，你不能对列表中的节点进行翻转。 示例: 12输入: (7 -&gt; 2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出: 7 -&gt; 8 -&gt; 0 -&gt; 7 方法 先求出和，再构建链表 123456789101112131415161718class Solution: def addTwoNumbers(self, l1: ListNode, l2: ListNode) -&gt; ListNode: num1 = '' num2 = '' while l1: num1 += str(l1.val) l1 = l1.next while l2: num2 += str(l2.val) l2 = l2.next add = str(int(num1) + int(num2)) head = ListNode(add[0]) answer = head for i in range(1, len(add)): node = ListNode(add[i]) head.next = node head = head.next return answer 138. 复制带随机指针的链表 给定一个链表，每个节点包含一个额外增加的随机指针，该指针可以指向链表中的任何节点或空节点。 要求返回这个链表的深拷贝。 示例： 123456输入：&#123;&quot;$id&quot;:&quot;1&quot;,&quot;next&quot;:&#123;&quot;$id&quot;:&quot;2&quot;,&quot;next&quot;:null,&quot;random&quot;:&#123;&quot;$ref&quot;:&quot;2&quot;&#125;,&quot;val&quot;:2&#125;,&quot;random&quot;:&#123;&quot;$ref&quot;:&quot;2&quot;&#125;,&quot;val&quot;:1&#125;解释：节点 1 的值是 1，它的下一个指针和随机指针都指向节点 2 。节点 2 的值是 2，它的下一个指针指向 null，随机指针指向它自己。 提示：你必须返回给定头的拷贝作为对克隆列表的引用。 方法 使用hashtable，在这个hash表里，记录了老链表和新链表的每一组对应。这样先构造了一个纯next的链表，然后再次循环就能得到带random的链表了。 123456789101112131415161718class Solution: def copyRandomList(self, head: 'Node') -&gt; 'Node': nodeDict = dict() dummy = Node(0, None, None) nodeDict[head] = dummy newHead, pointer = dummy, head while pointer: nodeDict[pointer] = Node(pointer.val, pointer.next, None) newHead.next = nodeDict[pointer] newHead, pointer = newHead.next, pointer.next pointer = head while pointer: if pointer.random: nodeDict[pointer].random = nodeDict[pointer.random] pointer = pointer.next return dummy.next]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>LeetCode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生成模型与判别模型]]></title>
    <url>%2F2019%2F05%2F15%2F%E7%94%9F%E6%88%90%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%88%A4%E5%88%AB%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[学习任务： 生成模型（generative model） 判别模型（discriminative model） 生成模型 假设数据分布服从某种参数化的模型。当估计出一个数据分布的参数化模型后，我们可以根据这个模型来生成数据，因此这些模型也称为生成模型（generative model）。 在机器学习中，生成模型可以用来： 直接对数据建模（例如根据某个变量的概率密度函数进行数据采样） 建立变量间的条件概率分布。条件概率分布可以由生成模型根据贝叶斯定理形成。 生成模型是所有变量的全概率模型， 而判别模型是在给定观测变量值前提下目标变量条件概率模型。 因此生成模型能够用于模拟（即生成）模型中任意变量的分布情况，而判别模型只能根据观测变量得到目标变量的采样。 判别模型不对观测变量的分布建模，因此它不能够表达观测变量与目标变量之间更复杂的关系。因此，生成模型更适用于无监督的任务，如分类和聚类。 典型的生成模型包括: 高斯混合模型和其他混合模型 隐马尔可夫模型 随机上下文无关文法 朴素贝叶斯分类器 AODE分类器 潜在狄利克雷分配模型 受限玻尔兹曼机 深度信念网络 ## 深度学习的三大生成模型：VAE、GAN、GAN 变分自编码器 对抗生成网络 序列生成模型： 自回归 N 元统计模型 深度序列模型 # 判别模型]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>sklearn</tag>
        <tag>机器学习</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LSTM理解]]></title>
    <url>%2F2019%2F05%2F12%2FLSTM%2F</url>
    <content type="text"><![CDATA[学习任务： 循环神经网络 RNN 什么是RNN？ RNN有哪些不足点？ LSTM网络 LSTMs 的核心思想 LSTM应用 keras代码实现 RNN 前向传播]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tensorflow入门]]></title>
    <url>%2F2019%2F05%2F09%2FTensorflow%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[这里编写一个最简单的神经网络，以此了解深度学习的整个训练过程。 Imports 导入keras框架，用来定义神经网络的一系列Sequential层 123import tensorflow as tfimport numpy as npfrom tensorflow import keras Define and Compile the Neural Network 创建最简单的神经网络，1 layer, 1 neuron, input shape只有1个value 1model = tf.keras.Sequential([keras.layers.Dense(units=1, input_shape=[1])]) compile 神经网络，指定了两个函数， - loss： 计算猜测的值与已知的真实值之间的差距，判断猜测的好不好。 - optimizer：根据loss结果，重新猜测多次，以最小化loss 1model.compile(optimizer='sgd', loss='mean_squared_error') Providing the Data 输入一些数据，numpy把数据变成array类型。 能够看出来他们的关系是 Y=2X-1, 12xs = np.array([-1.0, 0.0, 1.0, 2.0, 3.0, 4.0], dtype=float)ys = np.array([-3.0, -1.0, 1.0, 3.0, 5.0, 7.0], dtype=float) Training the Neural Network 训练过程中，神经网络学习 xs 与 ys 之间的关系。根据 loss , 用 optimizer 重复猜测 epochs 次， 1model.fit(xs, ys, epochs=500) 预测一个数。由于神经网络是做概率计算，所以虽然能找到这个数据关系 Y=2X-1,但是预测结果只能非常接近19，不可能直接是19，而且训练数据量只有6个，太少。 1print(model.predict([10.0])) 参考 课程 Introduction to TensorFlow for Artificial Intelligence, Machine Learning, and Deep Learning]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>深度学习</tag>
        <tag>tensorflow</tag>
        <tag>神经网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分治算法(divide and conquer)]]></title>
    <url>%2F2019%2F04%2F23%2Fpython-leetcode-divide_and_conquer%2F</url>
    <content type="text"><![CDATA[利用分治算法求一组数据的逆序对个数]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>python</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python解LeetCode数学题(1)]]></title>
    <url>%2F2019%2F04%2F22%2Fpython_leetcode-math(1)%2F</url>
    <content type="text"><![CDATA[整数反转 字符串转换整数 (atoi) (解法见 python实现数据结构之字符串) 回文数 罗马数字转整数 格雷编码 计数素数 2的幂 丑数 丑数 II Nim 游戏 第N个数字 7. 整数反转 给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。 示例 1: 12输入: 123输出: 321 示例 2: 12输入: -123输出: -321 示例 3: 12输入: 120输出: 21 注意: 假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231, 231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。 方法一:取模 循环通过对10取模得到尾部数字，一步步乘10构造新的翻转后的整数即可。然而要注意首先判断原数字的正负，最后还要判断结果是否溢出。 123456789class Solution: def reverse(self, x: int) -&gt; int: flag = 1 if x&gt;0 else -1 rev = 0 x = abs(x) while(x!=0): rev = rev*10 + x%10 x //= 10 return rev*flag if rev &lt; 2147483648 else 0 方法二：转字符串 整数符号提取出来，把整数转化为字符串，然后使用字符串的翻转。 12345class Solution: def reverse(self, x: int) -&gt; int: flag = -1 if x &lt; 0 else 1 x = int(str(abs(x))[::-1]) return x*flag if x&lt;=2 ** 31 -1 else 0 9. 回文数 判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。 示例 1: 12输入: 121输出: true 示例 2: 123输入: -121输出: false解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。 示例 3: 123输入: 10输出: false解释: 从右向左读, 为 01 。因此它不是一个回文数。 方法一：转成字符串 123456789class Solution: def isPalindrome(self, x: int) -&gt; bool: if x &lt; 0: return False x = str(x) N = len(x) for i in range(N//2): if x[i] != x[N-1-i]: return False return True 方法二：数学除余+取模 借助一个与x同等位数的变量help（首位1，其余位0），通过循环： 1. 找到x的最高位x//help和最低位x%10，进行比较， 2. 去掉x两头的数字(x%help)//10。help变量同步修改去掉两个0。 help/=100。 1234567891011121314class Solution: def isPalindrome(self, x: int) -&gt; bool: if x &lt; 0: return False help=1 while x//help &gt;= 10: help *= 10 while x!=0: if x//help != x%10: return False x = (x%help)//10 help /= 100 return True 13. 罗马数字转整数 罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。 12345678字符 数值I 1V 5X 10L 50C 100D 500M 1000 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。 X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。 给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。 示例 1: 12输入: &quot;III&quot;输出: 3 示例 2: 12输入: &quot;IV&quot;输出: 4 示例 3: 12输入: &quot;IX&quot;输出: 9 示例 4: 123输入: &quot;LVIII&quot;输出: 58解释: L = 50, V= 5, III = 3. 示例 5: 123输入: &quot;MCMXCIV&quot;输出: 1994解释: M = 1000, CM = 900, XC = 90, IV = 4. 方法：从后往前遍历 1234567891011class Solution: def romanToInt(self, s: str) -&gt; int: roman = &#123;"I":1, "V":5, "X":10, "L":50, "C":100, "D":500, "M":1000&#125; res = roman[s[-1]] N = len(s) for i in range(N-2, -1, -1): if roman[s[i]] &lt; roman[s[i+1]]: res -= roman[s[i]] else: res += roman[s[i]] return res 89.格雷编码 格雷编码是一个二进制数字系统，在该系统中，两个连续的数值仅有一个位数的差异。 给定一个代表编码总位数的非负整数 n，打印其格雷编码序列。格雷编码序列必须以 0 开头。 示例 1: 123456789101112131415输入: 2输出: [0,1,3,2]解释:00 - 001 - 111 - 310 - 2对于给定的 n，其格雷编码序列并不唯一。例如，[0,2,3,1] 也是一个有效的格雷编码序列。00 - 010 - 211 - 301 - 1 方法 下面是百度百科告诉的如何求n位的格雷码的方法。 递归生成码表 这种方法基于格雷码是反射码的事实，利用递归的如下规则来构造： 12341位格雷码有两个码字(n+1)位格雷码中的前2n个码字等于n位格雷码的码字，按顺序书写，加前缀0(n+1)位格雷码中的后2n个码字等于n位格雷码的码字，按逆序书写，加前缀1n+1位格雷码的集合 = n位格雷码集合(顺序)加前缀0 + n位格雷码集合(逆序)加前缀1 简言之就是递归。第（n+1）位的格雷码序列=（‘0’+第n位的正序） + （‘1’+第n位的逆序） 题目中说了n是非负数，当n=0的时候，返回[0]即可。 12345678910class Solution: def grayCode(self, n: int) -&gt; List[int]: return map(lambda x: int(x,2), self.bit_gray(n)) def bit_gray(self,n): if n==0: return ["0"] elif n==1: return ["0","1"] else: pre_gray = self.bit_gray(n-1) return ["0"+x for x in pre_gray] + ["1"+x for x in pre_gray[::-1]] 204. 计数素数 质数（prime number）又称素数，有无限个。 质数定义为在大于1的自然数中，除了1和它本身以外不再有其他因数。 题目描述 统计所有小于非负整数 n 的质数的数量。 示例: 123输入: 10输出: 4解释: 小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。 方法：素数筛法 素数筛法就是把这个数的所有倍数都删除掉，因为这些数一定不是素数。最后统计一下数字剩余的没有被删除的个数就好。 1234567891011121314class Solution: def countPrimes(self, n: int) -&gt; int: nums = [1]*n for i in range(2, n): if nums[i]==0: continue # 筛掉不是素数的值 j = 2 while i*j &lt; n: nums[i*j] = 0 j += 1 res = 0 for i in range(2, n): res += nums[i] return res 执行用时有点长。 231. 2的幂 给定一个整数，编写一个函数来判断它是否是 2 的幂次方。 示例 1: 123输入: 1输出: true解释: 20 = 1 示例 2: 123输入: 16输出: true解释: 24 = 16 方法一：二进制 数一下二进制中1的个数是不是正好是1个 123class Solution: def isPowerOfTwo(self, n: int) -&gt; bool: return n&gt;0 and bin(n).count("1")==1 方法二：位运算 n&amp;(n-1) 的方法来数一个数里边只有一个1 12345678class Solution(object): def isPowerOfTwo(self, n): """ :type n: int :rtype: bool """ if n &lt;= 0: return False return n &amp; (n - 1) == 0 263. 丑数 编写一个程序判断给定的数是否为丑数。 丑数就是只包含质因数 2, 3, 5 的正整数。 示例 1: 123输入: 6输出: true解释: 6 = 2 × 3 示例 2: 123输入: 8输出: true解释: 8 = 2 × 2 × 2 示例 3: 123输入: 14输出: false 解释: 14 不是丑数，因为它包含了另外一个质因数 7。 说明： 1 是丑数。 输入不会超过 32 位有符号整数的范围: [−231, 231 − 1]。 方法 把这个数中的所有的2,3,5的因子全部除去，剩余的数为1，则说明全部为这几个因子构成。 12345678910class Solution: def isUgly(self, num: int) -&gt; bool: if num==0: return False while num%2==0: num /= 2 while num%3==0: num /= 3 while num%5==0: num /= 5 return num==1 264. 丑数 II 编写一个程序，找出第 n 个丑数。 丑数就是只包含质因数 2, 3, 5 的正整数。 示例: 123输入: n = 10输出: 12解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。 说明: 1 是丑数。 n 不超过1690。 方法 1234567891011class Solution: def nthUglyNumber(self, n: int) -&gt; int: if n&lt;0: return 0 dp = [1]*n index2, index3, index5 = 0,0,0 for i in range(1,n): dp[i] = min(dp[index2]*2, dp[index3]*3, dp[index5]*5) if dp[i]==dp[index2]*2: index2 += 1 if dp[i]==dp[index3]*3: index3 += 1 if dp[i]==dp[index5]*5: index5 += 1 return dp[-1] 292. Nim 游戏 你和你的朋友，两个人一起玩 Nim 游戏：桌子上有一堆石头，每次你们轮流拿掉 1 - 3 块石头。 拿掉最后一块石头的人就是获胜者。你作为先手。 你们是聪明人，每一步都是最优解。 编写一个函数，来判断你是否可以在给定石头数量的情况下赢得游戏。 示例: 1234输入: 4输出: false 解释: 如果堆中有 4 块石头，那么你永远不会赢得比赛； 因为无论你拿走 1 块、2 块 还是 3 块石头，最后一块石头总是会被你的朋友拿走。 方法 题目的意思是只要拿最后一个石子的人赢。 因为每次最多拿三个，所以只要我拿走子之后，最后剩余四个的话，我就输了。 所以，所有子的个数不能被四整除我就赢了，否则我会输。输的原因是对手每次都拿4-n，n为当次我拿到子的个数。 123class Solution: def canWinNim(self, n: int) -&gt; bool: return n % 4 != 0 400. 第N个数字 在无限的整数序列 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, …中找到第 n 个数字。 注意:n 是正数且在32为整形范围内 ( n &lt; 231)。 示例 1: 12输入:3输出:3 示例 2: 12输入:11输出:0 说明: 第11个数字在序列 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, … 里是0，它是10的一部分。 方法 找规律：个位数字有9个，2位数字有910=90个，3位数字有9100=900个……所以我们先求出n是几位数字，然后判断第n个数字应该落在哪个自然数上，最后再求这个自然数会落在自然数的那一位上。 123456789101112class Solution: def findNthDigit(self, n: int) -&gt; int: _len = 1 count = 9 start = 1 while n &gt; count*_len: n -= count*_len count *= 10 _len += 1 start *= 10 start += (n-1)/_len return int(str(start)[(n-1)%_len]) 参考 How Many Primes Are There? Sieve of Eratosthenes]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>LeetCode</tag>
        <tag>牛客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XGBoost算法梳理]]></title>
    <url>%2F2019%2F04%2F09%2FXGBoost%E7%AE%97%E6%B3%95%E6%A2%B3%E7%90%86%2F</url>
    <content type="text"><![CDATA[学习任务： 算法原理 损失函数 分裂结点算法 对缺失值处理 优缺点 sklearn参数 2014年，陈天奇博士提出了XGBoost算法，它可认为是在GBDT算法基础上的进一步优化。首先，XGBoost算法在基学习器损失函数中引入了正则项，控制减少训练过程当中的过拟合；其次，XGBoost算法不仅使用一阶导数计算伪残差，还计算二阶导数可近似快速剪枝的构建新的基学习器；此外，XGBoost算法还做了很多工程上的优化，例如支持并行计算、提高计算效率、处理稀疏训练数据等等。 总的来说，XGBoost算法源起于Boosting集成学习方法，在演化过程中又融入了Bagging集成学习方法的优势，通过Gradient Boosting框架自定义损失函数提高了算法解决通用问题的能力，同时引入更多可控参数即可针对问题场景进行优化，最后通过工程实现方面细节优化，在保证算法结果稳定的同时还可高效处理大规模数据，可扩展支持不同编程语言。这些因素共同使它成为了工业界的主流机器学习算法之一。 XGBoost是一种提升树模型，所以它是将许多树模型集成在一起，形成一个很强的分类器。而所用到的树模型则是CART回归树模型。讲解其原理前，先讲解一下CART回归树。 CART回归树 CART回归树是假设树为二叉树，通过不断将特征进行分裂。 比如当前树结点是基于第 \(j\) 个特征值进行分裂的，设该特征值小于 \(s\) 的样本划分为左子树，大于s的样本划分为右子树。 \[ R_{1}(j, s)=\left\{x | x^{(j)} \leq s\right\} \text { and } R_{2}(j, s)=\left\{x | x^{(j)}&gt;s\right\} \] 而CART回归树实质上就是在该特征维度对样本空间进行划分，而这种空间划分的优化是一种NP难问题，因此，在决策树模型中是使用启发式方法解决。典型CART回归树产生的目标函数为： \[ \sum_{x_{i} \in R_{m}}\left(y_{i}-f\left(x_{i}\right)\right)^{2} \] 因此，当我们为了求解最优的切分特征j和最优的切分点s，就转化为求解这么一个目标函数： \[ \min _{j, s}\left[\min _{c_{1}} \sum_{x_{i} \in R_{1}(j, s)}\left(y_{i}-c_{1}\right)^{2}+\min _{c_{2}} \sum_{x_{i} \in R_{2}(j, s)}\left(y_{i}-c_{2}\right)^{2}\right] \] 所以我们只要遍历所有特征的的所有切分点，就能找到最优的切分特征和切分点。最终得到一棵回归树。 # XGBoost算法思想 该算法思想就是不断地添加树，不断地进行特征分裂来生长一棵树，每次添加一个树，其实是学习一个新函数，去拟合上次预测的残差。当我们训练完成得到k棵树，我们要预测一个样本的分数，其实就是根据这个样本的特征，在每棵树中会落到对应的一个叶子节点，每个叶子节点就对应一个分数，最后只需要将每棵树对应的分数加起来就是该样本的预测值。 \[ \hat{y}=\phi\left(x_{i}\right)=\sum_{k=1}^{K} f_{k}\left(x_{i}\right) \] \[ where\ F=\left\{f(x)=w_{q(x)}\right\}\left(q : R^{m} \rightarrow T, w \in R^{T}\right) \] 注：\(w_q(x)\) 为叶子节点 \(q\) 的分数，\(f(x)\)为其中一棵回归树 XGBoost原理 XGBoost目标函数定义为： \[ O b j=\sum_{i=1}^{n} l\left(y_{i}, \hat{y}_{i}\right)+\sum_{k=1}^{K} \Omega\left(f_{k}\right) \\ where\ \Omega(f)=\gamma T+\frac{1}{2} \lambda\|w\|^{2} \] 目标函数由两部分构成，第一部分用来衡量预测分数和真实分数的差距（损失），另一部分则是正则化项。 正则化项同样包含两部分，\(T\) 表示叶子结点的个数，\(w\) 表示叶子结点的分数。\(γ\) 可以控制叶子结点的个数，\(λ\) 可以控制叶子节点的分数不会过大，防止过拟合。\(y_i\) 即为真实值，\(\hat{y}_{i}\) 为预测值。 正如上文所说，新生成的树是要拟合上次预测的残差的，即当生成 \(t\) 棵树后，预测分数可以写成： \[ \hat{y}_{i}^{(t)}=\hat{y}_{i}^{(t-1)}+f_{t}\left(x_{i}\right) \] 同时，可以将目标函数改写成： \[ \mathcal{L}^{(t)}=\sum_{i=1}^{n} l\left(y_{i}, \hat{y}_{i}^{(t-1)}+f_{t}\left(x_{i}\right)\right)+\Omega\left(f_{t}\right) \] 很明显，我们接下来就是要去找到一个 \(f_t\) 能够最小化目标函数。XGBoost的想法是利用其在 \(f_t=0\) 处的泰勒二阶展开近似它。 泰勒展开：\(f(x+\Delta x) \simeq f(x)+f^{\prime}(x) \Delta x+\frac{1}{2} f^{\prime \prime}(x) \Delta x^{2}\) 先定义一阶导数和二阶导数：\(g_{i}=\partial_{\hat{y}^{(t-1)}} l\left(y_{i}, \hat{y}^{(t-1)}\right), \quad h_{i}=\partial_{\hat{y}^{(t-1)}}^{2} l\left(y_{i}, \hat{y}^{(t-1)}\right)\) 所以，目标函数近似为： \[ O b j^{(t)} \simeq \sum_{i=1}^{n}\left[l\left(y_{i}, \hat{y}_{i}^{(t-1)}\right)+g_{i} f_{t}\left(x_{i}\right)+\frac{1}{2} h_{i} f_{t}^{2}\left(x_{i}\right)\right]+\Omega\left(f_{t}\right)+ constant \] 由于前t-1棵树的预测分数与y的残差对目标函数优化不影响，可以直接去掉。我们知道，每个样本都最终会落到一个叶子结点中，所以我们可以将所以同一个叶子结点的样本重组起来，过程如下： \[ \begin{aligned} O b j^{(t)} &amp; \simeq \sum_{i=1}^{n}\left[g_{i} f_{t}\left(x_{i}\right)+\frac{1}{2} h_{i} f_{t}^{2}\left(x_{i}\right)\right]+\Omega\left(f_{t}\right) \\ &amp;=\sum_{i=1}^{n}\left[g_{i} w_{q\left(x_{i}\right)}+\frac{1}{2} h_{i} w_{q\left(x_{i}\right)}^{2}\right]+\gamma T+\lambda \frac{1}{2} \sum_{j=1}^{T} w_{j}^{2} \\ &amp;=\sum_{j=1}^{T}\left[\left(\sum_{i \in I_{j}} g_{i}\right) w_{j}+\frac{1}{2}\left(\sum_{i \in I_{j}} h_{i}+\lambda\right) w_{j}^{2}\right]+\gamma T \end{aligned} \] 因此通过上式的改写，我们可以将目标函数改写成关于叶子结点分数 \(w\) 的一个一元二次函数，求解最优的 \(w\) 和目标函数值就变得很简单了，直接使用顶点公式即可。因此，最优的 \(w\) 和目标函数公式为 \[ w_{j}^{*}=-\frac{G_{j}}{H_{j}+\lambda} \\ O b j=-\frac{1}{2} \sum_{j=1}^{T} \frac{G_{j}^{2}}{H_{j}+\lambda}+\gamma T \] 分裂结点算法 在上面的推导中，我们知道了如果我们一棵树的结构确定了，如何求得每个叶子结点的分数。但我们还没介绍如何确定树结构，即每次特征分裂怎么寻找最佳特征，怎么寻找最佳分裂点。 正如上文说到，基于空间切分去构造一颗决策树是一个NP难问题，我们不可能去遍历所有树结构，因此，XGBoost使用了和CART回归树一样的想法，利用贪婪算法，遍历所有特征的所有特征划分点，不同的是使用上式目标函数值作为评价函数。具体做法就是对比分裂后的目标函数值与单子叶子节点的目标函数增益，同时为了限制树生长过深，还加了个阈值，只有当增益大于该阈值才进行分裂。 同时可以设置树的最大深度、当样本权重和小于设定阈值时停止生长去防止过拟合。 Shrinkage and Column Subsampling XGBoost还提出了两种防止过拟合的方法：Shrinkage and Column Subsampling。 Shrinkage方法就是在每次迭代中对树的每个叶子结点的分数乘上一个缩减权重η，这可以使得每一棵树的影响力不会太大，留下更大的空间给后面生成的树去优化模型。 Column Subsampling类似于随机森林中的选取部分特征进行建树。其可分为两种， - 一种是按层随机采样，在对同一层内每个结点分裂之前，先随机选择一部分特征，然后只需要遍历这部分的特征，来确定最优的分割点。 - 另一种是随机选择特征，建树前随机选择一部分特征然后分裂就只遍历这些特征。一般情况下前者效果更好。 近似算法 对于连续型特征值，当样本数量非常大，该特征取值过多时，遍历所有取值会花费很多时间，且容易过拟合。因此XGBoost思想是对特征进行分桶，即找到l个划分点，将位于相邻分位点之间的样本分在一个桶中。在遍历该特征的时候，只需要遍历各个分位点，从而计算最优划分。 从算法伪代码中该流程还可以分为两种，全局的近似是在新生成一棵树之前就对各个特征计算分位点并划分样本，之后在每次分裂过程中都采用近似划分，而局部近似就是在具体的某一次分裂节点的过程中采用近似算法。 针对稀疏矩阵的算法（缺失值处理） 当样本的第 \(i\) 个特征值缺失时，无法利用该特征进行划分时，XGBoost的想法是将该样本分别划分到左结点和右结点，然后计算其增益，哪个大就划分到哪边。 XGBoost的优点 使用许多策略去防止过拟合，如：正则化项、Shrinkage and Column Subsampling等。 目标函数优化利用了损失函数关于待求函数的二阶导数 支持并行化，这是XGBoost的闪光点，虽然树与树之间是串行关系，但是同层级节点可并行。具体的对于某个节点，节点内选择最佳分裂点，候选分裂点计算增益用多线程并行。训练速度快。 添加了对稀疏数据的处理。 交叉验证，early stop，当预测结果已经很好的时候可以提前停止建树，加快训练速度。 支持设置样本权重，该权重体现在一阶导数g和二阶导数h，通过调整权重可以去更加关注一些样本。 xgboost参数 官方参数介绍看这里： Parameters (official guide) General Parameters（常规参数） booster [default=gbtree]：选择基分类器，gbtree: tree-based models/gblinear: linear models silent [default=0]:设置成1则没有运行信息输出，最好是设置为0. nthread [default to maximum number of threads available if not set]：线程数 Booster Parameters（模型参数） 1.eta [default=0.3]:shrinkage参数，用于更新叶子节点权重时，乘以该系数，避免步长过大。参数值越大，越可能无法收敛。把学习率 eta 设置的小一些，小学习率可以使得后面的学习更加仔细。 2.min_child_weight [default=1]:这个参数默认是 1，是每个叶子里面 h 的和至少是多少，对正负样本不均衡时的 0-1 分类而言，假设 h 在 0.01 附近，min_child_weight 为 1 意味着叶子节点中最少需要包含 100 个样本。这个参数非常影响结果，控制叶子节点中二阶导的和的最小值，该参数值越小，越容易 overfitting。 3.max_depth [default=6]: 每颗树的最大深度，树高越深，越容易过拟合。 4.max_leaf_nodes:最大叶结点数，与max_depth作用有点重合。 5.gamma [default=0]：后剪枝时，用于控制是否后剪枝的参数。 6.max_delta_step [default=0]：这个参数在更新步骤中起作用，如果取0表示没有约束，如果取正值则使得更新步骤更加保守。可以防止做太大的更新步子，使更新更加平缓。 7.subsample [default=1]：样本随机采样，较低的值使得算法更加保守，防止过拟合，但是太小的值也会造成欠拟合。 8.colsample_bytree [default=1]：列采样，对每棵树的生成用的特征进行列采样.一般设置为： 0.5-1 9.lambda [default=1]：控制模型复杂度的权重值的L2正则化项参数，参数越大，模型越不容易过拟合。 10.alpha [default=0]:控制模型复杂程度的权重值的 L1 正则项参数，参数值越大，模型越不容易过拟合。 11.scale_pos_weight [default=1]：如果取值大于0的话，在类别样本不平衡的情况下有助于快速收敛。 Learning Task Parameters（学习任务参数） 1.objective [default=reg:linear]：定义最小化损失函数类型，常用参数： binary:logistic –logistic regression for binary classification, returns predicted probability (not class) multi:softmax –multiclass classification using the softmax objective, returns predicted class (not probabilities) you also need to set an additional num_class (number of classes) parameter defining the number of unique classes multi:softprob –same as softmax, but returns predicted probability of each data point belonging to each class. 2.eval_metric [ default according to objective ]： The metric to be used for validation data. The default values are rmse for regression and error for classification. Typical values are: rmse – root mean square error mae – mean absolute error logloss – negative log-likelihood error – Binary classification error rate (0.5 threshold) merror – Multiclass classification error rate mlogloss – Multiclass logloss auc: Area under the curve 3.seed [default=0]： The random number seed. 随机种子，用于产生可复现的结果 Can be used for generating reproducible results and also for parameter tuning. 注意: python sklearn style参数名会有所变化 eta –&gt; learning_rate lambda –&gt; reg_lambda alpha –&gt; reg_alpha 参考 XGBoost-ZDK 一文读懂机器学习大杀器XGBoost原理 XGBoost-Python完全调参指南-参数解释篇 Complete Guide to Parameter Tuning in XGBoost (with codes in Python) XGBoost：参数解释 xgboost入门与实战（原理篇） XGBoost]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>sklearn</tag>
        <tag>机器学习</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python解leetcode动态规划(1)]]></title>
    <url>%2F2019%2F04%2F05%2Fpython_leetcode-dynamic-programming(1)%2F</url>
    <content type="text"><![CDATA[动态规划方法可以画网格⭐。 递归 + 记忆化 ——&gt; 递推（动态规划）（自上而下的记忆化搜索） 状态的定义：数组 opt[n], dp[n], fib[n] 状态转移方程：opt[n] = best_of(opt[n-1], opt[n-2], …) 从前面的n-1个值得到最优的第n个值 最优子结构 动态规划是自下而上的解决问题。（先解决小数据量下的问题怎么解决，之后层层递推更大的数据量问题。） 将原问题拆解成若干子问题，同时保存子问题的答案，使得每个子问题只求解一次，最终获得原问题的答案。 学习内容： 509. 斐波那契数列 70. 爬楼梯 不同路径 不同路径 II 64. 最小路径和 120. 三角形最小路径和 打家劫舍 打家劫舍 II 打家劫舍 III 最佳买卖股票时机含冷冻期 买卖股票的最佳时机含手续费 509. 斐波那契数列求值 \(f(n)=f(n-1)+f(n-2)\) 斐波那契数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。 [0,1,1,2,3,5,8,13,…] 给定n,计算 f(N) 方法：动态规划 递归 + 记忆化 -&gt; 递推 递推公式：A[i] = A[i-1] + A[i-2] 12345678910class Solution: def fib(self, N: int) -&gt; int: if (N &lt;= 1): return N A = [None]*(N+1) A[0] = 0 A[1] = 1 for i in range(2, N+1): A[i] = A[i-1] + A[i-2] return A[N] 更简洁的写法： 123456789class Solution: def fib(self, N: int) -&gt; int: if (N &lt;= 1): return N previous = 0 current = 1 for _ in range(N-1): previous, current = current, previous + current return current 70. 爬楼梯 Climbing Stairs 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 注意：给定 n 是一个正整数。 示例 ： 123456输入： 3输出： 3解释： 有三种方法可以爬到楼顶。1. 1 阶 + 1 阶 + 1 阶2. 1 阶 + 2 阶3. 2 阶 + 1 阶 方法：动态规划 当有 \(n\) 个台阶时，可供选择的走法可以分两类：1，先跨一阶再跨完剩下 \(n-1\) 阶；2，先跨2阶再跨完剩下 \(n-2\) 阶。所以 \(n\) 阶的不同走法的数目是 \(n-1\) 阶和 \(n-2\) 阶的走法数的和。 这和斐波那契数列的规律相同，可以用这个思路。 动态规划来记录历史数据。 12345678910class Solution: def climbStairs(self, n): """ :type n: int :rtype: int """ prev, current = 0, 1 for i in range(n): prev, current = current, prev + current return current 62. 不同路径 一个机器人位于一个 m x n 网格的左上角。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。 问总共有多少条不同的路径？ 示例 1: 1234567输入: m = 3, n = 2输出: 3解释:从左上角开始，总共有 3 条路径可以到达右下角。1. 向右 -&gt; 向右 -&gt; 向下2. 向右 -&gt; 向下 -&gt; 向右3. 向下 -&gt; 向右 -&gt; 向右 方法 每一格子都是左边和上边之和 1234567891011class Solution: def uniquePaths(self, m: int, n: int) -&gt; int: grid = [[0]*n for _ in range(m)] for i in range(n): grid[0][i] = 1 for i in range(m): grid[i][0] = 1 for i in range(1,m): for j in range(1,n): grid[i][j] = grid[i][j-1] + grid[i-1][j] return grid[m-1][n-1] 63. 不同路径 II 一个机器人位于一个 m x n 网格的左上角。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。 现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？ 示例 1: 123456789101112输入:[ [0,0,0], [0,1,0], [0,0,0]]输出: 2解释:3x3 网格的正中间有一个障碍物。从左上角到右下角一共有 2 条不同的路径：1. 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下2. 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右 方法 1234567891011121314151617class Solution: def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -&gt; int: m, n = len(obstacleGrid), len(obstacleGrid[0]) dp = [[0]*n for _ in range(m)] if obstacleGrid[0][0] == 0: dp[0][0] = 1 for i in range(m): for j in range(n): if obstacleGrid[i][j] == 1: dp[i][j] = 0 else: if i!=0:#不是最上面一行 dp[i][j] += dp[i-1][j] if j!=0: dp[i][j] += dp[i][j-1] return dp[m-1][n-1] 64. 最小路径和 给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。 说明：每次只能向下或者向右移动一步。 示例: 12345678输入:[ [1,3,1], [1,5,1], [4,2,1]]输出: 7解释: 因为路径 1→3→1→1→1 的总和最小。 方法：动态规划 新的一个点的最短路径一定等于其上方、左方最短路径+当前的值。 第一行的每个状态 = 左边状态+当前位置 第一列的每个状态 = 上边状态+当前位置。 其余位置 = 上边和左边的状态最小值 + 当前位置。 1234567891011121314151617class Solution: def minPathSum(self, grid: List[List[int]]) -&gt; int: if not grid or not grid[0]: return 0 m,n = len(grid),len(grid[0]) # 行列数 for i in range (m): for j in range(n): if i==0 and j==0: before = 0 elif i==0: before = grid[0][j-1] elif j==0: before = grid[i-1][0] else: before = min(grid[i-1][j], grid[i][j-1]) grid[i][j] = before + grid[i][j] return grid[m-1][n-1] 题目中说每个格子里是非负整数，负数会有什么影响？ 限定的只能左移或下移，如果没有限定，上下左右都可以，会怎么办？ 120. 三角形最小路径和 给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。 例如，给定三角形： 1234567[ [2], [3,4], [6,5,7], [4,1,8,3]]自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。 方法：从下到上的动态规划 从顶向下的DP会导致元素越来越多，因此不是很方便，从下向上的DP做。 用minpath[k][i]保存从下向上得到的第 k 层第 i 个位置的最短路径。那么有： minpath[k][i] = min( minpath[k+1][i], minpath[k+1][i+1]) + triangle[k][i] 可以看出 minpath[k][i] 只被用到了一次，所以可以变成一维DP： 12For the kth level:minpath[i] = min( minpath[i], minpath[i+1]) + triangle[k][i]; 注意， - dp的初始化应该是最下面一层，然后从倒数第二层开始遍历； - 第layer的元素是layer + 1个。 时间复杂度为O(n^2)，空间复杂度O(n)。n为三角形高度。 1234567class Solution: def minimumTotal(self, triangle: List[List[int]]) -&gt; int: dp = triangle[-1] for layer in range(len(triangle)-2, -1, -1): for i in range(layer+1): dp[i] = min(dp[i], dp[i+1]) + triangle[layer][i] return dp[0] 198. 打家劫舍 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。 给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。 示例 1: 1234输入: [1,2,3,1]输出: 4解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。 偷窃到的最高金额 = 1 + 3 = 4 。 示例 2: 1234输入: [2,7,9,3,1]输出: 12解释: 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。 偷窃到的最高金额 = 2 + 9 + 1 = 12 。 方法一 假设只有一家，那么你只能偷这家；假设有两家，那么你要判断两家哪个钱多，偷哪个；依次类推，假设有n家，那么你要判断“偷第n家不偷第n-1家且前n-2家尽量多的偷”和“不偷第n家且前n-1家尽量多的偷”，哪个得到的钱多偷哪个。 你可以递归求解，然而复杂度太高无法AC。所以应该记录已经计算过的结果，于是这变成一个动态规划问题。 12345678910class Solution: def rob(self, nums: List[int]) -&gt; int: if len(nums) == 0: return 0 elif len(nums)&lt;2: return max(nums[0], nums[-1]) money = [0]*len(nums) money[0],money[1] = nums[0], max(nums[0], nums[1]) for i in range(2, len(nums)): money[i] = max(nums[i] + money[i-2], money[i-1]) return money[len(nums)-1] 方法二：更简洁的写法 上 面的代码使用的空间是冗余的，因为每次循环只会用到前两个数据。所以代码可以降低空间复杂度到O(1)。 123456class Solution: def rob(self, nums: List[int]) -&gt; int: now = last = 0 for i in nums: last, now = now, max(i+last, now) return now 213. 打家劫舍 II 你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都围成一圈，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。 给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。 示例 1: 123输入: [2,3,2]输出: 3解释: 你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。 示例 2: 1234输入: [1,2,3,1]输出: 4解释: 你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。 偷窃到的最高金额 = 1 + 3 = 4 。 方法 这个是198题的拓展。本题目里面的房间是一个环的，也就是说第一个房子和最后一个房子是相邻的。在这种情况下，相邻的两个房子不能一起偷，求能偷到的金额的最大值。 多了环的条件，在这个约束下就多了个不同时偷第一个和最后一个就可以了。所以，两种偷的情况：第一种不偷最后一个房间，第二种不偷第一个房间，求这两种偷法能获得的最大值。所以只多了一个切片的过程。 状态转移方程仍然是： 123dp[0] = num[0] （当i=0时） dp[1] = max(num[0], num[1]) （当i=1时） dp[i] = max(num[i] + dp[i - 2], dp[i - 1]) （当i !=0 and i != 1时） 第三个式子就是当前的房间偷的情况和不偷情况下的最大值。 时间复杂度是O(N)，空间复杂度是O(N). 1234567891011121314151617181920class Solution: def rob(self, nums: List[int]) -&gt; int: if not nums: return 0 N = len(nums) if N == 1: return nums[0] if N == 2: return max(nums[0], nums[1]) return max(self.rob_range(nums[0: N-1]), self.rob_range(nums[1:N])) def rob_range(self, nums): if not nums: return 0 N = len(nums) if N == 1: return nums[0] if N == 2: return max(nums[0], nums[1]) dp = [0]*N dp[0] = nums[0] dp[1] = max(nums[0], nums[1]) for i in range(2, N): dp[i] = max(dp[i-1], dp[i-2] + nums[i]) return dp[-1] 337. 打家劫舍 III 在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。 计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。 示例 1: 12345678910输入: [3,2,3,null,3,null,1] 3 / \ 2 3 \ \ 3 1输出: 7 解释: 小偷一晚能够盗取的最高金额 = 3 + 3 + 1 = 7. 示例 2: 12345678910输入: [3,4,5,1,3,null,1] 3 / \ 4 5 / \ \ 1 3 1输出: 9解释: 小偷一晚能够盗取的最高金额 = 4 + 5 = 9. 方法 就是求本节点+孙子更深节点vs儿子节点+重孙更深的节点的比较。 用了dfs函数，虽然递归是自顶向下的，但是因为是不断的return，所以真正求值是从底向上的。 用到了一个有两个元素的列表，分别保存了之前层的，不取节点和取节点的情况。然后遍历左右子树，求出当前节点取和不取能得到的值，再返回给上一层。 注意这个里面的robcur是当前节点能达到的最大值，所以最后返回结果的时候试试返回的root节点robcur的值 123456789101112131415161718# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def rob(self, root: TreeNode) -&gt; int: def dfs(root): if not root: return [0, 0] left = dfs(root.left) right = dfs(root.right) norob = left[1] + right[1] #本节点不抢劫，儿子节点的最大值 robcur = max(root.val + left[0] + right[0], norob) return [norob, robcur] return dfs(root)[1] 309. 最佳买卖股票时机含冷冻期 给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。​ 设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。 示例: 123输入: [1,2,3,0,2]输出: 3 解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出] 方法 这个题和 714题 比较像。做题方法都是使用了两个数组： sell 该天结束手里没有股票的情况下，已经获得的最大收益 sell[i]代表的是手里没有股票的收益，这种可能性是今天卖了或者啥也没干。 max(昨天手里有股票的收益+今天卖股票的收益，昨天手里没有股票的收益)， 即 max(sell[i - 1], hold[i - 1] + prices[i])； hold 该天结束手里有股票的情况下，已经获得的最大收益 hold[i]代表的是手里有股票的收益，这种可能性是今天买了股票或者啥也没干，今天买股票必须昨天休息。 max(今天买股票是前天卖掉股票的收益-今天股票的价格，昨天手里有股票的收益）。即 max(hold[i - 1], sell[i - 2] - prices[i])。 另外需要注意的是，题目说的是昨天卖了股票的话今天不能买，对于开始的第一天，不可能有卖股票的行为，所以需要做个判断。 该算法的时间复杂度是O(n)，空间复杂度是O(n)。 12345678910class Solution: def maxProfit(self, prices: List[int]) -&gt; int: if not prices: return 0 sell = [0] * len(prices) #没有股票的收益 hold = [0] * len(prices) #持有股票的收益 hold[0] = -prices[0] #第一天 for i in range(1, len(prices)): sell[i] = max(sell[i-1], hold[i-1] + prices[i]) hold[i] = max(hold[i-1], (sell[i-2] if i&gt;=2 else 0) - prices[i]) return sell[-1] 如果使用O(1)的空间复杂度，那么就可以写成下面这样： 123456789101112class Solution: def maxProfit(self, prices: List[int]) -&gt; int: if not prices: return 0 prev_sell = 0 curr_sell = 0 hold = -prices[0] for i in range(1, len(prices)): temp = curr_sell curr_sell = max(curr_sell, hold + prices[i]) hold = max(hold, (prev_sell if i &gt;= 2 else 0) - prices[i]) prev_sell = temp return curr_sell 714. 买卖股票的最佳时机含手续费 给定一个整数数组 prices，其中第 i 个元素代表了第 i 天的股票价格 ；非负整数 fee 代表了交易股票的手续费用。 你可以无限次地完成交易，但是你每次交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。 返回获得利润的最大值。 示例 1: 12345678输入: prices = [1, 3, 2, 8, 4, 9], fee = 2输出: 8解释: 能够达到的最大利润: 在此处买入 prices[0] = 1在此处卖出 prices[3] = 8在此处买入 prices[4] = 4在此处卖出 prices[5] = 9总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8. 注意: 0 &lt; prices.length &lt;= 50000. 0 &lt; prices[i] &lt; 50000. 0 &lt;= fee &lt; 50000. 方法:动态规划 该dp使用了两个数字，cash和hold。解释如下： cash 该天结束手里没有股票的情况下，已经获得的最大收益 hold 该天结束手里有股票的情况下，已经获得的最大收益 所以转移状态分析如下： cash 更新的策略是：既然今天结束之后手里没有股票，那么可能是今天没买（保持昨天的状态），也可能是今天把股票卖出了 hold 更新的策略是：今天今天结束之后手里有股票，那么可能是今天没卖（保持昨天的状态），也可能是今天买了股票 12345678910class Solution: def maxProfit(self, prices: List[int], fee: int) -&gt; int: cash = 0 hold = -prices[0] for i in range(1,len(prices)): #没操作,保持昨天的状态；今天卖出股票 cash = max(cash, hold+prices[i]-fee) # 没操作,保持昨天的状态；今天买了股票 hold = max(hold, cash-prices[i]) return cash 参考 【LeetCode】120. Triangle 解题报告（Python）]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>LeetCode</tag>
        <tag>数据结构</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python解LeetCode链表(3)]]></title>
    <url>%2F2019%2F04%2F05%2Fpython_linklist(3)%2F</url>
    <content type="text"><![CDATA[转换链表节点的位置 （穿针引线） 反转链表 反转链表 II 两两交换链表中的节点 K 个一组翻转链表 旋转链表 分隔链表 重排链表 排序 对链表进行插入排序 排序链表（归并排序） 奇偶链表 206.反转链表 Reverse Linked List 反转一个单链表。 示例: 12输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL 方法一：两个指针，头插法 用两个指针，p指针记录的是每次的队头元素，q指针指向下一个要插入队头的元素。 head帮忙指向下轮要头插的元素，待本轮指针翻转完之后要把该元素赋给q 12345678910111213141516class Solution(object): def reverseList(self, head): """ :type head: ListNode :rtype: ListNode """ if not head: return None p = head # p是指向每次的队头元素 q = head.next # q是指下一个要插入队头的元素 while q: head.next = q.next # 保留后一个要插入的元素地址 q.next = p # 指针反转，next为队头元素 p = q #q插入，作为新的队头 q = head.next # 重新指定下一个要插入队头的元素 return p 方法二 1234567class Solution: def reverseList(self, head: ListNode) -&gt; ListNode: cur, prev = head, None while cur: # 链表反转，更新指针pre，更新指针cur cur.next, prev, cur = prev, cur, cur.next return prev 92. 反转链表 II 反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。 说明: 1 ≤ m ≤ n ≤ 链表长度。 示例: 12输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4输出: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL 方法 翻转链表的而变形题目了。进行一遍遍历，把第m到n个元素进行翻转，即依次插入到第m个节点的头部。 实际面试中细节考虑：m和n超过链表范围怎么办？ m&gt;n怎么办？ 1234567891011121314151617181920212223class Solution: def reverseBetween(self, head: ListNode, m: int, n: int) -&gt; ListNode: count = 1 root = ListNode(1) root.next = head pre = root while pre.next and count&lt;m: pre = pre.next count += 1 if count &lt; m: return head mNode = pre.next curr = mNode.next while curr and count&lt;n: Next = curr.next curr.next = pre.next pre.next = curr mNode.next = Next curr = Next count += 1 return root.next 24. 两两交换链表中的节点 Swap Nodes in Pairs 给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。 示例: 给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3. 方法 a, b, pre 三个指针变量 123456789101112131415# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def swapPairs(self, head: ListNode) -&gt; ListNode: pre, pre.next = self, head while pre.next and pre.next.next: #考虑奇数和偶数 a = pre.next # pre是每次要调换的两个元素的前一个元素 b = a.next # a,b是要调换的相邻元素 pre.next, b.next, a.next =b, a, b.next # next连线重置 pre = a return self.next 25. K 个一组翻转链表 给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。 k 是一个正整数，它的值小于或等于链表的长度。 如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。 示例 : 123给定这个链表：1-&gt;2-&gt;3-&gt;4-&gt;5当 k = 2 时，应当返回: 2-&gt;1-&gt;4-&gt;3-&gt;5当 k = 3 时，应当返回: 3-&gt;2-&gt;1-&gt;4-&gt;5 说明 : 你的算法只能使用常数的额外空间。 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。 方法 翻转函数单独写出来调用更清晰。每次k个元素翻转，再和前后两个节点连接起来。 123456789101112131415161718192021222324252627class Solution: def reverseKGroup(self, head: ListNode, k: int) -&gt; ListNode: if not head or k &lt;= 1: return head dummy = ListNode(-1) #设立链表的虚拟头结点 dummy.next = head temp = dummy # 遍历整个链表 while temp: temp = self.reverseNextK(temp, k) return dummy.next def reverseNextK(self, head, k): # 检查当前遍历剩余节点数是否比k小 temp = head for _ in range(k): if not temp.next: return None temp = temp.next prev, cur, tail = head, head.next, head.next for _ in range(k): # 链表反转，更新指针pre，更新指针cur cur.next, prev, cur = prev, cur, cur.next # 连接头head和尾tail head.next, tail.next = prev, cur return tail 61. 旋转链表 给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。 示例 1: 12345输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k = 2输出: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL解释:向右旋转 1 步: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULL向右旋转 2 步: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL 示例 2: 1234567输入: 0-&gt;1-&gt;2-&gt;NULL, k = 4输出: 2-&gt;0-&gt;1-&gt;NULL解释:向右旋转 1 步: 2-&gt;0-&gt;1-&gt;NULL向右旋转 2 步: 1-&gt;2-&gt;0-&gt;NULL向右旋转 3 步: 0-&gt;1-&gt;2-&gt;NULL向右旋转 4 步: 2-&gt;0-&gt;1-&gt;NULL 方法 首先，可以从Example 2也能看出来，存在k&gt;len的情况，这样必须求余运算，否则肯定超时。即要求链表的长度。 其次，如果求余之后，知道了移动几次，本质上就是把链表的后面k个节点移动到开头去。注意是平移，顺序不变的。所以要找到后面的k个节点，那么需要用到19. Remove Nth Node From End of List类似的方法，用两个距离为k的指针进行平移操作，当前面的到达了末尾，那么后面的正好是倒数第k个。 找到倒数第k个之后，那么把这个节点和之前的节点断开，把后面的这段移到前面去即可。 1234567891011121314151617181920212223class Solution: def rotateRight(self, head: ListNode, k: int) -&gt; ListNode: if not head or not head.next: return head root = head _len = 0 while head: _len += 1 head = head.next k %= _len if k == 0: return root fast, slow = root,root while k-1: fast = fast.next k -= 1 pre = slow while fast.next: fast = fast.next pre = slow slow = slow.next pre.next = None fast.next = root return slow 86. 分隔链表 给定一个链表和一个特定值 x，对链表进行分隔，使得所有小于 x 的节点都在大于或等于 x 的节点之前。 你应当保留两个分区中每个节点的初始相对位置。 示例: 12输入: head = 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x = 3输出: 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5 方法 做链表的题，不要省指针。 这个题类似于快排的过程。 用两个新指针，分别记录比x值小的和比x值大的，遍历原来的链表的时候根据值的大小拼接到对应的链表后面。 最后再把两个链表拼接到一起就行了。 12345678910111213141516class Solution: def partition(self, head: ListNode, x: int) -&gt; ListNode: small = ListNode(0) large = ListNode(0) small_root, large_root = small, large while head: if head.val &lt; x: small.next = head small = small.next else: large.next = head large = large.next head = head.next large.next = None small.next = large_root.next return small_root.next 143. 重排链表 给定一个单链表 L：L0→L1→…→Ln-1→Ln ， 将其重新排列后变为： L0→Ln→L1→Ln-1→L2→Ln-2→… 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。 示例1:给定链表 1-&gt;2-&gt;3-&gt;4, 重新排列为 1-&gt;4-&gt;2-&gt;3. 示例 2: 1给定链表 1-&gt;2-&gt;3-&gt;4-&gt;5, 重新排列为 1-&gt;5-&gt;2-&gt;4-&gt;3. 方法 题目大意:把一个链表的前半部分正序，后半部分逆序，然后一个一个的连接起来。 链表无法随机访问数据，如何获得中间的元素？ 奇数还是偶数个节点？ 两次遍历还是一次遍历？ 123456789101112131415161718192021222324252627282930313233343536373839class Solution(object): def reorderList(self, head): """ :type head: ListNode :rtype: None Do not return anything, modify head in-place instead. """ if head and head.next and head.next.next: # 找中间位置head2 fast, slow = head, head while fast.next and fast.next.next: fast = fast.next.next slow = slow.next head1 = head head2 = slow.next slow.next = None # 前半部分结尾空 # 反转head2后半部分 pre = ListNode(0) pre.next = head2 curr = head2.next head2.next = None # 后半部分结尾空 while curr: temp = curr curr = curr.next temp.next = pre.next pre.next = temp head2 = pre.next # 两部分交叉连接 p1, p2 = head1, head2 while p2: temp1 = p1.next temp2 = p2.next p1.next = p2 p2.next = temp1 p1 = temp1 p2 = temp2 147. 对链表进行插入排序 插入排序算法： 插入排序是迭代的，每次只移动一个元素，直到所有元素可以形成一个有序的输出列表。 每次迭代中，插入排序只从输入数据中移除一个待排序的元素，找到它在序列中适当的位置，并将其插入。 重复直到所有输入数据插入完为止。 方法 123456789101112131415161718192021class Solution(object): def insertionSortList(self, head): """ :type head: ListNode :rtype: ListNode """ if not head or not head.next: return head pre = ListNode(0) pre.next = head while head.next: # 遍历每个元素，如果小于就插入前面 if head.val &lt;= head.next.val: head = head.next else: temp = head.next # temp用来跟前面的有序数列进行依次比较 head.next = head.next.next # 删掉该元素 p = pre #有序数列从前开始比较 while p.next and p.next.val&lt;= temp.val: p = p.next temp.next = p.next p.next = temp return pre.next 148. 排序链表 在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序。 示例 1: 输入: 4-&gt;2-&gt;1-&gt;3 输出: 1-&gt;2-&gt;3-&gt;4 示例 2: 输入: -1-&gt;5-&gt;3-&gt;4-&gt;0 输出: -1-&gt;0-&gt;3-&gt;4-&gt;5 方法 这个题要求用O(nlongn)的时间复杂度和O(1)的空间复杂度。所以可以使用merge排序，但是如果是链表可以修改指针，把两个有序链表进行原地的合并。 Merge排序就是先划分成一前一后等分的两块，然后对两块分别进行排序，然后再合并两个有序序列。 第一步，如何等分地划分，可以使用快慢指针的方式，当快指针到达结尾，那么慢指针到了中间位置，把链表进行截断分成了两个。 第二步，合并有序的序列，对于单链表来说，正好用到了 Merge Two Sorted Lists 里的把两个链表合并的方法。 事实上，这个答案里面并不是O(1)的空间，因为，第一，添加了新的链表头的个数会随着递归的次数而不断增加，并不是常量个；第二，递归本身就不是常量空间。 1234567891011121314151617181920212223242526272829303132333435class Solution(object): def sortList(self, head): """ :type head: ListNode :rtype: ListNode """ # 划分成两部分 if not head or not head.next: return head pre, fast, slow = head, head, head while fast and fast.next: # 找中间位置 pre = slow slow = slow.next fast = fast.next.next pre.next = None # 前半部分结尾空 L1 = self.sortList(head) # 递归划分 L2 = self.sortList(slow) return self.merge2Lists(L1, L2) # 合并两个有序数组 def merge2Lists(self, l1, l2): head = ListNode(0) move = head if not l1: return l2 if not l2: return l1 while l1 and l2: if l1.val &lt;= l2.val: move.next = l1 l1 = l1.next else: move.next = l2 l2 = l2.next move = move.next move.next = l2 if l2 else l1 return head.next 328.奇偶链表 方法 给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。 请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。 示例 1: 12输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 1-&gt;3-&gt;5-&gt;2-&gt;4-&gt;NULL 示例 2: 12输入: 2-&gt;1-&gt;3-&gt;5-&gt;6-&gt;4-&gt;7-&gt;NULL 输出: 2-&gt;3-&gt;6-&gt;7-&gt;1-&gt;5-&gt;4-&gt;NULL 说明: 应当保持奇数节点和偶数节点的相对顺序。 链表的第一个节点视为奇数节点，第二个节点视为偶数节点，以此类推。 方法 两条链,如果是奇数节点放到奇链，如果是偶数节点就放到偶链。最后，把偶链放到奇链的后面就好了。 注意，偶链的末尾指针要设置成空，已让单链表终止。 比如对于用例[1,2,3]，奇数链是1-&gt;3，偶链是2，而遍历完成后的偶链2仍然指向3的，所以死循环了。把尾指针设置成空就能终止了。 123456789101112131415161718class Solution: def oddEvenList(self, head: ListNode) -&gt; ListNode: odd = ListNode(0) even = ListNode(0) oddHead, evenHead = odd, even index = 0 while head: if index &amp; 1 == 0: odd.next = head odd = odd.next else: even.next = head even = even.next head = head.next index += 1 even.next = None odd.next = evenHead.next return oddHead.next 参考 LeetCode 2. Add Two Numbers 解题报告（Python &amp; C++） 【LeetCode】142. Linked List Cycle II 解题报告（Python &amp; C++）]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>LeetCode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[梯度提升树(GBDT)算法梳理]]></title>
    <url>%2F2019%2F04%2F04%2F%E6%A2%AF%E5%BA%A6%E6%8F%90%E5%8D%87%E5%86%B3%E7%AD%96%E6%A0%91(GBDT)%E7%AE%97%E6%B3%95%E6%A2%B3%E7%90%86%2F</url>
    <content type="text"><![CDATA[梯度提升决策树（Gradient Boosting Decision Tree， GBDT）是Boosting算法中非常流行的模型，也是近来在机器学习竞赛、商业应用中表现都非常优秀的模型。GBDT非常好地体现了“从错误中学习”的理念，基于决策树预测的残差进行迭代的学习。 学习任务： 前向分步算法 负梯度拟合 损失函数 回归 二分类，多分类 正则化 优缺点 sklearn参数 GDBT 基本思想是根据当前模型损失函数的负梯度信息来训练新加入的弱分类器， 然后将训练好的弱分类器以累加的形式结合到现有模型中。 采用决策树作为弱分类器的Gradient Boosting算法被称为GBDT，有时又被称为MART（Multiple Additive Regression Tree）。GBDT中使用的决策树通常为CART。 GBDT中每一棵树学的是之前所有树结论和的残差， 这个残差就是一个加预测值后能得真实值的累加量。 举例子来说，假设对每个用户的年龄做出预测，例如用户A的真实年龄是25岁， 但第一棵决策树的预测年龄是22岁， 差了3岁， 即残差为3。 那么在第二棵树里我们把A的年龄设为3岁去学习， 如果第二棵树能把A分到3岁的叶子节点， 那两棵树的结果相加就可以得到A的真实年龄； 如果第二棵树的结论是5岁， 则A仍然存在−2岁的残差， 第三棵树里A的年龄就变成−2岁，继续学。 这里使用残差继续学习， 就是GBDT中Gradient Boosted所表达的意思。 前向分步算法 在GBDT的迭代中，假设我们前一轮迭代得到的强学习器（即当前模型）是 \(f_{m-1}(x)\), 损失函数是 \(L(y, f_{m-1}(x))\) , 我们本轮迭代的目标是找到一个CART回归树模型的弱学习器 \(h(x:\alpha_{m})\)，让本轮的损失函数 \(L(y, f_{m}(x) =L(y, f_{m-1}(x)+ h(x:\alpha))\) 最小。也就是说，从前向后，每一步只学习一个基函数及其系数，逐步逼近优化损失函数。 输入：训练数据集 \(T=\{(x_,y_1),(x_2,y_2), ...(x_N,y_N)\}\); 损失函数是 \(L(y, f(x))\); 基函数集 \({h(x:\alpha)}\); 输出：加法模型\(f(x)\). 初始化\(f_{0}(x)=0\) For \(m=1\) to \(M\) do： 通过极小化损失函数(如下公式1)得到下一颗决策树的参数:\(\beta_{m},\alpha_{m}\). \[(\beta_{m},\alpha_{m}) = arg\min \limits_{\beta,\alpha}\sum\limits_{i=1}^{N} L(y_i,f_{m-1}(x_i) + \beta h(x:\alpha))\tag{1}\] 更新 \[f_{m}(x) = f_{tm-1}(x) + \beta_{m} h(x:\alpha_{m}))\tag{2}\] 5. 前三步循环结束即可得到加法模型： \[f(x) = f_{M}(x) = \sum\limits_{m=1}^{M} \beta_{m} h(x:\alpha_{m}))\tag{3}\] GBDT 的负梯度拟合 若上述算法采用平方误差损失函数, \[L(y, f(x)) = (y-f(x))^2\tag{4}\] 其损失变为 \[L(y,f_{m-1}(x) + \beta h(x:\alpha) \\=[y-f_{m-1}(x) - \beta h(x:\alpha)]^2 \\=[r - \beta h(x:\alpha)]^2\] 这里， \[r = y - f_{m-1}(x)\tag{5}\] 是当前模型拟合数据的残差（residual ). 所以， 对冋归问题的提升树算法来说，只需简单地拟合当前模型的残差. 提升树利用加法模型与前向分歩算法实现学习的优化过程. 当损失函数是平方损失和指数损失函数时， 每一步优化是很简单的. 但对一般损失函数而言， 往往每一步优化并不那么容易. 损失函数各种各样，怎么找到一种通用的拟合方法呢？ 针对这一问题， Freidman 提出了梯度提升（gradient boosting) 算法. 这是利用最速下降法的近似方法， 其关键是利用损失函数的负梯度在当前模型的值来拟合本轮损失（即残差）的近似值。第m轮的第i个样本的损失函数的负梯度表示为下式(6): \[r_{mi} = -\bigg[\frac{\partial L(y_i, f(x_i)))}{\partial f(x_i)}\bigg]_{f(x) = f_{m-1}\;\; (x)}\tag{6}\] GBDT 的算法思想 在每一轮迭代中， 计算出当前模型在所有样本上的负梯度（可以作为残差的近似值） 以该值为目标训练一个新的弱分类器进行拟合 计算出该弱分类器的权重 最终实现对模型的更新 Gradient Boosting算法的伪代码如下： 输入：训练数据集 \(T=\{(x_,y_1),(x_2,y_2), ...(x_N,y_N)\}\); 损失函数是 \(L(y, f(x))\); 基函数集 \({h(x:\alpha)}\); 输出：加法模型\(f(x)\). 初始化\(f_{0}(x)= arg\min \limits_{\rho}\sum\limits_{i=1}^{N} L(y_i,\rho))\) For \(m=1\) to \(M\) do： 计算负梯度 \[r_{mi} = -\bigg[\frac{\partial L(y_i, f(x_i)))}{\partial f(x_i)}\bigg]_{f(x) = f_{m-1}\;\; (x)}\tag{6}\] 通过极小化损失函数得到新的学习器的参数:下降的步长\(\beta_{m}\)和方向 \(\alpha_{m}\). \[\alpha_{m} = arg\min \limits_{\beta,\alpha}\sum\limits_{i=1}^{N} (r_{mi} - \beta h(x_i:\alpha))^2\tag{7}\] - (3) 计算新学习器的权重 \[\rho_m = arg\min \limits_{\rho}\sum\limits_{i=1}^{N} L(y_i,f_{m-1}(x_i) + \rho h(x_i:\alpha_{m}))\tag{8}\] 更新 \[f_{m}(x) = f_{m-1}(x) + \rho_{m} h(x:\alpha_{m}))\tag{9}\] 5. 循环结束即可得到加法模型： \[f(x) = f_{M}(x) = \sum\limits_{m=1}^{M} \rho_{m} h(x:\alpha_{m}))\tag{10}\] 由于GBDT是利用残差训练的， 在预测的过程中， 我们需要把所有树的预测值加起来， 得到最终的预测结果。 GBDT回归算法 输入是训练集样本\(T=\{(x_,y_1),(x_2,y_2), ...(x_m,y_m)\}\)， 最大迭代次数T, 损失函数L。 输出是强学习器f(x) 初始化弱学习器 \[f_0(x) = \underbrace{arg\; min}_{c}\sum\limits_{i=1}^{m}L(y_i, c)\] 对迭代轮数t=1,2,...T有： a)对样本i=1,2，...m，计算负梯度 \[r_{ti} = -\bigg[\frac{\partial L(y_i, f(x_i)))}{\partial f(x_i)}\bigg]_{f(x) = f_{t-1}\;\; (x)}\] b)利用\((x_i,r_{ti})\;\; (i=1,2,..m)\), 拟合一颗CART回归树,得到第t颗回归树，其对应的叶子节点区域为\(R_{tj}, j =1,2,..., J\)。其中J为回归树t的叶子节点的个数。 对叶子区域j =1,2,..J,计算最佳拟合值 \[c_{tj} = \underbrace{arg\; min}_{c}\sum\limits_{x_i \in R_{tj}} L(y_i,f_{t-1}(x_i) +c)\] 更新强学习器 \[f_{t}(x) = f_{t-1}(x) + \sum\limits_{j=1}^{J}c_{tj}I(x \in R_{tj})\] 得到强学习器f(x)的表达式 \[f(x) = f_T(x) =f_0(x) + \sum\limits_{t=1}^{T}\sum\limits_{j=1}^{J}c_{tj}I(x \in R_{tj})\] GBDT分类算法 GBDT的分类算法从思想上和GBDT的回归算法没有区别，但是由于样本输出不是连续的值，而是离散的类别，导致我们无法直接从输出类别去拟合类别输出的误差。 为了解决这个问题，主要有两个方法， 用指数损失函数，此时GBDT退化为Adaboost算法。 是用类似于逻辑回归的对数似然损失函数的方法。也就是说，我们用的是类别的预测概率值和真实概率值的差来拟合损失。 本文仅讨论用对数似然损失函数的GBDT分类。对此我们又有二元分类和多元分类的区别。 二元GBDT分类算法 对于二元GBDT，如果用类似于逻辑回归的对数似然损失函数，则损失函数为： \[L(y, f(x)) = log(1+ exp(-yf(x)))\] 其中\(y∈\{−1,+1\}\).则此时的负梯度误差为: \[r_{mi} = -\bigg[\frac{\partial L(y, f(x_i)))}{\partial f(x_i)}\bigg]_{f(x) = f_{m-1}\;\; (x)} = \frac{y_i}{1+exp(y_if(x_i))}\] 对于生成的决策树，我们各个叶子节点的最佳负梯度拟合值为: \[c_{mj} = \underbrace{arg\; min}_{c}\sum\limits_{x_i \in R_{mj}} log(1+exp(-y_i(f_{m-1}(x_i) +c)))\] 由于上式比较难优化，我们一般使用近似值代替 \[c_{mj} = \frac{\sum\limits_{x_i \in R_{mj}}r_{mi}} {\sum\limits_{x_i \in R_{mj}}|r_{mi}|(1-|r_{mi}|)}\] 除了负梯度计算和叶子节点的最佳负梯度拟合的线性搜索，二元GBDT分类和GBDT回归算法过程相同。 多元GBDT分类算法 多元GBDT要比二元GBDT复杂一些，对应的是多元逻辑回归和二元逻辑回归的复杂度差别。 假设类别数为K，则此时我们的对数似然损失函数为： \[L(y, f(x)) = - \sum\limits_{k=1}^{K}y_klog\;p_k(x)\] 其中如果样本输出类别为k，则\(y_k=1\)。第k类的概率\(p_k(x)\)的表达式为： \[p_k(x) = \frac{exp(f_k(x))} {\sum\limits_{l=1}^{K} exp(f_l(x))}\] 集合上两式，我们可以计算出第t轮的第i个样本对应类别l的负梯度误差为 \[r_{mil} = -\bigg[\frac{\partial L(y_i, f(x_i)))}{\partial f(x_i)}\bigg]_{f_k(x) = f_{l, m-1}\;\; (x)} = y_{il} - p_{l, m-1}(x_i)\] 观察上式可以看出，其实这里的误差就是样本i对应类别l的真实概率和m−1轮预测概率的差值。 对于生成的决策树，我们各个叶子节点的最佳负梯度拟合值为 \[c_{mjl} = \underbrace{arg\; min}_{c_{jl}}\sum\limits_{i=0}^{m}\sum\limits_{k=1}^{K} L(y_k, f_{m-1, l}(x) + \sum\limits_{j=0}^{J}c_{jl} I(x_i \in R_{mj}))\] 由于上式比较难优化，我们一般使用近似值代替 \[c_{tjl} = \frac{K-1}{K} \; \frac{\sum\limits_{x_i \in R_{tjl}}r_{til}}{\sum\limits_{x_i \in R_{til}}|r_{til}|(1-|r_{til}|)}\] 除了负梯度计算和叶子节点的最佳负梯度拟合的线性搜索，多元GBDT分类和二元GBDT分类以及GBDT回归算法过程相同。 GBDT常用损失函数 分类算法 损失函数一般有对数损失函数和指数损失函数两种: 指数损失函数 \[L(y, f(x)) = exp(-yf(x))\] 其负梯度计算和叶子节点的最佳负梯度拟合和Adaboost原理相同。 对数损失函数，分为二元分类和多元分类两种，参见上文的GBDT分类算法。 回归算法 常用损失函数有如下4种: 均方差，最常见的回归损失函数 \[L(y, f(x)) =(y-f(x))^2\] 2. 绝对损失，这个损失函数也很常见 \[L(y, f(x)) =|y-f(x)|\] 对应负梯度误差为： \[sign(y_i-f(x_i))\] Huber损失，它是均方差和绝对损失的折衷产物，对于远离中心的异常点，采用绝对损失，而中心附近的点采用均方差。这个界限一般用分位数点度量。损失函数如下： \[L(y, f(x))= \begin{cases} \frac{1}{2}(y-f(x))^2&amp; {|y-f(x)| \leq \delta}\\ \delta(|y-f(x)| - \frac{\delta}{2})&amp; {|y-f(x)| &gt; \delta} \end{cases}\] 对应的负梯度误差为： \[r(y_i, f(x_i))= \begin{cases} y_i-f(x_i)&amp; {|y_i-f(x_i)| \leq \delta}\\ \delta sign(y_i-f(x_i))&amp; {|y_i-f(x_i)| &gt; \delta} \end{cases}\] 分位数损失。它对应的是分位数回归的损失函数，表达式为 \[L(y, f(x)) =\sum\limits_{y \geq f(x)}\theta|y - f(x)| + \sum\limits_{y &lt; f(x)}(1-\theta)|y - f(x)|\] 其中θ为分位数，需要我们在回归前指定。对应的负梯度误差为： \[r(y_i, f(x_i))= \begin{cases} \theta&amp; { y_i \geq f(x_i)}\\ \theta - 1 &amp; {y_i &lt; f(x_i) } \end{cases}\] 对于Huber损失和分位数损失，主要用于健壮回归，也就是减少异常点对损失函数的影响。 GBDT的正则化 和Adaboost一样，我们也需要对GBDT进行正则化，防止过拟合。GBDT的正则化主要有三种方式。 步长(learning rate) 第一种是和Adaboost类似的正则化项，即步长(learning rate)。定义为ν,对于前面的弱学习器的迭代 \[f_{k}(x) = f_{k-1}(x) + h_k(x)\] 如果我们加上了正则化项，则有 \[f_{k}(x) = f_{k-1}(x) + \nu h_k(x)\] ν的取值范围为0&lt;ν≤1。对于同样的训练集学习效果，较小的ν意味着我们需要更多的弱学习器的迭代次数。通常我们用步长和迭代最大次数一起来决定算法的拟合效果。 子采样 第二种正则化的方式是通过子采样比例（subsample）。取值为(0,1]。注意这里的子采样和随机森林不一样，随机森林使用的是放回抽样，而这里是不放回抽样。如果取值为1，则全部样本都使用，等于没有使用子采样。如果取值小于1，则只有一部分样本会去做GBDT的决策树拟合。选择小于1的比例可以减少方差，即防止过拟合，但是会增加样本拟合的偏差，因此取值不能太低。推荐在[0.5, 0.8]之间。 使用了子采样的GBDT有时也称作随机梯度提升树(Stochastic Gradient Boosting Tree, SGBT)。由于使用了子采样，程序可以通过采样分发到不同的任务去做boosting的迭代过程，最后形成新树，从而减少弱学习器难以并行学习的弱点。 正则化剪枝 针对于弱学习器（即CART回归树）进行正则化剪枝。就是决策树的正则化方法 GBDT的优点和局限性 优点 预测阶段的计算速度快， 树与树之间可并行化计算。 在分布稠密的数据集上， 泛化能力和表达能力都很好， 这使得GBDT在Kaggle的众多竞赛中， 经常名列榜首。 采用决策树作为弱分类器使得GBDT模型具有较好的解释性和鲁棒性，能够自动发现特征间的高阶关系， 并且也不需要对数据进行特殊的预处理如归一化等。 局限性 GBDT在高维稀疏的数据集上， 表现不如支持向量机或者神经网络。 GBDT在处理文本分类特征问题上， 相对其他模型的优势不如它在处理数值特征时明显。 训练过程需要串行训练， 只能在决策树内部采用一些局部并行的手段提高训练速度。 sklearn参数 在sacikit-learn中，GradientBoostingClassifier为GBDT的分类类， 而GradientBoostingRegressor为GBDT的回归类。两者的参数类型完全相同，当然有些参数比如损失函数loss的可选择项并不相同。 这些参数中，类似于Adaboost，我们把重要参数分为两类， - 第一类是Boosting框架的重要参数， - 第二类是弱学习器（即CART回归树）的重要参数。 下面我们就从这两个方面来介绍这些参数的使用。 ## GBDT类库boosting框架参数 由于GradientBoostingClassifier和GradientBoostingRegressor的参数绝大部分相同，我们下面会一起来讲，不同点会单独指出。 n_estimators: 也就是弱学习器的最大迭代次数，或者说最大的弱学习器的个数。一般来说n_estimators太小，容易欠拟合，n_estimators太大，又容易过拟合，一般选择一个适中的数值。 默认是100。在实际调参的过程中，我们常常将n_estimators和下面介绍的参数learning_rate一起考虑。 learning_rate: 即每个弱学习器的权重缩减系数ν，也称作步长，加上了正则化项，我们的强学习器的迭代公式为\(f_{k}(x) = f_{k-1}(x) + \nu h_k(x)\)。ν的取值范围为0&lt;ν≤1。对于同样的训练集拟合效果，较小的ν意味着我们需要更多的弱学习器的迭代次数。通常我们用步长和迭代最大次数一起来决定算法的拟合效果。 所以这两个参数n_estimators和learning_rate要一起调参。一般来说，可以从一个小一点的ν开始调参，默认是1。 subsample: 即我们在上文的正则化章节讲到的子采样，取值为(0,1]。注意这里的子采样和随机森林不一样，随机森林使用的是放回抽样，而这里是不放回抽样。如果取值为1，则全部样本都使用，等于没有使用子采样。如果取值小于1，则只有一部分样本会去做GBDT的决策树拟合。选择小于1的比例可以减少方差，即防止过拟合，但是会增加样本拟合的偏差，因此取值不能太低。 推荐在[0.5, 0.8]之间，默认是1.0，即不使用子采样。 init: 即我们的初始化的时候的弱学习器，拟合对应原理里面的f0(x)，如果不输入，则用训练集样本来做样本集的初始化分类回归预测。否则用init参数提供的学习器做初始化分类回归预测。一般用在我们对数据有先验知识，或者之前做过一些拟合的时候，如果没有的话就不用管这个参数了。 loss: 即我们GBDT算法中的损失函数。分类模型和回归模型的损失函数是不一样的。 对于分类模型，有对数似然损失函数&quot;deviance&quot;和指数损失函数&quot;exponential&quot;两者输入选择。默认是对数似然损失函数&quot;deviance&quot;。在原理篇中对这些分类损失函数有详细的介绍。一般来说，推荐使用默认的&quot;deviance&quot;。它对二元分离和多元分类各自都有比较好的优化。而指数损失函数等于把我们带到了Adaboost算法。 对于回归模型，有均方差&quot;ls&quot;, 绝对损失&quot;lad&quot;, Huber损失&quot;huber&quot;和分位数损失“quantile”。默认是均方差&quot;ls&quot;。一般来说，如果数据的噪音点不多，用默认的均方差&quot;ls&quot;比较好。如果是噪音点较多，则推荐用抗噪音的损失函数&quot;huber&quot;。而如果我们需要对训练集进行分段预测的时候，则采用“quantile”。 alpha：这个参数只有GradientBoostingRegressor有，当我们使用Huber损失&quot;huber&quot;和分位数损失“quantile”时，需要指定分位数的值。默认是0.9，如果噪音点较多，可以适当降低这个分位数的值。 GBDT类库弱学习器参数 由于GBDT使用了CART回归决策树，因此它的参数基本来源于决策树类，也就是说，和DecisionTreeClassifier和DecisionTreeRegressor的参数基本类似。 划分时考虑的最大特征数max_features: 可以使用很多种类型的值，默认是&quot;None&quot;,意味着划分时考虑所有的特征数；如果是&quot;log2&quot;意味着划分时最多考虑log2N个特征；如果是&quot;sqrt&quot;或者&quot;auto&quot;意味着划分时最多考虑N−−√个特征。如果是整数，代表考虑的特征绝对数。如果是浮点数，代表考虑特征百分比，即考虑（百分比xN）取整后的特征数。其中N为样本总特征数。 一般来说，如果样本特征数不多，比如小于50，我们用默认的&quot;None&quot;就可以了，如果特征数非常多，我们可以灵活使用刚才描述的其他取值来控制划分时考虑的最大特征数，以控制决策树的生成时间。 决策树最大深度max_depth: 默认可以不输入，如果不输入的话，默认值是3。一般来说，数据少或者特征少的时候可以不管这个值。如果模型样本量多，特征也多的情况下，推荐限制这个最大深度，具体的取值取决于数据的分布。 常用的可以取值10-100之间。 内部节点再划分所需最小样本数min_samples_split: 这个值限制了子树继续划分的条件，如果某节点的样本数少于min_samples_split，则不会继续再尝试选择最优特征来进行划分。 默认是2.如果样本量不大，不需要管这个值。如果样本量数量级非常大，则推荐增大这个值。 叶子节点最少样本数min_samples_leaf: 这个值限制了叶子节点最少的样本数，如果某叶子节点数目小于样本数，则会和兄弟节点一起被剪枝。 默认是1,可以输入最少的样本数的整数，或者最少样本数占样本总数的百分比。 如果样本量不大，不需要管这个值。如果样本量数量级非常大，则推荐增大这个值。 叶子节点最小的样本权重和min_weight_fraction_leaf：这个值限制了叶子节点所有样本权重和的最小值，如果小于这个值，则会和兄弟节点一起被剪枝。 默认是0，就是不考虑权重问题。一般来说，如果我们有较多样本有缺失值，或者分类树样本的分布类别偏差很大，就会引入样本权重，这时我们就要注意这个值了。 最大叶子节点数max_leaf_nodes: 通过限制最大叶子节点数，可以防止过拟合，默认是&quot;None”，即不限制最大的叶子节点数。如果加了限制，算法会建立在最大叶子节点数内最优的决策树。 如果特征不多，可以不考虑这个值，但是如果特征分成多的话，可以加以限制，具体的值可以通过交叉验证得到。 节点划分最小不纯度min_impurity_split: 这个值限制了决策树的增长，如果某节点的不纯度(基于基尼系数，均方差)小于这个阈值，则该节点不再生成子节点。即为叶子节点 。 一般不推荐改动默认值1e-7。 参考 《百面机器学习》 梯度提升树(GBDT)原理小结 scikit-learn 梯度提升树(GBDT)调参小结]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>sklearn</tag>
        <tag>机器学习</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[随机森林(Random Forest)算法梳理]]></title>
    <url>%2F2019%2F04%2F04%2F%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97%2F</url>
    <content type="text"><![CDATA[学习任务： 集成学习 什么是集成学习？ 集成学习的种类有哪些？ 集成学习的基本步骤：个体学习器的选择、训练、结合 bagging算法 随机森林思想 随机森林的推广 sklearn参数 集成学习 集成学习（ensemble learning）是机器学习中的一种思想，而不是指某一具体算法，它通过构建并结合多个学习器来完成学习任务。 集成学习通过将多个学习器进行结合，常可获得比单一学习器显著优越的泛化性能。 集成学习的种类 根据个体学习器的生成方式，目前的集成学习方法大致可分为两大类： 个体学习器问存在强依赖关系、必须串行生成的序列化方法，代表是 Boosting； 个体学习器间不存在强依赖关系、可同时生成的并行化方法，代表是 Bagging 和&quot;随机森林&quot; (Random Forest)。 Boosting 的基本思路是将基分类器层层叠加， 每一层在训练的时候， 对前一层基分类器中分错的样本， 给予更高的权重。 测试时， 根据各层分类器的结果的加权得到最终结果。（降低偏差） Bagging 方法更像是一个集体决策的过程， 每个个体都进行单独学习， 学习的内容可以相同， 也可以不同， 也可以部分重叠。 但由于个体之间存在差异性， 最终做出的判断不会完全一致。 在最终做决策时， 每个个体单独作出判断， 再通过投票的方式做出最后的集体决策。 （降低方差） 集成学习的基本步骤 集成学习一般可分为以下3个步骤。 找到误差互相独立的个体学习器。 这里可以选取ID3决策树作为基分类器。 事实上， 任何分类模型都可以作为基分类器， 但树形模型由于结构简单且较易产生随机性所以比较常用。 训练个体学习器。 在集成学习中需有效地生成多样性大的个体学习器。与简单地直接用初始数据训练出个体学习器相比，如何增强多样性呢?一般思路是在学习过程中引入随机性，常见做法主要是对数据样本、 输入属性、输出表示 、 算法参数进行扰动。 数据样本扰动：通常是基于采样法， 例如在 Bagging中使用自助采样(即有放回的采样)，在 AdaBoost 中使用序列采样. 输入属性扰动：从初始属性集中抽取出若干个属性子集，再基于每个属性子集训练一个基学习器。比如随机子空间 (random subspace)算法。 输出表示扰动：可对训练样本的类标记稍作变动，如&quot;翻转法&quot; (Flipping Output)随机改变一些训练样本的标记;也可对输出表示进行转化，如&quot;输出调制法&quot; (Output Smearing) 将分类输出转化为回归输出后构建个体学习器; 算法参数扰动：基学习算法一般都有参数需进行设置，例如神经网络的隐层神经元数、初始连接权值等。通过随机设置不同的参数，往往可产生差别较大的个体学习器. 合并个体学习器的结果。 常见的结合策略：平均法(averaging)，投票法(voting)，学习法(比如 stacking) averaging 常用于数值型输出。有简单平均法、加权平均法等。 voting 是用投票的方式， 将获得最多选票的结果作为最终的结果。常用于分类任务。 stacking 是用串行的方式， 把前一个基分类器的结果输出到下一个分类器， 将所有基分类器的输出结果相加（或者用更复杂的算法融合） 作为最终的输出。 Bagging算法 采样，训练 在Bootstrap(有放回抽样)的基础上可以构造出Bagging（Bootstrap Aggregating）算法。这种方法对训练样本集进行多次Bootstrap抽样，用每次抽样形成的数据集训练一个弱学习器模型，得到多个独立的弱学习器（对于分类问题，称为弱分类器），最后用它们的组合进行预测。 结合策略 在对预测输出进行结合时， Bagging 通常对分类任务使用简单投票法，对回归任务使用简单平均法. 若分类预测时出现两个类收到同样票数的情形，则最简单的做法是随机选择一个，也可进一步考察学习器投票的置信度来确定最终胜者. 算法特点 假定基学习器的计算复杂度为 O(m) ， 则 Bagging 的复杂度大致为\(T(O(m) + O (s))\) ，考虑到采样与投票/平均过程的复杂度 \(O(s)\) 很小，而\(T\)通常是一个不太大的常数，因此，训练一个 Bagging 集成与直接使用基学习算法训练一个学习器的复杂度同阶，这说明 Bagging 是一个很高效的集成学习算法. 因为Boostrap采样过程，每个基学习器只使用了初始训练集中约 63.2% 的样本，那么剩下约 36.8% 的样本可用作验证集来对泛化性能进行&quot;包外估计&quot; (out-oιbag estimate) 从偏差方差分解的角度看， Bagging 主要关注降低方差，因此它在不剪枝 决策树、神经网络等易受样本扰动的学习器上效用更为明显. 随机森林思想 随机森林(Random Forest，简称RF)是 Bagging 的一个扩展变体. RF 在以决策树为基学习器构建 Bagging 集成的基础上，进一步在决策树的训练过程中引入了随机属性选择. (数据样本扰动 + 输入属性扰动) 传统决策树在选择划分属性时是在当前结点的属性集合(假定有 d 个属性)中选择一个最优属性; 而在RF 中，对基决策树的每个结点，先从该结点的属性集合中随机选择一个包含 k 个属性的子集，然后再从这个子集中选择一个最优属性用于划分. 这里的参数 k 控制了随机性的引入程度： 若令 \(k = d\) ， 则基决策树的构建与传统决策树相同; 若令 \(k = 1\) ， 则是随机选择一个属性用于划分 ; 一般情况下，推荐值 \(k = log_{2}d\) 特点 随机森林简单、容易实现、计算开销小，令人惊奇的是，它在很多现实任务中展现出强大的性能。 随机森林的训练效率常优于 Bagging。 因为在个体决策树的构建过程中，Bagging使用的是 &quot;确定型&quot; 决策树，在选择划分属性时要对结点的所有属性进行考察，而随机森林使用的&quot;随机型&quot;决策树则只需考察一个属性子集。 由于可以随机选择决策树节点划分特征，这样在样本特征维度很高的时候，仍然能高效的训练模型。 在训练后，可以给出各个特征对于输出的重要性。 缺点 在某些噪音比较大的样本集上，RF模型容易陷入过拟合。 随机森林的推广 基于RF，有很多变种算法，应用也很广泛，不光可以用于分类回归，还可以用于特征转换，异常点检测等。 sklearn参数 RF的分类器是RandomForestClassifier，回归器是RandomForestRegressor。RF需要调的参数包括两部分，第一部分是Bagging框架的参数，第二部分是CART决策树的参数。 1234567891011class sklearn.ensemble.RandomForestClassifier( n_estimators=’warn’, criterion=’gini’, max_depth=None, min_samples_split=2, min_samples_leaf=1, min_weight_fraction_leaf=0.0, max_features=’auto’, max_leaf_nodes=None, min_impurity_decrease=0.0, min_impurity_split=None, bootstrap=True, oob_score=False, n_jobs=None, random_state=None, verbose=0, warm_start=False, class_weight=None) Bagging框架的参数解释 n_estimators：弱学习器的最大迭代次数，或者说最大的弱学习器的个数。 一般来说n_estimators太小，容易过拟合，太大又容易欠拟合，一般选择一个适中的数值。默认是100.实际调参的过程中，我们常常将n_estimators和下面介绍的参数learning_rate一起考虑。 oob_score：即是否采用袋外样本来评估模型的好坏。默认设置False。个人推荐设置为True，因为袋外分数反应了一个模型拟合后的泛化能力。 criterion：即CART决策树做划分时对特征的评价标准。分类模型和回归模型的损失函数不一样。 分类RF对应的CART分类树默认是基尼系数，另一个可选择的标准是信息增益。 回归RF对应的CART回归树默认是均方差mse，另一个可以选择的标准时绝对值mae。 一般来说选择默认的标准就已经很好了。 RF重要的框架参数比较少，主要关注的是n_estimators，即RF最大的决策树个数。 RF决策树参数 RF的决策树参数，它要调参的参数基本和GBDT相同，如下: max_features:RF划分时考虑的最大特征，可以使用很多种类型的值. 默认是&quot;auto&quot;，意味着划分时最多考虑 \(\sqrt{N}\) 个特征； 如果是&quot;log2&quot;意味着划分时最多考虑 \(log_{2}N\) 个特征； 如果是&quot;sqrt&quot;或者&quot;auto&quot;意味着划分时最多可考虑 \(\sqrt{N}\) 个特征。 如果是整数，代表考虑的特征绝对数。 如果是浮点数，代表考虑特征百分比，即考虑（百分比xN）取整后的特征数。 其中N为样本总特征数。 一般我们默认的&quot;auto&quot;就可以了，如果特征数非常多，我们可以灵活使用刚才描述的其他取值来控制划分时考虑的最大特征数，以控制决策树的生成时间。 max_depth: 决策树最大深度。默认可以不输入，如果不输入的话，决策树在建立子树的时候不会限制子树的深度。 一般来说，数据少或者特征少的时候可以不管这个值。 如果模型样本量多，特征也多的情况下，推荐限制这个最大深度，具体的取值取决于数据的分布。常用的可以取值10-100之间。 min_samples_split: 内部节点再划分所需最小样本数。这个值限制了子树继续划分的条件，如果某节点的样本数少于min_samples_split，则不会继续再尝试选择最优特征来进行划分。 默认是2.如果样本量不大，不需要管这个值。如果样本量数量级非常大，则推荐增大这个值。 min_samples_leaf: 叶子节点最少样本数。这个值限制了叶子节点最少的样本数，如果某叶子节点数目小于样本数，则会和兄弟节点一起被剪枝。 默认是1,可以输入最少的样本数的整数，或者最少样本数占样本总数的百分比。如果样本量不大，不需要管这个值。如果样本量数量级非常大，则推荐增大这个值。 min_weight_fraction_leaf：叶子节点最小的样本权重和。这个值限制了叶子节点所有样本权重和的最小值，如果小于这个值，则会和兄弟节点一起被剪枝。 默认是0，就是不考虑权重问题。一般来说，如果我们有较多样本有缺失值，或者分类树样本的分布类别偏差很大，就会引入样本权重，这时我们就要注意这个值了。 max_leaf_nodes: 最大叶子节点数。通过限制最大叶子节点数，可以防止过拟合，默认是&quot;None”，即不限制最大的叶子节点数。如果加了限制，算法会建立在最大叶子节点数内最优的决策树。如果特征不多，可以不考虑这个值，但是如果特征很多的话，可以加以限制，具体的值可以通过交叉验证得到。 min_impurity_split: 节点划分最小不纯度。这个值限制了决策树的增长，如果某节点的不纯度(基于基尼系数，均方差)小于这个阈值，则该节点不再生成子节点。即为叶子节点 。一般不推荐改动默认值1e-7。 上面决策树参数中最重要的包括最大特征数 max_features， 最大深度 max_depth， 内部节点再划分所需最小样本数min_samples_split 和叶子节点最少样本数 min_samples_leaf。 参考 《机器学习》周志华 《百面机器学习》诸葛越 随机森林概述 by SIGAI 随机森林算法介绍(理论) scikit-learn随机森林调参小结]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>sklearn</tag>
        <tag>机器学习</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pandas 处理时间类型数据]]></title>
    <url>%2F2019%2F04%2F01%2Fpandas%E5%A4%84%E7%90%86%E6%97%B6%E9%97%B4%E5%92%8C%E6%97%A5%E6%9C%9F%E7%B1%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[学习目标： - 时间序列数据导入，并转为时间类型 - 导入一个时间相关的数据集 123456import numpy as npimport pandas as pd## importing a dataseturl="http://mlr.cs.umass.edu/ml/machine-learning-databases/event-detection/CalIt2.data"data = pd.read_csv(url, header = None) 查看数据的属性 12345678910111213&gt;&gt;&gt; data.head(3) 0 1 2 30 7 07/24/05 00:00:00 01 9 07/24/05 00:00:00 02 7 07/24/05 00:30:00 1## 查看所有列的数据类型&gt;&gt;&gt; data.dtypes0 int641 object2 object3 int64dtype: object 可以看出来第1列和第2列包含时间时间序列数据，但却是object类型，我们可以转换成时间类型。 ## 数据类型转化(object → datetime) 12345678910&gt;&gt;&gt; data[1] = pd.to_datetime(data[1])&gt;&gt;&gt; data[2] = pd.to_datetime(data[2])&gt;&gt;&gt; data.dtypes0 int641 datetime64[ns]2 datetime64[ns]3 int64dtype: object 查看datetime类型数据 查看这个数据集中的时间数据中包含了哪些年、月、日等。 123456789&gt;&gt;&gt; data[1].dt.year.unique()array([2005], dtype=int64)&gt;&gt;&gt; data[1].dt.month.unique()array([ 7, 8, 9, 10, 11], dtype=int64)&gt;&gt;&gt; data[1].dt.day.unique()array([24, 25, 26, 27, 28, 29, 30, 31, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23], dtype=int64) 查看某月的数据有多少 12&gt;&gt;&gt; data[data[1].dt.month == 10].shape(2976, 4) 查看两个时间相差多久 12&gt;&gt;&gt; data.loc[6624,1] - data.loc[0,1]Timedelta('69 days 00:00:00') 第1行和第6624行的数据相差69天，结果是个Timedelta数据类型。 参考：Working with Dates and timedelta in Pandas]]></content>
      <categories>
        <category>数据分析</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>pandas</tag>
        <tag>时间序列</tag>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模型评估指标]]></title>
    <url>%2F2019%2F03%2F21%2F%E6%A8%A1%E5%9E%8B%E9%AA%8C%E8%AF%81%2F</url>
    <content type="text"><![CDATA[先加载数据 12345678910111213# Data Loadingimport pandas as pd# Load datamelbourne_file_path = '../input/melbourne-housing-snapshot/melb_data.csv'melbourne_data = pd.read_csv(melbourne_file_path) # Filter rows with missing price valuesfiltered_melbourne_data = melbourne_data.dropna(axis=0)# Choose target and featuresy = filtered_melbourne_data.Pricemelbourne_features = ['Rooms', 'Bathroom', 'Landsize', 'BuildingArea', 'YearBuilt', 'Lattitude', 'Longtitude']X = filtered_melbourne_data[melbourne_features] 回归模型评价指标MSE、RMSE、MAE、R-Squared 均方误差(MAE) MSE （Mean Squared Error）叫做均方误差。看公式 \[ \frac{1}{m}\sum _ { i=1 }^m (y_ i-\hat{y_i})^2\] 参考 Model Validation]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[决策树(Decision trees)]]></title>
    <url>%2F2019%2F03%2F18%2F%E5%86%B3%E7%AD%96%E6%A0%91%2F</url>
    <content type="text"><![CDATA[决策树模型核心是下面几部分： 结点和有向边组成 结点有内部结点和叶结点俩种类型 内部结点表示一个特征，叶节点表示一个类 决策树的判定过程就相当于树中从根结点到某一个叶子结点的遍历。每一步如何遍历是由数据各个特征的具体特征属性决定。 构建决策树 所谓决策树的构造，就是进行属性选择度量，确定各个特征属性之间的拓扑结构。 属性选择度量是一种选择分裂准则，是将给定的类标记的训练集合的数据划分D“最好”地分成个体类的启发式方法，它决定了拓扑结构及分裂点split_point的选择。 属性选择度量算法有很多，一般使用自顶向下递归分治法，并采用不回溯的贪心策略。 分裂属性 构造决策树的关键步骤是分裂属性。 分裂属性分为三种不同的情况： 属性是离散值且不要求生成二叉决策树。此时用属性的每一个划分作为一个分支。 属性是离散值且要求生成二叉决策树。此时使用属性划分的一个子集进行测试，按照“属于此子集”和“不属于此子集”分成两个分支。 属性是连续值。此时确定一个值作为分裂点split_point，按照&gt;split_point和&lt;=split_point生成两个分支。 分裂属性：在某个节点处按照某一特征属性的不同划分构造不同的分支，其目标是让各个分裂子集尽可能地“纯”。尽可能“纯”就是尽量让一个分裂子集中待分类项属于同一类别。 判断“纯”的方法不同引出了我们的ID3算法，C4.5算法以及CART算法。 ID3算法 在信息论中，期望信息越小，信息增益越大，从而纯度越高。 ID3算法的核心思想就是以信息增益来度量属性选择，选择分裂后信息增益最大的属性进行分裂。 下面先定义几个要用到的概念。 设 D 为用类别对训练元组进行的划分，则 D 的熵（entropy）表示为： \[ i n f o(D)=-\sum_{i=1}^{m} p_{i} \log _{2}\left(p_{i}\right) \] 其中 \(p_i\) 表示第 \(i\) 个类别在整个训练元组中出现的概率，可以用\(\frac{属于此类别元素的数量} {训练元组元素总数量}\) 作为估计。熵的实际意义表示是 D 中元组的类标号所需要的平均信息量。 现在我们假设将训练元组 D 按属性 A 进行划分，则 A 对 D 划分的期望信息为： \[ i n f o_{A}(D)=\sum_{j=1}^{v} \frac{\left|D_{j}\right|}{|D|} \text i n f o\left(D_{j}\right) \] 而信息增益即为两者的差值： \[ \operatorname{gain}(A)=i n f o(D)-i n f o_{A}(D) \] ID3算法就是在每次需要分裂时，计算每个属性的增益率，然后选择增益率最大的属性进行分裂。 C4.5算法 ID3算法存在一个问题，就是偏向于多值属性，例如，如果存在唯一标识属性ID，则ID3会选择它作为分裂属性，这样虽然使得划分充分纯净，但这种划分对分类几乎毫无用处。ID3的后继算法C4.5使用增益率（gain ratio）的信息增益扩充，试图克服这个偏倚。 CART算法 CART(Classification And Regression Tree)分类回归树算法采用一种二分递归分割的技术，将当前的样本集分为两个子样本集，使得生成的url子节点都有两个分支。因此，CART算法生成的决策树是结构简洁的二叉树。 由于CART算法构成的是一个二叉树，它在每一步的决策时只能是“是”或者“否”，即使一个feature有多个取值，也是把数据分为两部分。在CART算法中主要分为两个步骤: 将样本递归划分进行建树过程 用验证数据进行剪枝 划分建树 设 \(x_{1}, x_{2}, \dots, x_{n}\) 代表单个样本的 \(n\) 个属性，\(y\) 表示所属类别。CART算法通过递归的方式将维的空间划分为不重叠的矩形。划分步骤大致如下: 选一个自变量 \(x_i\)，再选取 \(x_i\) 的一个值 \(v_i\)， \(v_i\)把 n 维空间划分为两部分，一部分的所有点都满足 \(x_{i} \leq v_{i}\)，另一部分的所有点都满足 \(x_{i} &gt; v_{i}\)，对非连续变量来说属性值的取值只有两个，即等于该值或不等于该值。 递归处理，将上面得到的两部分按步骤1 重新选取一个属性继续划分，直到把整个维空间都划分完。 在划分时候有一个问题，它是按照什么标准来划分的 ？ 对于一个变量属性来说，它的划分点是一对连续变量属性值的中点。假设 m 个样本的集合一个属性有 m 个连续的值，那么则会有 m-1 个分裂点，每个分裂点为相邻两个连续值的均值。每个属性的划分按照能减少的杂质的量来进行排序，而杂质的减少量定义为划分前的杂质减去划分后的每个节点的杂质量划分所占比率之和。而杂质度量方法常用Gini指标，假设一个样本共有 \(C\) 类，那么一个节点 \(A\) 的Gini不纯度可定义为 \[ \operatorname{Gini}(A)=1-\sum_{i=1}^{C} p_{i}^{2} \] 其中 \(p_i\) 表示属于 \(i\) 类的概率，当 Gini(A)=0 时，所有样本属于同类，所有类在节点中以等概率出现时，Gini(A) 最大化，此时 \(C(C-1)/2\) 。 有了上述理论基础，实际的递归划分过程是这样的：如果当前节点的所有样本都不属于同一类或者只剩下一个样本，那么此节点为非叶子节点，所以会尝试样本的每个属性以及每个属性对应的分裂点，尝试找到杂质变量最大的一个划分，该属性划分的子树即为最优分支。 剪枝 建树完成后，可以根据验证数据进行剪枝。在CART树的建树过程中，可能存在Overfitting，许多分支中反映的是数据中的异常，这样的决策树对分类的准确性不高，那么需要检测并减去这些不可靠的分支。 决策树常用的剪枝有事前剪枝和事后剪枝，CART算法采用事后剪枝，具体方法为代价复杂性剪枝法。可参考如下链接 剪枝参考：http://www.cnblogs.com/zhangchaoyang/articles/2709922.html 参考 算法杂货铺——分类算法之决策树(Decision tree) 决策树之CART算法]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[梯度下降(gradient boosting)]]></title>
    <url>%2F2019%2F03%2F18%2F%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>python</tag>
        <tag>梯度下降</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[回溯算法]]></title>
    <url>%2F2019%2F03%2F16%2Fpython-leetcode-backtracking%2F</url>
    <content type="text"><![CDATA[回溯法是暴力搜索法中的一种。 对于某些计算问题而言，回溯法是一种可以找出所有解的一般性算法，尤其适用于约束满足问题。回溯法采用试错的思想，它尝试分步的去解决一个问题。 在分步解决问题的过程中，当它通过尝试发现现有的分步答案不能得到有效的正确的解答的时候，它将取消上一步甚至是上几步的计算，再通过其它的可能的分步解答再次尝试寻找问题的答案。回溯法通常用最简单的递归方法来实现，在反复重复上述的步骤后可能出现两种情况： 找到一个可能存在的正确的答案 在尝试了所有可能的分步方法后宣告该问题没有答案 回溯算法的基本形式是“递归+循环”，正因为循环中嵌套着递归，递归中包含循环，这才使得回溯比一般的递归和单纯的循环更难理解。 学习目标： 利用回溯算法求解八皇后问题 leetcode 51. N皇后 leetcode 52. N皇后 II 利用回溯算法求解 0-1 背包问题 Leetcode 78. 子集 Leetcode 17. 电话号码的字母组合 单词搜索 八皇后问题 有一个棋盘和8个要放到上面的皇后。唯一的要求是皇后之间不能形成威胁。（必须把它们放置成每个皇后都不能吃掉其他皇后的状态）皇后要如何放置呢？ 假设不只是8个，而是有任意数目的皇后，怎么解决？ 方法：回溯 + 生成器 这是一个典型的回溯问题。首先尝试在第一行放置第1个皇后，然后第二行放置第2个，依次类推。 如果发现不能放置下一个皇后，就回溯到上一步，试着将皇后放到其他的位置。最后，或者尝试完所有的可能，或者找到解决方案。 状态表示 元组表示：每个元组中的元素都指示相应行的皇后的列的位置信息。 比如 state[0] == 3 就是第一行的皇后在第4列。 寻找冲突 定义一个 conflict 函数，传入已知的皇后位置，判断下一个皇后可能的位置是否与它们有冲突。 冲突指的是水平位置(即列数)相同，或者对角线位置相同(即行数之差==列数之差)。 基本情况：最后一个皇后该怎么做？ 已知其他行皇后的位置(相互间没有冲突)，遍历这一行的每一列，返回没有冲突发生的位置。 需要递归的情况 同样已知底层的所有行皇后位置(相互间没有冲突)，判断当前行的这一列没有冲突，则加入包含位置信息的元组中，递归传到下一层，下一层返回它的所有正确位置，加入到当前层的位置信息中。 打包 清理输出。将输出处理得更容易理解一点。 1234567891011121314151617181920212223242526272829303132333435363738394041def conflict(state, nextX): #nextX是当前列数 nextY = len(state) # 当前行数 for i in range(nextY):# 遍历之前所有行 if abs(state[i]-nextX) in (0, nextY-i): return True # 同一列或同一对角线上，就冲突 return False#生成器def queens(num=8, state=()): for pos in range(num):#遍历所有列 if not conflict(state,pos): #如果这一列不冲突 if len(state) == num-1:#到了最后一个皇后 yield (pos,) else:#递归 for result in queens(num,state+(pos,)):#加上当前层的正确列数pos去下一层 #result就是递归的下一层返回来的一个列结果 yield (pos,) + result # 当前层应该返回的结果# 生成器给出所有解决方案print(list(queens(3))) # []print(list(queens(4))) # [(1, 3, 0, 2), (2, 0, 3, 1)]# 8个皇后有多少种解决方案：print(len(list(queens(8)))) # 92# 打包：更形象得随机输出解决方案def prettyprint(solution): def line(pos,length=len(solution)): # 对于每一行pos return '. '*pos + 'X ' + '. '*(length-pos-1) for pos in solution:# 对于每一行pos print(line(pos)) import randomprettyprint(random.choice(list(queens(8))))#输出：#. . . . . . X . #X . . . . . . . #. . X . . . . . #. . . . . . . X #. . . . . X . . #. . . X . . . . #. X . . . . . . #. . . . X . . . Leetcode 78. 子集 给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。 说明：解集不能包含重复的子集。 示例: 123456789101112输入: nums = [1,2,3]输出:[ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], []] 方法：回溯，递归，dfs 深度优先算法回溯：以【1,2,3】为例 每轮都传递一个数组起始指针的值，保证遍历顺序： 第一轮：先遍历以1 开头的所有子集，1→12→123 →13 第二轮：遍历以2开头的所有子集，2→23 第三轮:遍历以3开头的所有子集，3 这样三轮遍历保证能找到全部1开头，2开头，3开头的所有子集；同时，每轮遍历后又把上轮的头元素去掉，这样不会出现重复子集。（包括空集） 1234567891011class Solution: def subsets(self, nums: List[int]) -&gt; List[List[int]]: res = [] nums.sort() def dfs(nums, index, path, res): res.append(path) for i in range(index, len(nums)): dfs(nums, i+1, path+[nums[i]], res) dfs(nums, 0, [],res) return res 方法：组合，非递归 ① 最外层循环逐一从 nums 数组中取出每个元素 num ② 内层循环从原来的结果集中取出每个中间结果集，并向每个中间结果集中添加该 num 元素 ③往每个中间结果集中加入 num ④将新的中间结果集加入结果集中 123456789class Solution: def subsets(self, nums: List[int]) -&gt; List[List[int]]: res = [[]] for num in nums: for temp in res[:]: x = temp[:] x.append(num) res.append(x) return res 相比前一种方法，这个更快 Leetcode 17. 电话号码的字母组合 给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。 给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。 示例: 12输入：&quot;23&quot;输出：[&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;]. 方法：dfs穷举 12345678910111213141516171819202122232425class Solution: def letterCombinations(self, digits: str) -&gt; List[str]: dict = &#123;'2':['a','b','c'], '3':['d','e','f'], '4':['g','h','i'], '5':['j','k','l'], '6':['m','n','o'], '7':['p','q','r','s'], '8':['t','u','v'], '9':['w','x','y','z'] &#125; res = [] length = len(digits) def dfs(index, path, res): if index == length: res.append(path) return for letter in dict[digits[index]]: dfs(index+1, path+letter, res) if length == 0: return [] dfs(0, '', res) return res 79. 单词搜索 给定一个二维网格和一个单词，找出该单词是否存在于网格中。 单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。 示例: 12345678910board =[ [&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;E&apos;], [&apos;S&apos;,&apos;F&apos;,&apos;C&apos;,&apos;S&apos;], [&apos;A&apos;,&apos;D&apos;,&apos;E&apos;,&apos;E&apos;]]给定 word = &quot;ABCCED&quot;, 返回 true.给定 word = &quot;SEE&quot;, 返回 true.给定 word = &quot;ABCB&quot;, 返回 false. 方法：回溯 这个题的回溯的起点可以是二维数组的任意位置。 回溯法的判定条件比较简单，需要注意的是把已经走过的路给改变了，不能再走了。python中通过swapcase()交换该字母的大小写即可行。 123456789101112131415161718192021222324class Solution: def exist(self, board: List[List[str]], word: str) -&gt; bool: for x in range(len(board)): for y in range(len(board[0])): if self.existword(board, word, x, y, 0): return True return False def existword(self, board, word, x, y, i): if i==len(word): #从第0个开始，word的每个字母都遍历到了 return True if x&lt;0 or x&gt;=len(board) or y&lt;0 or y&gt;=len(board[0]): return False if board[x][y] != word[i]: return False #该字母存在后，变小写，递归上下左右 board[x][y] = board[x][y].swapcase() isexist = (self.existword(board, word, x+1, y, i+1) or self.existword(board, word, x, y+1, i+1) or self.existword(board, word, x-1, y, i+1) or self.existword(board, word, x, y-1, i+1)) board[x][y] = board[x][y].swapcase() #变换回来大写 return isexist 参考 leetcode 78. Subsets-数组子集|回溯算法]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>LeetCode</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python 魔法方法]]></title>
    <url>%2F2019%2F03%2F14%2Fpython-magic%2F</url>
    <content type="text"><![CDATA[Python 中有的方法的名称前后都有两个下划线，这些方法被称为魔法方法。如果对象实现了这些方法中的某一个，那么这个方法就会在特殊的情况下被 Python 所调用，而这一切都是自动发生的。 这里总结一些重要的魔法方法： - 构造方法 __init__ , __new__ 构造方法 __init__ 在定义类的时候，会去定义构造方法。当一个对象被创造后，会立即调用构造方法，定义这个对象的初始值。 12345678class FooBar: def __init__(self,s=8): self.var = 40 self.some = sf = FooBar(9)print(f.var) # 40print(f.some) # 9 可以给构造函数传几个参数。 __new__ 这个方法我们一般很少定义，不过我们在一些开源框架中偶尔会遇到定义这个方法的类。实际上，这才是“真正的构造方法”，它会在对象实例化时第一个被调用，然后再调用__init__，它们的区别主要如下： __new__的第一个参数是clsxz，而__init__的第一个参数是self __new__返回值是一个实例，而__init__没有任何返回值，只做初始化操作 __new__由于是返回一个实例对象，所以它可以给所有实例进行统一的初始化操作 由于 __new__ 优先于 __init__ 调用，且返回一个实例。 看下面例子： 123456789101112131415class Person(object): def __new__(cls, *args, **kwargs): print("in __new__") instance = object.__new__(cls) return instance def __init__(self, name, age): print("in __init__") self._name = name self._age = agep = Person("Wang", 33)#输出：#in __new__#in __init__ 可以每次返回同一个实例来实现一个单例类： 123456789101112131415class Singleton(object): _instance = None def __new__(cls, *args, **kwargs): if cls._instance is None: cls._instance = object.__new__(cls, *args, **kwargs) return cls._instances1 = Singleton()s2 = Singleton()print(s1)print(s2) #输出：# &lt;__main__.Singleton object at 0x000001AEC9403400&gt;# &lt;__main__.Singleton object at 0x000001AEC9403400&gt; 可以看到s1和s2都指向同一个对象，实现了单例模式。 再来看下工厂模式的实现 12345678910111213141516171819202122232425262728293031323334353637383940class Fruit(object): def __init__(self): pass def print_color(self): passclass Apple(Fruit): def __init__(self): pass def print_color(self): print("apple is in red")class Orange(Fruit): def __init__(self): pass def print_color(self): print("orange is in orange")class FruitFactory(object): fruits = &#123;"apple": Apple, "orange": Orange&#125; def __new__(cls, name): if name in cls.fruits.keys(): return cls.fruits[name]() else: return Fruit()fruit1 = FruitFactory("apple")fruit2 = FruitFactory("orange")fruit1.print_color() fruit2.print_color() fruit3 = FruitFactory("banana")print(fruit2)print(fruit3)# 输出：# apple is in red# orange is in orange# &lt;__main__.Orange object at 0x000001AEC940F2E8&gt;# &lt;__main__.Fruit object at 0x000001AEC94277F0&gt; 另外一种使用场景是当你需要继承内置类时，例如int、str、tuple，只能通过__new__来达到初始化数据的效果： 12345678class g(float): """千克转克""" def __new__(cls, kg): return float.__new__(cls, kg * 2)# 50千克转为克a = g(50)print(a) # 100.0print(a + 100) # 200.0, 由于继承了float，所以可以直接运算，非常方便！ __del__ 这是析构方法，也就是在对象被垃圾回收之前被调用。 自定义序列和映射 序列和映射是对象的集合。为了实现它们的基本行为，如果对象是不可变的，就需要使用 __len__ 和 __getitem__ 两个魔法方法，如果是可变的，则还需要使用 __setitem__ 和 __delitem__ 。 __len__(self) 返回容器的长度，可变和不可变类型都需要实现。 __getitem__(self, key) 定义对容器中某一项使用 self[key] 的方式进行读取操作时的行为。这也是可变和不可变容器类型都需要实现的一个方法。它应该在键的类型错误式产生 TypeError 异常，同时在没有与键值相匹配的内容时产生 KeyError 异常。 __setitem__(self, key) 定义对容器中某一项使用 self[key] 的方式进行赋值操作时的行为。它是可变容器类型必须实现的一个方法，同样应该在合适的时候产生 KeyError 和 TypeError 异常。 __delitem__(self, key) 这个方法在对一部分对象使用 del 语句时被调用，同时必须删除和键相关的键。 访问控制 __str__ 当被 str() 调用时会执行__str__。此方法类似JAVA中的toString方法。 1234567891011121314151617class A: def __init__(self,name): self.name = nameclass B: def __init__(self,name): self.name = name def __str__(self):#重写__str__方法 return self.namea = A("Tom")print(a)b = B("Jake")print(b)#输出：#&lt;__main__.A object at 0x000001AEC9447198&gt;#Jake 迭代器 __iter__ 该方法会返回一个迭代器。 迭代器是具有next方法的对象。在调用next方法时，会返回迭代器的下一个值。 除了在迭代器和可迭代对象上进行迭代外，还能把他们转换为序列。 下面的例子是用list构造方法显示地将迭代器转化为列表。 12 生成器 参考 Python面试之理解__new__和__init__的区别]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python实现数据结构之图]]></title>
    <url>%2F2019%2F03%2F10%2Fpython-algo-graph%2F</url>
    <content type="text"><![CDATA[学习目标： 实现有向图、无向图、有权图、无权图的邻接矩阵和邻接表表示方法 实现图的深度优先搜索、广度优先搜索、A* 算法 leetCode36.有效的数独 leetCode200.岛屿的数量 实现一个邻接表表示的有向带权图 每个顶点的所有邻接点和对应的边的权重用字典表示。 对于无权图，可以只将顶点的所有邻接点放入 list 中即可。 图的所有顶点名称及对应的顶点对象用字典表示。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364class Vertex:#顶点 def __init__(self,key): self.id = key self.connectedTo = &#123;&#125; #邻接点，及相应的权重 def addNeighbor(self, nbr, weight=0): self.connectedTo[nbr] = weight def __str__(self): return str(self.id) + ' connectedTo: '+str([x.id for x in self.connectedTo]) def getConnections(self): #多有邻接点 return self.connectedTo.keys() def getId(self): return self.id def getWeight(self,nbr): return self.connectedTo[nbr] class Graph: # 邻接表表示的有向带权图 def __init__(self): self.vertList = &#123;&#125; # 所有顶点 self.numVertices = 0 def addVertex(self, key): #添加顶点 self.numVertices += 1 newVertex = Vertex(key) self.vertList[key] = newVertex return newVertex def getVertex(self, n): if n in self.vertList: return self.vertList[n] else: return None def __contains__(self,n): return n in self.vertList def addEdge(self,f,t,cost=0): #添加边 if f not in self.vertList: self.addVertex(f) if t not in self.vertList: self.addVertex(t) self.vertList[f].addNeighbor(self.vertList[t], cost) def getVertices(self): return self.vertList.keys() def __iter__(self): return iter(self.vertList.values()) g = Graph()for i in range(6): g.addVertex(i)print(g.getVertex(3))print(g.vertList)print(3 in g)g.addEdge(0,1,5)g.addEdge(0,5,2)g.addEdge(1,2,4)g.addEdge(2,3,9)g.addEdge(3,4,7)g.addEdge(3,5,3)g.addEdge(4,0,1)g.addEdge(5,4,8)g.addEdge(5,2,1)print(g.getVertices())for v in g: for w in v.getConnections(): print('(%s,%s)'%(v.getId(), w.getId())) 输出： 123456789101112133 connectedTo: []&#123;0: &lt;__main__.Vertex object at 0x000001AEC9423B70&gt;, 1: &lt;__main__.Vertex object at 0x000001AEC903F748&gt;, 2: &lt;__main__.Vertex object at 0x000001AEC85F8CC0&gt;, 3: &lt;__main__.Vertex object at 0x000001AEC9415FD0&gt;, 4: &lt;__main__.Vertex object at 0x000001AEC9415EF0&gt;, 5: &lt;__main__.Vertex object at 0x000001AEC9415B70&gt;&#125;Truedict_keys([0, 1, 2, 3, 4, 5])(0,1)(0,5)(1,2)(2,3)(3,4)(3,5)(4,0)(5,4)(5,2) 图的遍历 遍历图最常用的有两种方式，就是你常听到的 BFS 和 DFS. BFS: Breadth First Search，广度优先搜索 DFS: Depdth First Search，深度优先搜索 BFS BFS 类似于树的层序遍历，从第一个节点开始，先访问离 A 最近的点，接着访问次近的点。 123456789101112131415161718192021222324252627282930313233343536373839404142from collections import dequeGRAPH = &#123; # 邻接表表示的无向无权图 'A': ['B', 'F'], 'B': ['C', 'I', 'G'], 'C': ['B', 'I', 'D'], 'D': ['C', 'I', 'G', 'H', 'E'], 'E': ['D', 'H', 'F'], 'F': ['A', 'G', 'E'], 'G': ['B', 'F', 'H', 'D'], 'H': ['G', 'D', 'E'], 'I': ['B', 'C', 'D'],&#125;class Queue(object): # 队列辅助 def __init__(self): self._deque = deque() def push(self, value): return self._deque.append(value) def pop(self): return self._deque.popleft() def __len__(self): return len(self._deque)def bfs(graph, start): search_queue = Queue() search_queue.push(start)# 起点先入队 searched = set() # 已经访问过的结点 while search_queue: # 队列不为空就继续 cur_node = search_queue.pop() # 出队 if cur_node not in searched: # 若是未访问的结点 yield cur_node # 读出 searched.add(cur_node) # 添加到记录中 for node in graph[cur_node]: # 所有邻接点 search_queue.push(node)# 起点的所有邻接点入队print([i for i in bfs(GRAPH, 'A')]) 输出 1[&apos;A&apos;, &apos;B&apos;, &apos;F&apos;, &apos;C&apos;, &apos;I&apos;, &apos;G&apos;, &apos;E&apos;, &apos;D&apos;, &apos;H&apos;] DFS 深度优先搜索(DFS)是每遇到一个节点，如果没有被访问过，就直接去访问它的邻居节点，不断加深。 12345678910111213141516171819202122232425GRAPH = &#123; #邻接表表示的无向无权图 'A': ['B', 'F'], 'B': ['C', 'I', 'G'], 'C': ['B', 'I', 'D'], 'D': ['C', 'I', 'G', 'H', 'E'], 'E': ['D', 'H', 'F'], 'F': ['A', 'G', 'E'], 'G': ['B', 'F', 'H', 'D'], 'H': ['G', 'D', 'E'], 'I': ['B', 'C', 'D'],&#125;DFS_SEARCHED = set()def dfs(graph, start): if start not in DFS_SEARCHED: # 若是未访问的结点 print(start) DFS_SEARCHED.add(start) for node in graph[start]: # 所有邻接点 if node not in DFS_SEARCHED:# 一旦是未访问的结点 dfs(graph, node) # 递归dfs(GRAPH, 'A') # A B C I D G F E H 36.有效的数独 Valid Sudoku 判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。 数字 1-9 在每一行只能出现一次。 数字 1-9 在每一列只能出现一次。 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。 方法 如果只判断有效的话，实现三个函数分别对应三个条件即可：判断行，判断列，判断9宫格。 把要判断的这些位置的数字取出来，然后用set后的长度是否等于原长度就能知道是不是有重复数字了。题目中已经说了给出的数字只有1~9，所以省掉了很多事。判断之前需要把’.‘给去掉，因为数字只允许出现一次，而’.’可能出现多次。 时间复杂度是O(N^2)，空间复杂度是O(N). 12345678910111213141516171819202122232425262728293031class Solution: def isValidSudoku(self, board: List[List[str]]) -&gt; bool: n = len(board) return self.isValidRow(n, board) and self.isValidCol(n, board) and self.isValidNineCell(n, board) def isValidRow(self, n, board): for r in range(n): row = [x for x in board[r] if x !='.'] if len(set(row)) != len(row): return False return True def isValidCol(self, n, board): for c in range(n): col = [board[r][c] for r in range(n) if board[r][c] != '.'] if len(set(col)) != len(col): return False return True def isValidNineCell(self, n, board): for r in range(0, n, 3): for c in range(0, n, 3): cell = [] for i in range(3): for j in range(3): num = board[r+i][c+j] if num != '.': cell.append(num) if len(set(cell)) != len(cell): return False return True 200.岛屿的数量 给定一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，计算岛屿的数量。一个岛被水包围，并且它是通过水平方向或垂直方向上相邻的陆地连接而成的。你可以假设网格的四个边均被水包围。 示例 1: 1234567输入:11110110101100000000输出: 1 方法:DFS 123456789101112131415161718class Solution: def numIslands(self, grid: List[List[str]]) -&gt; int: res = 0 for r in range(len(grid)): for c in range(len(grid[0])): if grid[r][c] == '1': self.dfs(grid, r, c) res += 1 return res def dfs(self, grid, i, j): dirs = [[-1,0], [0,1], [0,-1], [1,0]] grid[i][j] = '0' for dir in dirs: nr, nc = i+dir[0], j+dir[1] if nr&gt;=0 and nc&gt;=0 and nr&lt;len(grid) and nc&lt;len(grid[0]): if grid[nr][nc]=='1': self.dfs(grid, nr, nc) 参考 《Problem Solving with Algorithms and Data Structures using Python》 18_图与图的遍历 数据结构之图]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>LeetCode</tag>
        <tag>数据结构</tag>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python实现数据结构之堆]]></title>
    <url>%2F2019%2F03%2F10%2Fpython-algo-heap%2F</url>
    <content type="text"><![CDATA[堆是一种图的树形结构，被用于实现“优先队列”（priority queues）。优先队列是一种数据结构，可以自由添加数据，但取出数据时要从最小值开始按顺序取出。在堆的树形结构中，各个顶点被称为“结点”（node），数据就存储在这些结点中。 学习目标： 实现一个小顶堆、大顶堆、优先级队列 实现堆排序 利用优先级队列合并 K 个有序数组 求一组动态数据集合的最大 Top K （选做）第三天堆排序学习（复习） 堆中的每个结点最多有两个子结点。 树的形状取决于数据的个数。另外，结点的排列顺序为从上到下，同一行里则为从左到右。 在堆中存储数据时必须遵守这样一条规则 ：子结点必定大于父结点。 因此，最小值被存储在顶端的根结点中。 添加数据： 往堆中添加数据时，为了遵守这条规则，一般会把新数据放在最下面一行靠左的位置。当最下面一行里没有多余空间时，就再往下另起一行，把数据加在这一行的最左端。 在添加新数据后，如果父结点大于子结点，则不符合上文提到的规则，因此需要交换父子结点的位置。重复这样的操作直到数据都符合规则，不再需要交换为止。 取数据： 从堆中取出数据时，取出的是最上面的数据。这样，堆中就能始终保持最上面的数据最小。 由于最上面的数据被取出，因此堆的结构也需要重新调整。按照从上到下、同一行里从左到右的排列顺序，将最后的数据移动到最顶端。 如果子结点的数字小于父结点的，就将父结点与其左右两个子结点中较小的一个进行交换。重复这个操作直到数据都符合规则，不再需要交换为止。]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>LeetCode</tag>
        <tag>数据结构</tag>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python解leetcode二叉树(1)]]></title>
    <url>%2F2019%2F03%2F09%2Fpython_leetcode-binary-tree(1)%2F</url>
    <content type="text"><![CDATA[二叉查找树（英语：Binary Search Tree），也称为二叉搜索树、有序二叉树（ordered binary tree）或排序二叉树（sorted binary tree）。 学习目标： 实现一个二叉查找树，并且支持插入、删除、查找操作 LeetCode 108. 将有序数组转换为二叉搜索树 LeetCode 109. 有序链表转换二叉搜索树 LeetCode 701. 二叉搜索树中的插入操作 LeetCode 700. 二叉搜索树中的搜索 LeetCode 450. 删除二叉搜索树中的结点 实现查找二叉查找树中某个结点的后继、前驱结点 实现二叉树前、中、后序以及按层遍历 LeetCode 144. 二叉树的前序遍历 LeetCode 94. 二叉树的中序遍历 LeetCode 145. 二叉树的后序遍历 LeetCode 102. 二叉树的层次遍历 从前序与中序遍历序列构造二叉树 验证二叉搜索树 二叉树的锯齿形层次遍历 二叉树展开为链表 翻转二叉树 二叉查找树是指：一棵空树，或者具有下列性质的二叉树： 若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值； 若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值； 任意节点的左、右子树也分别为二叉查找树； 没有键值相等的节点。 二叉查找树相比于其他数据结构的优势在于查找、插入的时间复杂度较低，为 \(O(log n)\)。 每次插入的新的结点都是二叉查找树上新的叶子结点，在进行插入操作时，不必移动其它结点，只需改动某个结点的指针，由空变为非空即可。 将有序数组转换为二叉搜索树 LeetCode 108. Convert Sorted Array to Binary Search Tree 将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。 本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。 示例: 123456789给定有序数组: [-10,-3,0,5,9],一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树： 0 / \ -3 9 / / -10 5 方法：递归 由于要求二叉查找树是平衡的。所以可以选在数组的中间那个数当树根root。 然后这个数左边的数组为左子树，右边的数组为右子树，分别递归产生左右子树就可以了。 12345678910111213141516171819# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def sortedArrayToBST(self, nums: List[int]) -&gt; TreeNode: length = len(nums) if length == 0: return None if length == 1: return TreeNode(nums[0]) middle = (length-1)//2 root = TreeNode(nums[middle]) root.left = self.sortedArrayToBST(nums[:middle]) root.right = self.sortedArrayToBST(nums[middle+1:]) return root 有序链表转换二叉搜索树 LeetCode 109. Convert Sorted List to Binary Search Tree 给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。 本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。 示例: 123456789给定的有序链表： [-10, -3, 0, 5, 9],一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树： 0 / \ -3 9 / / -10 5 方法：链表转成数组 转成数组后，方法同上一题108的解法 123456789101112131415161718192021222324252627282930313233# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = None# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def sortedListToBST(self, head: ListNode) -&gt; TreeNode: nums = [] while head: nums.append(head.val) head = head.next def sortedArrayToBST(nums): length = len(nums) if length == 0: return None if length == 1: return TreeNode(nums[0]) middle = (length-1)//2 root = TreeNode(nums[middle]) root.left = sortedArrayToBST(nums[:middle]) root.right = sortedArrayToBST(nums[middle+1:]) return root return sortedArrayToBST(nums) 二叉搜索树中的插入操作 LeetCode 701. Insert into a Binary Search Tree 给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 保证原始二叉搜索树中不存在新值。 注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回任意有效的结果。 例如, 123456789给定二叉搜索树: 4 / \ 2 7 / \ 1 3和 插入的值: 5 你可以返回这个二叉搜索树: 12345 4 / \ 2 7 / \ /1 3 5 或者这个树也是有效的: 1234567 5 / \ 2 7 / \ 1 3 \ 4 方法 与根结点比较大小，递归左子树或右子树。 1234567891011121314151617# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def insertIntoBST(self, root: TreeNode, val: int) -&gt; TreeNode: if root: if val &lt; root.val: root.left = self.insertIntoBST(root.left, val) else: root.right = self.insertIntoBST(root.right, val) return root else: return TreeNode(val) 二叉搜索树中的搜索 LeetCode 700. Search in a Binary Search Tree 给定二叉搜索树（BST）的根节点和一个值。 你需要在BST中找到节点值等于给定值的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 NULL。 例如， 123456789给定二叉搜索树: 4 / \ 2 7 / \ 1 3和值: 2 你应该返回如下子树: 123 2 / \ 1 3 方法 与根结点比较大小，等于则返回，大于小于则 递归 左子树或右子树。 123456789101112131415161718192021222324252627282930313233343536373839404142# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution:# def sortedArrayToBST(self, nums: [int]) -&gt; TreeNode:# #层序树的列表转为树结构# l=len(nums)# nodeLst = []# for i in range(l):# nodeLst.append(TreeNode(nums[i]))# for i in range(l//2-1):# nodeLst[i].left = nodeLst[2*i+1]# nodeLst[i].right = nodeLst[2*i+2]# nodeLst[l//2-1].left = nodeLst[2*(l//2-1)+1]# if len(nums)%2 == 1:# nodeLst[l//2-2].left = nodeLst[2*(l//2-1)+1]# return nodeLst[0]## def BSTTraversal(self,root): #层序输出树的列表# a = []# L = []# L.append(root)# while L:# if L[0].left is not None:# L.append(L[0].left) # if L[0].right is not None:# L.append(L[0].right)# a.append(L.pop(0).val)# return a def searchBST(self, root: TreeNode, val: int) -&gt; TreeNode: if not root: return None if val == root.val: return root if val &lt; root.val: return self.searchBST(root.left, val) else: return self.searchBST(root.right, val) 删除二叉搜索树中的节点 LeetCode 450. Delete Node in a BST 给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。 一般来说，删除节点可分为两个步骤： 首先找到需要删除的节点； 如果找到了，删除它。 说明： 要求算法时间复杂度为 O(h)，h 为树的高度。 示例: 1234567891011121314151617181920212223242526root = [5,3,6,2,4,null,7]key = 3 5 / \ 3 6 / \ \2 4 7给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它。一个正确的答案是 [5,4,6,2,null,null,7], 如下图所示。 5 / \ 4 6 / \2 7另一个正确答案是 [5,2,6,null,4,null,7]。 5 / \ 2 6 \ \ 4 7 方法 递归遍历整个树 找到这个要删除的结点后，如果只有左孩子，或没有孩子，返回左孩子或空 如果有右孩子，找右子树的最小值，即待删结点的后继，交换两个值。 12345678910111213141516171819202122# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def deleteNode(self, root: TreeNode, key: int) -&gt; TreeNode: if not root: return None if root.val == key: # 找到这个结点 if not root.right: # 如果只有左孩子，或没有孩子 return root.left else: # 如果有右孩子 succ = root.right while succ.left:# 找右子树的最小值，即待删结点的后继 succ = succ.left succ.val, root.val = root.val, succ.val #交换两个值 root.left = self.deleteNode(root.left, key) # 递归遍历左子树 root.right = self.deleteNode(root.right, key) # 递归遍历右子树 return root 查找后继节点 查找二叉查找树中某个节点的前驱节点 思路 若一个节点有右子树，那么该节点的后继节点是其右子树中val值最小的节点（也就是右子树中所谓的leftMostNode） 若一个节点没有右子树，那么判断该节点和其父节点的关系 若该节点是其父节点的左边孩子，那么该节点的后继结点即为其父节点 若该节点是其父节点的右边孩子，那么需要沿着其父亲节点一直向树的顶端寻找，直到找到一个节点P，P节点是其父节点Q的左边孩子，那么Q就是该节点的后继节点 方法 写成递归形式， 当根节点值小于等于p节点值，说明p的后继节点一定在右子树中， 所以对右子节点递归调用此函数 如果根节点值大于p节点值，那么有可能根节点就是p的后继节点，或者左子树中的某个节点是p的后继节点， 所以先对左子节点递归调用此函数，如果返回空，说明根节点是后继节点，返回即可，如果不为空，则将那个节点返回 123456789101112131415161718192021222324252627282930313233343536373839404142434445# Definition for a binary tree node.class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = Noneclass Solution: def sortedArrayToBST(self, nums: [int]) -&gt; TreeNode: #层序树的列表转为树结构 l=len(nums) nodeLst = [] for i in range(l): nodeLst.append(TreeNode(nums[i])) for i in range(l//2-1): nodeLst[i].left = nodeLst[2*i+1] nodeLst[i].right = nodeLst[2*i+2] nodeLst[l//2-1].left = nodeLst[2*(l//2-1)+1] if len(nums)%2 == 1: nodeLst[l//2-2].left = nodeLst[2*(l//2-1)+1] return nodeLst[0] def searchSuccNode(self, root: TreeNode, key: int) -&gt; TreeNode: if not root: return None if root.val &lt;= key: # 后继在右子树中 return self.searchSuccNode(root.right, key) else: # 后继就是该结点，或者在该结点的左子树中。 left = self.searchSuccNode(root.left, key) if not left: return root else: return left if __name__ == '__main__': root = [4,2,7,1,3,5] p = 5 S = Solution() root = S.sortedArrayToBST(root) r= S.searchSuccNode(root,p) if not r: print(str(p) + '的后继不存在') else: print(str(p) + '的后继是' + str(r.val)) #输出：5的后继是7 查找前驱结点 查找二叉查找树中某个节点的前驱节点 思路 若一个节点有左子树，那么该节点的前驱节点是其左子树中val值最大的节点（也就是左子树中所谓的rightMostNode） 若一个节点没有左子树，那么判断该节点和其父节点的关系 若该节点是其父节点的右边孩子，那么该节点的前驱结点即为其父节点。 若该节点是其父节点的左边孩子，那么需要沿着其父亲节点一直向树的顶端寻找，直到找到一个节点P，P节点是其父节点Q的右边孩子，那么Q就是该节点的前驱节点 方法 方法和查找后继结点相同。只是左右子树比较相反。 1234567891011121314151617181920212223242526272829303132333435363738394041424344# Definition for a binary tree node.class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = Noneclass Solution: def sortedArrayToBST(self, nums: [int]) -&gt; TreeNode: #层序树的列表转为树结构 l=len(nums) nodeLst = [] for i in range(l): nodeLst.append(TreeNode(nums[i])) for i in range(l//2-1): nodeLst[i].left = nodeLst[2*i+1] nodeLst[i].right = nodeLst[2*i+2] nodeLst[l//2-1].left = nodeLst[2*(l//2-1)+1] if len(nums)%2 == 1: nodeLst[l//2-2].left = nodeLst[2*(l//2-1)+1] return nodeLst[0] def searchPredecessorNode(self, root: TreeNode, key: int) -&gt; TreeNode: if not root: return None if root.val &gt;= key: # 前驱在左子树中 return self.searchPredecessorNode(root.left, key) else: # 后继就是该结点，或者在该结点的左子树中。 right = self.searchPredecessorNode(root.right, key) if not right: return root else: return right if __name__ == '__main__': root = [4,2,7,1,3,5] p = 3 S = Solution() root = S.sortedArrayToBST(root) r= S.searchPredecessorNode(root,p) if not r: print(str(p) + '的前驱不存在') else: print(str(p) + '的前驱是' + str(r.val)) 二叉树的前序遍历 LeetCode 144. Binary Tree Preorder Traversal 给定一个二叉树，返回它的 前序 遍历。 示例: 12345678输入: [1,null,2,3] 1 \ 2 / 3 输出: [1,2,3] 方法一：用栈从上到下遍历 先右孩子入栈，再左孩子入栈。 12345678910111213141516171819# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def preorderTraversal(self, root: TreeNode) -&gt; List[int]: if not root: return [] stack = [root] # 用栈来辅助存储 res = [] while stack: node = stack.pop() res.append(node.val) if node.right: stack.append(node.right) if node.left: stack.append(node.left) return res 方法二：递归 12345678910class Solution: def preorderTraversal(self, root: TreeNode) -&gt; List[int]: res = [] def dfs(root, res): if root: res.append(root.val) dfs(root.left, res) dfs(root.right, res) return res return dfs(root,res) 方法三：用栈迭代 从根节点開始，一直找它的左子树，直到为空，再找右子树。 1234567891011121314class Solution: def preorderTraversal(self, root: TreeNode) -&gt; List[int]: if not root: return [] stack = [] # 用栈来辅助存储 res = [] cur = root while stack or cur: while cur: #从根节点開始，一直找它的左子树，直到cur为空 stack.append(cur) # 栈中存入根节点和左孩子 res.append(cur.val) cur = cur.left cur = stack.pop().right #找右子树 return res 二叉树的中序遍历 LeetCode 94. Binary Tree Inorder Traversal 给定一个二叉树，返回它的中序 遍历。 示例: 12345678输入: [1,null,2,3] 1 \ 2 / 3输出: [1,3,2] 方法一：递归 1234567891011121314151617# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def inorderTraversal(self, root: TreeNode) -&gt; List[int]: res = [] def inorder(root, res): if root: inorder(root.left, res) res.append(root.val) inorder(root.right, res) return res return inorder(root,res) 方法二：用栈迭代 123456789101112131415class Solution: def inorderTraversal(self, root: TreeNode) -&gt; List[int]: if not root: return [] stack = [] # 用栈来辅助存储 res = [] cur = root while stack or cur: while cur: #从根节点開始，一直找它的左子树，直到cur为空 stack.append(cur) # 栈中存入根节点和左孩子 cur = cur.left temp = stack.pop() # 出栈，则左孩子先出来，然后才是根结点 res.append(temp.val) cur = temp.right #找右子树 return res 二叉树的后序遍历 LeetCode 145. Binary Tree Postorder Traversal 给定一个二叉树，返回它的 后序 遍历。 示例: 12345678输入: [1,null,2,3] 1 \ 2 / 3 输出: [3,2,1] 方法一：递归 12345678910class Solution: def postorderTraversal(self, root: TreeNode) -&gt; List[int]: res = [] def postorder(root, res): if root: postorder(root.left, res) postorder(root.right, res) res.append(root.val) return res return postorder(root,res) 方法二：迭代 1234567891011121314class Solution: def postorderTraversal(self, root: TreeNode) -&gt; List[int]: if not root: return [] stack = [] # 用栈来辅助存储 res = [] cur = root while stack or cur: while cur: #从根节点開始，一直找它的左子树，直到cur为空 stack.append(cur) # 栈中存入根节点和右孩子 res.append(cur.val) cur = cur.right cur = stack.pop().left #找左子树 return res[::-1] 二叉树的层次遍历 LeetCode 102. Binary Tree Level Order Traversal 给定一个二叉树，返回其按层次遍历的节点值。 （即逐层地，从左到右访问所有节点）。 例如: 给定二叉树: [3,9,20,null,null,15,7], 12345 3 / \9 20 / \ 15 7 返回其层次遍历结果： 12345[ [3], [9,20], [15,7]] 方法一： 广度优先搜索（BFS） 1234567891011121314151617181920212223# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def levelOrder(self, root: TreeNode) -&gt; List[List[int]]: if not root: return [] res = [] currLevel = [root] while currLevel: res.append([node.val for node in currLevel]) nextLevel = [] for node in currLevel: if node.left: nextLevel.append(node.left) if node.right: nextLevel.append(node.right) currLevel = nextLevel return res 方法二：深度优先搜索（DFS） 12345678910111213class Solution: def levelOrder(self, root: TreeNode) -&gt; List[List[int]]: def dfs(root, depth, res): if not root: return res if len(res) &lt;= depth: res.append([]) res[depth].append(root.val) dfs(root.left, depth+1,res) dfs(root.right,depth+1,res) res = [] dfs(root,0,res) return res 105. 从前序与中序遍历序列构造二叉树 根据一棵树的前序遍历与中序遍历构造二叉树。 注意: 你可以假设树中没有重复的元素。 例如，给出 12前序遍历 preorder = [3,9,20,15,7]中序遍历 inorder = [9,3,15,20,7] 返回如下的二叉树： 12345 3 / \9 20 / \ 15 7 方法 先序遍历的开头第一个元素是根元素，找到其在中序遍历中的位置，分割出左右子树。再根据左右子树的长度在先序遍历中划分。 123456789class Solution: def buildTree(self, preorder: List[int], inorder: List[int]) -&gt; TreeNode: if not preorder or not inorder: return None root = TreeNode(preorder[0]) index = inorder.index(preorder[0]) root.left = self.buildTree(preorder[1:index+1], inorder[:index]) root.right = self.buildTree(preorder[index+1:], inorder[index+1:]) return root 二叉树的锯齿形层次遍历 LeetCode 103. Binary Tree Zigzag Level Order Traversal 给定一个二叉树，返回其节点值的锯齿形层次遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。 例如： 给定二叉树 [3,9,20,null,null,15,7], 12345 3 / \9 20 / \ 15 7 返回锯齿形层次遍历如下： 12345[ [3], [20,9], [15,7]] 方法 1234567891011121314151617181920212223# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def zigzagLevelOrder(self, root: TreeNode) -&gt; List[List[int]]: def dfs(root, depth, res): if not root: return res if len(res) &lt;= depth: res.append([]) if depth % 2 == 0: res[depth].append(root.val) else: res[depth].insert(0, root.val) dfs(root.left, depth+1,res) dfs(root.right,depth+1,res) res = [] dfs(root,0,res) return res 验证二叉搜索树 LeetCode 98. Validate Binary Search Tree 给定一个二叉树，判断其是否是一个有效的二叉搜索树。 假设一个二叉搜索树具有如下特征： 节点的左子树只包含小于当前节点的数。 节点的右子树只包含大于当前节点的数。 所有左子树和右子树自身必须也是二叉搜索树。 示例 1: 12345输入: 2 / \ 1 3输出: true 示例 2: 123456789输入: 5 / \ 1 4 / \ 3 6输出: false解释: 输入为: [5,1,4,null,null,3,6]。 根节点的值为 5 ，但是其右子节点值为 4 。 方法一：中序遍历 中序遍历按照 左孩子－根节点－右孩子 这个顺序遍历，如果每个子树都满足左孩子&lt;根节点&lt;右孩子，那就应该是个BST吧。 1234567891011class Solution: def isValidBST(self, root: TreeNode) -&gt; bool: res = [] def inorder(root, res): if root: inorder(root.left, res) res.append(root.val) inorder(root.right, res) return res inorder(root,res) return res == sorted(res) and len(res) == len(set(res)) 方法二：递归 左子树的值要在(min,mid)之间，右子树的值在(mid,max)之间，这个mid值并不是中位数而是当前节点的值。 定义一个辅助函数， 要给这个辅助函数传入：当前要判断的节点、当前要判断的这个节点的取值下限和取值上限。 然后使用递归即可，每次要计算下一个节点的时候都要根据这个节点是左孩子还是右孩子对其取值的区间进行更新。 12345678910class Solution: def isValidBST(self, root: TreeNode) -&gt; bool: return self.valid(root, float('-inf'), float('inf')) def valid(self, root, min, max): if not root: return True if root.val &gt;= max or root.val &lt;= min: return False return self.valid(root.left, min, root.val) and self.valid(root.right, root.val, max) 114. 二叉树展开为链表 给定一个二叉树，原地将它展开为链表。 例如，给定二叉树 12345 1 / \ 2 5 / \ \3 4 6 将其展开为： 12345678910111 \ 2 \ 3 \ 4 \ 5 \ 6 方法：先序遍历 最简单的方法就是使用列表保存先序遍历的每个节点，然后在列表中完成操作。即，使得列表中每个元素的左孩子为空，右孩子都是下一个节点。 这个方法很简单，不过需要O(N)的空间复杂度。 12345678910111213141516class Solution: def flatten(self, root: TreeNode) -&gt; None: """ Do not return anything, modify root in-place instead. """ res = [] self.preOrder(root, res) for i in range(len(res)-1): res[i].left = None res[i].right = res[i+1] def preOrder(self, root, res): if not root:return res.append(root) self.preOrder(root.left, res) self.preOrder(root.right, res) 翻转二叉树 LeetCode 226. Invert Binary Tree 翻转一棵二叉树。 示例： 123456789101112131415输入： 4 / \ 2 7 / \ / \1 3 6 9输出： 4 / \ 7 2 / \ / \9 6 3 1 方法一：递归 DFS 每次递归交换当前节点的左右子树，同时对左右子树做同样的处理。 12345678class Solution: def invertTree(self, root: TreeNode) -&gt; TreeNode: if not root: return None temp = root.left root.left = self.invertTree(root.right) root.right = self.invertTree(temp) return root 方法二：栈 12345678910111213class Solution: def invertTree(self, root: TreeNode) -&gt; TreeNode: if not root: return None stack = [root] while len(stack) != 0: node = stack.pop() node.left, node.right = node.right, node.left if node.left: stack.append(node.left) if node.right: stack.append(node.right) return root 参考 《Problem Solving with Algorithms and Data Structures using Python》 [LeetCode] Inorder Successor in BST 二叉搜索树中的中序后继节点 226. Invert Binary Tree [easy] (Python) 112. Path Sum [easy] (Python)]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>LeetCode</tag>
        <tag>数据结构</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python解leetcode字符串(1)]]></title>
    <url>%2F2019%2F03%2F08%2Fpython_leetcode-string(1)%2F</url>
    <content type="text"><![CDATA[学习目标： 实现一个字符集，只包含 a～z 这 26 个英文字母的 Trie 树 实现朴素的字符串匹配算法 反转字符串 翻转字符串里的单词 反转字符串中的单词 III 字符串转换整数 (atoi) LeetCode 208. 实现 Trie (前缀树) 实现一个 Trie (前缀树)，包含 insert, search, 和 startsWith 这三个操作。 示例: 12345678Trie trie = new Trie();trie.insert(&quot;apple&quot;);trie.search(&quot;apple&quot;); // 返回 truetrie.search(&quot;app&quot;); // 返回 falsetrie.startsWith(&quot;app&quot;); // 返回 truetrie.insert(&quot;app&quot;); trie.search(&quot;app&quot;); // 返回 true 说明: 你可以假设所有的输入都是由小写字母 a-z 构成的。 保证所有输入均为非空字符串。 方法 trie，又称前缀树或字典树，是一种有序树，用于保存关联数组，其中的键通常是字符串。 一个节点的所有子孙都有相同的前缀，也就是这个节点对应的字符串，而根节点对应空字符串。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class TrieNode: def __init__(self): self.isEnd = False # 判断是否是词尾 self.children = dict() #子结点 class Trie: def __init__(self): """ Initialize your data structure here. """ self.root = TrieNode() def insert(self, word: str) -&gt; None: """ Inserts a word into the trie. """ currNode = self.root for i in word: if i not in currNode.children: currNode.children[i] = TrieNode() currNode = currNode.children[i] currNode.isEnd = True def search(self, word: str) -&gt; bool: """ Returns if the word is in the trie. """ currNode = self.root for i in word: if i not in currNode.children: return False currNode = currNode.children[i] return currNode.isEnd def startsWith(self, prefix: str) -&gt; bool: """ Returns if there is any word in the trie that starts with the given prefix. """ currNode = self.root for i in prefix: if i not in currNode.children: return False currNode = currNode.children[i] return True# Your Trie object will be instantiated and called as such:# obj = Trie()# obj.insert(word)# param_2 = obj.search(word)# param_3 = obj.startsWith(prefix) Trie树的优缺点 Trie树的核心思想是空间换时间，利用字符串的公共前缀来减少无谓的字符串比较以达到提高查询效率的目的。 优点 插入和查询的效率很高，都为O(m)O(m)，其中 mm 是待插入/查询的字符串的长度。 关于查询，会有人说 hash 表时间复杂度是O(1)O(1)不是更快？但是，哈希搜索的效率通常取决于 hash 函数的好坏，若一个坏的 hash 函数导致很多的冲突，效率并不一定比Trie树高。 Trie树中不同的关键字不会产生冲突。 Trie树只有在允许一个关键字关联多个值的情况下才有类似hash碰撞发生。 Trie树不用求 hash 值，对短字符串有更快的速度。通常，求hash值也是需要遍历字符串的。 Trie树可以对关键字按字典序排序。 缺点 当 hash 函数很好时，Trie树的查找效率会低于哈希搜索。 空间消耗比较大。 LeetCode 28. 实现strStr() Implement strStr() 实现 strStr() 函数。 给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回 -1。 示例 1: 12输入: haystack = &quot;hello&quot;, needle = &quot;ll&quot;输出: 2 示例 2: 12输入: haystack = &quot;aaaaa&quot;, needle = &quot;bba&quot;输出: -1 说明: 当 needle 是空字符串时我们返回 0 。这与C语言的 strstr() 以及 Java的 indexOf() 定义相符。 方法：内置find()函数 123class Solution: def strStr(self, haystack: str, needle: str) -&gt; int: return haystack.find(needle) 方法：朴素算法 字符串匹配算法主要是两类，最基本的暴力解法，也叫做朴素算法，另一种是KMP算法。 朴素算法是通过一个循环找到所有有效偏移，检查是否满足条件。 1234567class Solution: def strStr(self, haystack: str, needle: str) -&gt; int: M, N = len(haystack), len(needle) for i in range(M-N+1): if haystack[i:i+N] == needle: return i return -1 LeetCode 344. 反转字符串 反转字符串 编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。 不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。 你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。 示例 1： 12输入：[&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]输出：[&quot;o&quot;,&quot;l&quot;,&quot;l&quot;,&quot;e&quot;,&quot;h&quot;] 示例 2： 12输入：[&quot;H&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;h&quot;]输出：[&quot;h&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;H&quot;] 方法 依次交换前面和后面的字符直至中间字符，完成反转。 123456789class Solution: def reverseString(self, s: List[str]) -&gt; None: &quot;&quot;&quot; Do not return anything, modify s in-place instead. &quot;&quot;&quot; for i in range(len(s)//2): tmp = s[i] s[i] = s[len(s)-1-i] s[len(s)-1-i] = tmp LeetCode 151. 翻转字符串里的单词 Reverse Words in a String 给定一个字符串，逐个翻转字符串中的每个单词。 示例 1： 12输入: &quot;the sky is blue&quot;输出: &quot;blue is sky the&quot; 示例 2： 123输入: &quot; hello world! &quot;输出: &quot;world! hello&quot;解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。 示例 3： 123输入: &quot;a good example&quot;输出: &quot;example good a&quot;解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。 说明： 无空格字符构成一个单词。 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。 方法 12345class Solution: def reverseWords(self, s: str) -&gt; str: lst = s.split() lst.reverse() return " ".join(lst) 557. 反转字符串中的单词 III 给定一个字符串，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。 示例 1: 123456输入: &quot;Let&apos;s take LeetCode contest&quot;输出: &quot;s&apos;teL ekat edoCteeL tsetnoc&quot; 注意：在字符串中，每个单词由单个空格分隔，并且字符串中不会有任何额外的空格。123 方法 使用split与内置函数逆置 1234567class Solution: def reverseWords(self, s: str) -&gt; str: l = s.split() k = [] for i in l: k.append(i[::-1]) return " ".join(k) LeetCode 8. 字符串转换整数 (atoi) 字符串转换整数 (atoi) 请你来实现一个 atoi 函数，使其能将字符串转换成整数。 首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。 当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。 该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。 注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。 在任何情况下，若函数不能进行有效的转换时，请返回 0。 说明：假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 \([−2^{31}, 2^{31} − 1]\)。如果数值超过这个范围，qing返回 INT_MAX\((2^{31} − 1)\) 或 INT_MIN \((−2^{31})\) 。 示例 1: 12输入: &quot;42&quot;输出: 42 示例 2: 1234输入: &quot; -42&quot;输出: -42解释: 第一个非空白字符为 &apos;-&apos;, 它是一个负号。 我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。 示例 3: 123输入: &quot;4193 with words&quot;输出: 4193解释: 转换截止于数字 &apos;3&apos; ，因为它的下一个字符不为数字。 示例 4: 1234输入: &quot;words and 987&quot;输出: 0解释: 第一个非空字符是 &apos;w&apos;, 但它不是数字或正、负号。 因此无法执行有效的转换。 示例 5: 1234输入: &quot;-91283472332&quot;输出: -2147483648解释: 数字 &quot;-91283472332&quot; 超过 32 位有符号整数范围。 因此返回 INT_MIN (−231) 。 方法一：按条件多次判断 按题目要求进行如下处理和判断： 1. strip()去掉首位空格字符 2. 如果字符串为空，返回0 3. 判断首字符是否为正负号 4. 遍历每个字符，若在0-9范围内，则加入数字中；否则break。 5. 乘上正负号之后，判断数字是否越界。 12345678910111213141516171819202122232425class Solution: def myAtoi(self, str): """ :type str: str :rtype: int """ str = str.strip() number, flag = 0, 1 if not str: return 0 if str[0] == '-' and len(str)&gt;1: str = str[1:] flag = -1 elif str[0] == '+' and len(str)&gt;1: str = str[1:] for c in str: if c &gt;= '0' and c &lt;= '9': number = 10*number + ord(c) - ord('0') else: break number = flag * number number = number if number &lt;= 2**31-1 else 2**31-1 number = number if number &gt;= -2**31 else -2**31 return number 方法二：正则匹配 用正则表达式来匹配 123456789101112131415161718192021222324252627282930class Solution: def myAtoi(self, str): """ :type str: str :rtype: int """ # 导入正则模块 import re # 字符串中查找全部符合条件的整数，返回的是列表，第一个参数是正则，第二个参数是字符串 ret = re.findall(r"^[-+]?\d+", str.strip()) # strip()字符串去空格 # 判断是否有匹配的值，没有的话返回0，例如"word values 987"，匹配不到，返回0 if ret: ret_str = ret[0] # 匹配的数字的字符串 ret_str2 = "" # 记录去符号的字符串，ret_str后面还要使用，所以定义一个新的变量记录 # 判断是否带有符号 + or - if ret_str[0] == "-" or ret_str[0] == "+": ret_str2 = ret_str[1:] else: ret_str2 = ret_str # str转int ret_int = int(ret_str2) # 判断第一个字符是否为负号 if ret_str[0] == "-": # 三目运算符，判断是否溢出 # 如果ret_int &lt;= 2**31则返回-ret_int，否则返回-2**31 return -ret_int if ret_int &lt;= 2**31 else -2**31 else: return ret_int if ret_int &lt; 2**31 else 2**31-1 else: return 0 比方法一的执行时间短 参考 Trie树（Prefix Tree）介绍]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>LeetCode</tag>
        <tag>数据结构</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python实现数据结构之哈希表]]></title>
    <url>%2F2019%2F03%2F07%2Fpython-algo-hash%2F</url>
    <content type="text"><![CDATA[散列表（Hash table，也叫哈希表），是根据键（Key）而直接访问在内存存储位置的数据结构。 具体方法是： 选定一个整数的下标范围（通常以 0 或 1 开始)，建立一个包括相应元素位置范围的顺序表。 选定一个从实际关键码集合到上述下标范围的适当映射 h 在需要存入关键码为 key 的数据时，将其存入表中第 h(key) 个位置。 遇到以 key 为关键码检索数据时，直接去找表中第 h(key) 个位置的元素。 这个 h 称为散列函数， 也常被称为哈希（hash)函数或杂凑函数，它就是从可能的关键码集合到一个整数区间（下标区间）的映射。 学习目标： 实现一个基于链表法解决冲突问题的散列表 实现一个 LRU 缓存淘汰算法 LeetCode 1. 两数之和 LeetCode 202. Happy Number 字符串中的第一个唯一字符 实现一个基于链表法解决冲突问题的散列表 在存储数据的过程中，如果发生冲突，可以利用链表在已有数据的后面插入新数据来解决冲突。这种方法被称为“链地址法”。 在哈希表中，我们可以利用哈希函数快速访问到数组中的目标数据。如果发生哈希冲突，就使用链表进行存储。这样一来，不管数据量为多少，我们都能够灵活应对。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class HashTable: def __init__(self): self.size = 11 #容量自定，但必须是素数 self.hash_table = [[] for _ in range(self.size)] # 存放keys-values # list中的list是同一个位置的元素集合 def insert(self,key,value): hash_value =hash(key)%self.size #哈希函数 key_exists = False bucket = self.hash_table[hash_value] for i, kv in enumerate(bucket): k, v = kv if key == k: key_exists = True break if key_exists: bucket[i] = ((key,value)) else: bucket.append((key,value)) def search(self, key): hash_value = hash(key)%self.size #哈希函数 bucket = self.hash_table[hash_value] for i, kv in enumerate(bucket): k, v = kv if key == k: return v def delete(self, key): hash_value = hash(key)%self.size #哈希函数 key_exists = False bucket = self.hash_table[hash_value] for i, kv in enumerate(bucket): k, v = kv if key == k: key_exists = True break if key_exists: del bucket[i] return v else: return 0 if __name__ == '__main__': H=HashTable() H.insert(2,"lion") H.insert(10,"cat") H.insert(25,"dog") print(H.hash_table) # 输出 H.insert(10,"kitty") H.insert(21,"tiger") print(H.hash_table) # 输出 print("查找10的值为"+ H.search(10)) print("删除10，值为" + H.delete(10)) print(H.hash_table) # 输出 输出： 12345[[], [], [(2, &apos;lion&apos;)], [(25, &apos;dog&apos;)], [], [], [], [], [], [], [(10, &apos;cat&apos;)]][[], [], [(2, &apos;lion&apos;)], [(25, &apos;dog&apos;)], [], [], [], [], [], [], [(10, &apos;kitty&apos;), (21, &apos;tiger&apos;)]]查找10的值为kitty删除10，值为kitty[[], [], [(2, &apos;lion&apos;)], [(25, &apos;dog&apos;)], [], [], [], [], [], [], [(21, &apos;tiger&apos;)]] 如果数组的空间太小，使用哈希表的时候就容易发生冲突，线性查找的使用频率也会更高；反过来，如果数组的空间太大，就会出现很多空箱子，造成内存的浪费。因此，给数组设定合适的空间非常重要。 LeetCode 146. LRU缓存机制 LRU Cache 一个用hash表作为底层结构的数据库，当然少不了缓存淘汰算法。当缓存需要被清理时（比如空间占用已经接近临界值了），需要使用某种淘汰算法来决定清理掉哪些数据。 LRU：Least Recently Used，最近最少使用。判断最近被使用的时间，目前最远的数据优先被淘汰，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高”。 LRU 算法过程： 新数据插入到链表头部； 每当缓存命中（即缓存数据被访问），则将数据移到链表头部； 当链表满的时候，将链表尾部的数据丢弃。 这个缓存器主要有两个成员函数，get 和 put。 其中 get 函数是通过输入 key 来获得 value，如果成功获得后，这对 (key, value) 升至缓存器中最常用的位置（顶部），如果 key 不存在，则返回 -1 。 而 put 函数是插入一对新的 (key, value)，如果原缓存器中有该 key，则需要先删除掉原有的，将新的插入到缓存器的顶部。如果不存在，则直接插入到顶部。 若加入新的值后缓存器超过了容量，则需要删掉一个最不常用的值，也就是底部的值。 123456789101112131415161718192021222324252627282930class LRUCache: def __init__(self, capacity: int): self.cap = capacity # 容量 self._cache = [] #缓存 self._cacheMap = &#123;&#125; #缓存哈希表 def get(self, key: int) -&gt; int: if key not in self._cacheMap: return -1 self._cache.remove(key) self._cache.append(key) return self._cacheMap[key] def put(self, key: int, value: int) -&gt; None: if key in self._cacheMap: self._cacheMap[key] = value self._cache.remove(key) self._cache.append(key) else: if len(self._cache) == self.cap: x = self._cache.pop(0) del self._cacheMap[x] self._cache.append(key) self._cacheMap[key] = value# Your LRUCache object will be instantiated and called as such:# obj = LRUCache(capacity)# param_1 = obj.get(key)# obj.put(key,value) LeetCode 1. 两数之和 Two Sum ## 题目描述 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例: 给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9 所以返回 [0, 1] 方法：哈希表 利用python中的字典记录记录下每个元素出现的位置 12345678910111213141516class Solution(object): def twoSum(self, nums, target): """ :type nums: List[int] :type target: int :rtype: List[int] """ dic = dict() for index,value in enumerate(nums): sub = target - value if sub in dic: return [dic[sub], index] else: dic[value]=index LeetCode 202. Happy Number 202. 快乐数 编写一个算法来判断一个数是不是“快乐数”。 一个“快乐数”定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是无限循环但始终变不到 1。如果可以变为 1，那么这个数就是快乐数。 示例: 1234567输入: 19输出: true解释: 12 + 92 = 8282 + 22 = 6862 + 82 = 10012 + 02 + 02 = 1 方法一 按照“happy number”的定义，直接循环计算各位平方和，观察收敛到1 12345678910class Solution: def isHappy(self, n: int) -&gt; bool: mem = set() while n!=1: n = sum([int(x)*int(x) for x in list(str(n))]) if n in mem: return False else: mem.add(n) return True 方法二 先求出100以内的所有happy number， 按照“happy number”的定义，直接循环计算各位平方和，观察收敛到100之内后的数值是否在列表之内。 1234567class Solution: def isHappy(self, n: int) -&gt; bool: # 100以内的happyNumber happySet = set([1, 7, 10, 13, 19, 23, 28, 31, 32, 44, 49, 68, 70, 79, 82, 86, 91, 94, 97]) while n&gt;99: n = sum([int(x)*int(x) for x in list(str(n))]) return n in happySet 387. 字符串中的第一个唯一字符 给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。 案例: s = “leetcode” 返回 0. s = “loveleetcode”, 返回 2. 注意事项：您可以假定该字符串只包含小写字母。 方法 首先做个字符出现次数的统计，然后再次遍历，找出只出现了一次的第一个字符。 1234567class Solution: def firstUniqChar(self, s: str) -&gt; int: counter = collections.Counter(s) for i,c in enumerate(s): if counter[c] == 1: return i return -1 参考 缓存淘汰算法–LRU算法 看动画理解「链表」实现LRU缓存淘汰算法 《我的第一本算法书》 Hash Table implementation in Python [Data Structures &amp; Algorithms]]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>LeetCode</tag>
        <tag>数据结构</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python解LeetCode二分查找(1)]]></title>
    <url>%2F2019%2F03%2F06%2Fpython_leetcode-binary-search(1)%2F</url>
    <content type="text"><![CDATA[学习目标： 实现一个有序数组的二分查找算法 实现模糊二分查找算法 大于给定值的第一个元素 LeetCode 69. x 的平方根 LeetCode 35. 搜索插入位置 LeetCode 34. 在排序数组中查找元素的第一个和最后一个位置 二分查找 查找和目标值 k 完全相等的数 12345678910111213141516171819def BinarySearch(lst,k): left = 0 right = len(lst)-1 while left &lt;= right: mid = (left+right)//2 if lst[mid] &lt; k: left = mid + 1 elif lst[mid] &gt; k: right = mid - 1 else: return mid return -1if __name__ == "__main__": lst = [1,2,3,34,56,57,78,87] print(BinarySearch(lst,2)) 模糊二分查找 可能是跟目标值相等的数在数组中并不唯一，而是有多个，那么这种情况下nums[mid] == target这条判断语句就没有必要存在。 大于给定值的第一个元素 查找数组中第一个比 target 大的数的下标。 123456789101112131415161718192021def searchInsert(nums, target): """ :type nums: List[int] :type target: int :rtype: int """ left = 0 right = len(nums)-1 while left &lt;= right: mid = (right+left)//2 if nums[mid] &gt; target: right = mid-1 else: left = mid+1 return right+1if __name__ == "__main__": lst =[1,2,3,3,3,5,5,10,8] print(searchInsert(lst,5)) 输出7 还可变形为查找最后一个不大于目标值的数。 我们已经找到了第一个大于目标值的数，那么再往前退一位，位置 - 1，就是最后一个不大于目标值的数。比如在数组[0, 1, 1, 1, 1, 5]中查找数字1，就会返回最后一个数字1的位置4。 if nums[mid] &gt; target: 中的’&gt;’ 改为 ‘&gt;=’，就能找到大于等于给定值的第一个元素。往前退一位，可变形为查找最后一个小于目标值的数。 69. x 的平方根 实现 int sqrt(int x) 函数。 计算并返回 x 的平方根，其中 x 是非负整数。 由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。 示例 1: 12输入: 4输出: 2 示例 2: 1234输入: 8输出: 2说明: 8 的平方根是 2.82842..., 由于返回类型是整数，小数部分将被舍去。 方法：二分查找 1234567891011121314class Solution: def mySqrt(self, x: int) -&gt; int: left = 0 right = x while left &lt;= right: mid = (left+right)//2 if mid * mid &lt; x: left = mid + 1 elif mid * mid &gt; x: right = mid -1 else: return mid return left -1 35. 搜索插入位置 Search Insert Position 题目描述 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。 你可以假设数组中无重复元素。 示例 1: 输入: [1,3,5,6], 5 输出: 2 示例 2: 输入: [1,3,5,6], 2 输出: 1 示例 3: 输入: [1,3,5,6], 7 输出: 4 方法：二分查找 1234567891011121314151617181920class Solution(object): def searchInsert(self, nums, target): """ :type nums: List[int] :type target: int :rtype: int """ left = 0 right = len(nums)-1 while left &lt;= right: mid = (right-left)/2 + left if nums[mid] == target: return mid elif nums[mid] &gt; target: right = mid-1 else: left = mid+1 return left 34. 在排序数组中查找元素的第一个和最后一个位置 给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。 你的算法时间复杂度必须是 O(log n) 级别。 如果数组中不存在目标值，返回 [-1, -1]。 示例 1: 12输入: nums = [5,7,7,8,8,10], target = 8输出: [3,4] 示例 2: 12输入: nums = [5,7,7,8,8,10], target = 6输出: [-1,-1] 方法 12345678910111213141516171819class Solution: def searchRange(self, nums: List[int], target: int) -&gt; List[int]: if not nums: return [-1,-1] left = 0 right = len(nums)-1 while left &lt;= right: mid = (right+left)//2 if nums[mid] &gt; target: right = mid-1 else: left = mid+1 if nums[right] != target: return [-1,-1] l = right while l&gt;0 and nums[l-1] == target: l -= 1 return [l,right]]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>LeetCode</tag>
        <tag>数据结构</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python实现排序算法]]></title>
    <url>%2F2019%2F03%2F04%2Fpython-leetcode-sorting(0)%2F</url>
    <content type="text"><![CDATA[学习目标： 实现归并排序、快速排序、插入排序、冒泡排序、选择排序、堆排序 LeetCode 215. 数组中的第K个最大元素 插入排序 每次假设前面的元素都是已经排好序了的，然后将当前位置的元素插入到前面已排好序的序列中。 123456789101112def insert_sort(lst): for index in range(1, len(lst)): #开始时[0,1]已排序 x = lst[index] #待排序的元素 p = index # 从位置j往前开始比较 while p&gt;0 and lst[p-1] &gt; x: lst[p] = lst[p-1] p -= 1 lst[p] = xlst = [63,21,44,3,67,9,6,86,12]insert_sort(lst)print(lst) 空间复杂度是\(O(1)\) 平均时间复杂度\(O(n^2)\) 二分查找的插入排序 在插人排序中需要检索元素的插人位置， 而且是在排序的(部分)序列里检索。 这提示了另一可能方案： 采用二分查找。 1234567891011121314151617181920def insert_sort_binarysearch(lst): for index in range(1, len(lst)): x = lst[index] p = index low = 0 high = index-1 while high &gt;= low: mid = (high+low)//2 if lst[mid] &gt; x: high = mid-1 else: low = mid+1 while p &gt; low: lst[p] = lst[p-1] p -= 1 lst[p] = xlst = [63,21,44,3,67,9,6,86,12]insert_sort_binarysearch(lst)print(lst) 但这种做法不可能从根本上改变算法的性质： 虽然每次检索位置的代价降低了， 但找到位置后还需要顺序移动元素， 腾出空位将元素插人。 后一操作仍然可能需要线性时间。 选择排序 思路： 1. 以空序列作为排序工作的开始， 2. 遍历，每次从剩余未排序的元素中选取最小值， 将其放在已排序的\(i\)个元素的后面，作为序列的第\(i+ 1\)个元素， 使已排序序列增长。 3. 做到尚未排序的序列里只剩一个元素时（它必然为最大)，只需直接将其放在已排序的记录之后， 整个排序就完成了。 需要解决两个问题： 第一是如何选择元素； 第二是做出适当安排，尽可能利用现有序列的存储空间，避免另行安排存储。 - 最简单的选择方法是顺序扫描序列中的元素， 记住遇到的最小元素。 一次扫描完毕就找到了一个最小元素。反复扫描就能完成排序工作。 - 选出了一个元素，原来的序列中就出现了一个空位，可以把这些空位集中起来存放排好序的序列。 在排序过程中的任何时刻， 表的前段积累了一批递增的已经排好序的元素，而且它们都不大于任何一个未排序记录。 下一步从未排序段中选岀最小的元素， 将其存放在已排序元素段的后面(直接交换紧随已排序段的那个位置和最小值)。 这样在只剩一个元素时， 一定最大值， 工作即可结束。 123456789101112def select_sort(lst): for index in range(len(lst)-1): #不需要循环最后一个元素 k = index # 从index位置开始往后遍历比较找到最小元素 for j in range(index, len(lst)): if lst[j] &lt; lst[k]: k = j if index != k: # 确认不是同一个位置 lst[index],lst[k] = lst[k], lst[index] #交换元素 lst = [63,21,44,3,67,9,6,86,12]select_sort(lst)print(lst) 空间复杂度是\(O(1)\) 时间复杂度是\(O(n^2)\) 选择排序比较低效， 原因就在于其中的顺序比较： 每次选择一个元素， 都是从头开始做一遍完全的比较， 在整个排序过程中做了很多重复比较工作。 堆排序 如果在一个连续表里存储的数据是一个小顶堆（ 元素之间的关系满足堆序 )， 按优先队列的操作方式反复弹出堆顶元素， 能够得到一个递增序列。 1234567891011121314151617181920212223def heap_sort(elems): def siftdown(elems,e,begin,end):# 建立大根堆，排序 i, j = begin, begin*2+1 while j &lt; end: if j+1&lt;end and elems[j+1] &gt; elems[j]: j = j+1 #左右子树比较，选择较大的为j if e &gt; elems[j]: break #e比左右子树都大，那就不用下移比较了 elems[i] = elems[j] i, j = j, j*2+1 #下移 elems[i] = e end = len(elems) for i in range(end//2,-1,-1):#建立堆 siftdown(elems,elems[i],i,end) for i in range(end-1, 0, -1):#排序 e = elems[i] elems[i] = elems[0] siftdown(elems,e,0,i) l=[-1,26,5,77,1,61,11,59,15,48,19] heap_sort(l)print(l) 时间复杂度是\(O(nlogn)\) 冒泡排序 冒泡排序就是重复“从序列右边开始比较相邻两个数字的大小，再根据结果交换两个数字的位置”这一操作的算法。 每一轮操作（比较和交换）都会有一个最大值移到右端。 在这个过程中，数字会像泡泡一样，慢慢从左往右“浮”到序列的一端，所以这个算法才被称为“冒泡排序”。 通过一遍遍扫描，表的最后将积累起越来越多排好顺序的大元素。 每遍扫描，这段元素增加一个，经过 n-1 遍扫描，一定能完成排序。 此外，做一遍，扫描的范围可以缩短一项。 把这些考虑综合起来就得到了下面的算法： 12345678910def bubble_sort(lst): for i in range(len(lst)): for j in range(1,len(lst)-i): if lst[j-1] &gt; lst[j]: lst[j-1],lst[j] = lst[j], lst[j-1] l=[-1,26,5,77,1,61,11,59,15,48,19] bubble_sort(l)print(l) 改进 虽然有时起泡排序确实需要做满 n-1 遍，但那是特例，只有被排序表的最小元素恰好在最后时才会出现这种情况。 在其他情况下，扫描就不需要做那么多次，如果发现排序已经完成就可以及早结束。 如果在一次扫描中没遇到逆序，就说明排序工作已经完成， 可以提前结束了。 12345678910111213def bubble_sort(lst): for i in range(len(lst)): found = False for j in range(1,len(lst)-i): if lst[j-1] &gt; lst[j]: lst[j-1],lst[j] = lst[j], lst[j-1] found = True #有逆序 if not found:# 如果没有逆序 break #可以跳出循环结束了 l=[-1,26,5,77,1,61,11,59,15,48,19] bubble_sort(l)print(l) 归并排序 归并排序算法会把序列分成长度相同的两个子序列，当无法继续往下分时（也就是每个子序列中只有一个数据时），就对子序列进行归并。归并指的是把两个排好序的子序列合并成一个有序序列。该操作会一直重复执行，直到所有子序列都归并为一个整体为止。 归并排序中，分割序列所花费的时间不算在运行时间内（可以当作序列本来就是分割好的）。在合并两个已排好序的子序列时，只需重复比较首位数据的大小，然后移动较小的数据，因此只需花费和两个子序列的长度相应的运行时间。 也就是说，完成一行归并所需的运行时间取决于这一行的数据量。 无论哪一行都是n个数据，所以每行的运行时间都为 O(n)。 而将长度为 n 的序列对半分割直到只有一个数据为止时，可以分成\(log_2n\)行，因此，总 共有\(log_2n\)行。也就是说，总的运行时间为 O(nlogn) 123456789101112131415161718192021222324252627282930def mergesort(lst): if len(lst) &lt;= 1: return lst mid = len(lst)//2 # 将列表分成更小的两个列表 # 分别对左右两个列表进行处理，分别返回两个排序好的列表 left = mergesort(lst[:mid]) right = mergesort(lst[mid:]) # 对排序好的两个列表合并，产生一个新的排序好的列表 return merge(left, right)def merge(left, right): res = [] i = 0 j = 0 # 对两个列表中的元素 两两对比。 # 将最小的元素，放到res中 while i&lt;len(left) and j&lt;len(right): if left[i] &lt;= right[j]: res.append(left[i]) i += 1 else: res.append(right[j]) j += 1 res += left[i:] res += right[j:] return res l=[-1,26,5,77,1,61,11,59,15,48,19] res = mergesort(l)print(res) 快速排序 快速排序算法首先会在序列中随机选择一个基准值（pivot），然后将除了基准值以外的数分为“比基准值小的数”和“比基准值大的数”这两个类别，再将其排列成以下形式。 [ 比基准值小的数 ] 基准值 [ 比基准值大的数 ] 接着，对两个“[ ]”中的数据进行排序之后，整体的排序便完成了。对“[ ]”里面的数据进行排序时同样也会使用快速排序(递归)。 123456789101112131415161718192021222324def qsort_rec(lst, l, r): if l&gt;=r: return i = l j = r pivot = lst[i] while i&lt;j: # 找pivot的最终位置 while i&lt;j and lst[j]&gt;=pivot: j -= 1 # 用j向左扫描找小于pivot的记录 if i&lt;j: lst[i] = lst[j] i += 1 # 小记录移到左边 while i&lt;j and lst[i]&lt;pivot: i += 1 if i&lt;j: lst[j] = lst[i] j -= 1 lst[i] = pivot qsort_rec(lst, l, i-1) # 递归处理左半区间 qsort_rec(lst, i+1, r) # 递归处理左右半区间 l=[-1,26,5,77,1,61,11,59,15,48,19] qsort_rec(l,0,len(l)-1)print(l) 时间复杂度\(O(nlogn)\) 改进 1234567891011121314151617def quick_sort1(lst): def qsort(lst, begin,end): if begin &gt;= end: return pivot = lst[begin] i = begin for j in range(begin+1, end+1): if lst[j] &lt; pivot: i += 1 lst[i],lst[j] = lst[j],lst[i] lst[begin],lst[i] = lst[i], lst[begin] qsort(lst, begin, i-1) qsort(lst,i+1, end) qsort(lst,0,len(lst)-1)l=[-1,26,5,77,1,61,11,59,15,48,19] quick_sort1(l)print(l) LeetCode 215. 数组中的第K个最大元素 在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。 示例 1: 12输入: [3,2,1,5,6,4] 和 k = 2输出: 5 示例 2: 12输入: [3,2,3,1,2,4,5,5,6] 和 k = 4输出: 4 说明: 你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。 方法：快速排序中选择 1234567891011121314151617181920class Solution: def findKthLargest(self, nums: List[int], k: int) -&gt; int: def qsort(lst, begin,end): if begin &gt;= end: return pivot = lst[begin] i = begin for j in range(begin+1, end+1): if lst[j] &gt; pivot: i += 1 lst[i],lst[j] = lst[j],lst[i] lst[begin],lst[i] = lst[i], lst[begin] if i&gt;k-1: qsort(lst, begin, i-1) elif i&lt;k-1: qsort(lst,i+1, end) else: return qsort(nums,0,len(nums)-1) return nums[k-1] 方法改进 123456789101112131415import randomclass Solution: def findKthLargest(self, nums, k): pivot = random.choice(nums) nums1, nums2 = [], [] for num in nums: if num &gt; pivot: nums1.append(num) elif num &lt; pivot: nums2.append(num) if k &lt;= len(nums1): return self.findKthLargest(nums1, k) if k &gt; len(nums) - len(nums2): return self.findKthLargest(nums2, k - (len(nums) - len(nums2))) return pivot 参考 《数据结构(C++语言版)》 Python Data Structures - C2 Sort python归并排序–递归实现]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>LeetCode</tag>
        <tag>数据结构</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[递归算法(python实现)]]></title>
    <url>%2F2019%2F03%2F02%2F%E9%80%92%E5%BD%92(python)%2F</url>
    <content type="text"><![CDATA[在函数的定义中对这个函数自身的调用，就是递归。 递归结构中，递归的部分必须比原来的整体简单，才有可能到达某种终结点(出口)。而且必须存在非递归的基本结构构成的部分，否则会无限递归。 学习目标： 编程实现斐波那契数列求值 f(n)=f(n-1)+f(n-2) 编程实现求阶乘 n! 编程实现一组数据集合的全排列 LeetCode 46. 全排列 LeetCode 47. 全排列 II LeetCode 70. 爬楼梯 以上问题都可以用递归来解决。 斐波那契数列求值 f(n)=f(n-1)+f(n-2) 斐波那契数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。 [0,1,1,2,3,5,8,13,...] 给定n,计算 f(N) 对应LeetCode习题：509. Fibonacci Number 方法 12345class Solution: def fib(self, N: int) -&gt; int: if N &lt;= 1: return N return self.fib(N-1) + self.fib(N-2) 动态规划方法参见：动态规划 求阶乘 n! 12345678def factorial(n): if n == 0 or n == 1: return 1 else: return (n*factorial(n-1))a = factorial(3)print(a) 输出：6 LeetCode 46. 全排列 Permutations 给定一个没有重复数字的序列，返回其所有可能的全排列。 示例 输入: [1,2,3] 输出: [ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]] 方法 每次选择一个数出来，然后把剩下的数，再选择一个出来，依次类推，选到头，就回溯到上一层。 1234567891011class Solution: def permute(self, nums: List[int]) -&gt; List[List[int]]: res = [] def dfs(nums = nums, path = []): if not nums: res.append(path) for i in range(len(nums)): dfs(nums[:i]+nums[i+1:], path+[nums[i]]) dfs() return res LeetCode 47. 全排列 II Permutations II 给定一个可包含重复数字的序列，返回所有不重复的全排列。 示例: 输入: [1,1,2] 输出: [ [1, 1, 2], [1, 2, 1], [2, 1, 1] ] 方法 相比上一题，多了排序和内部的重复判断。 1234567891011121314class Solution: def permuteUnique(self, nums: List[int]) -&gt; List[List[int]]: nums.sort() res = [] def dfs(nums = nums, path=[]): if not nums: res.append(path) for i in range(len(nums)): if i&gt;0 and nums[i] == nums[i-1]: continue dfs(nums[:i]+nums[i+1:], path+[nums[i]]) dfs() return res LeetCode 70. 爬楼梯 Climbing Stairs 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 注意：给定 n 是一个正整数。 示例 ： 123456输入： 3输出： 3解释： 有三种方法可以爬到楼顶。1. 1 阶 + 1 阶 + 1 阶2. 1 阶 + 2 阶3. 2 阶 + 1 阶 方法：递归 当有n个台阶时，可供选择的走法可以分两类：1，先跨一阶再跨完剩下n-1阶；2，先跨2阶再跨完剩下n-2阶。所以n阶的不同走法的数目是n-1阶和n-2阶的走法数的和。 这和斐波那契数列的规律相同，可以用这个思路。 123456789class Solution: def climbStairs(self, n): """ :type n: int :rtype: int """ if n&lt;=2: return n return self.climbStairs(n-1) + self.climbStairs(n-2) 这个方法运行正常，但是因为超出时间限制，未能通过。 方法：动态规划 动态规划来记录历史数据。 12345678910class Solution: def climbStairs(self, n): """ :type n: int :rtype: int """ prev, current = 0, 1 for i in range(n): prev, current = current, prev + current return current]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>LeetCode</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python实现数据结构中的队列]]></title>
    <url>%2F2019%2F03%2F01%2Fpython-algo-queue%2F</url>
    <content type="text"><![CDATA[队列中的数据呈线性排列。与栈类似，队列中可以操作数据的位置也有一定的限制。在栈中，数据的添加和删除都在同一端进行，而在队列中则分别是在两端进行的。队列也不能直接访问位于中间的数据，必须通过出队操作将目标数据变成首位后才能访问。 像队列这种最先进去的数据最先被取来，即“先进先出”的结构，我们称为 First In First Out，简称 FIFO。 “先来的数据先处理”是一种很常见的思路，所以队列的应用范围非常广泛。比如广度优先搜索算法，通常就会从搜索候补中选择最早的数据作为下一个顶点。此时，在候补顶点的管理上就可以使用队列。 学习目标： - 用数组实现一个顺序队列 - 用链表实现一个链式队列 - 实现一个循环队列 - LeetCode 641. 设计循环双端队列 - LeetCode 239. 滑动窗口最大值 用数组实现一个顺序队列 list表头入队，表尾出队。反过来也可以。 实现的基本操作有： - enqueue 入队，要把表中其余元素全部后移，再插入首元素，需要 \(O(n)\)时间 - dequeue 出队,\(O(1)\) 1234567891011121314class Queue: def __init__(self): self.items = [] def enqueue(self, item): # 入队 self.items.insert(0,item) def dequeue(self): # 出队 return self.items.pop() if __name__ == '__main__': q = Queue() q.enqueue(4) q.enqueue(5) q.enqueue(6) print(q.dequeue()) 输出： 14 用链表实现一个链式队列 等同于用带表尾指针的单链表。链尾入队，链首出队。 实现的基本操作有： - enqueue 入队 \(O(1)\) - dequeue 出队 \(O(1)\) - peek 查看队首元素 \(O(1)\) 123456789101112131415161718192021222324252627282930313233343536class Node: # 链表的结点 def __init__(self, x, next_=None): self.val = x self.next = next_class LQueue: # def __init__(self): # 空表 self._head = None self._rear = None # 尾结点 def enqueue(self, x): # 入队 if self._head is None: self._head = Node(x, self._head) self._rear = self._head else: self._rear.next = Node(x) self._rear = self._rear.next def dequeue(self): # 出队 if self._head is None: return x = self._head.val self._head = self._head.next return x def peek(self): # 查看最早入队的元素 if self._head is None: return return self._head.val if __name__ == '__main__': l = LQueue() l.enqueue(4) l.enqueue(5) print(l.peek()) l.enqueue(6) l.dequeue() print(l.peek()) 输出： 1245 实现一个循环队列 LeetCode 622 队头变量_head记录当前队列的第一个元素位置 1234567891011121314151617181920212223242526272829303132333435363738394041class QueueUnderflow(ValueError):# 空队列无法 dequeue的异常错误 passclass SQueue: def __init__(self, init_len=8): self._elems = [0]*init_len # 队列元素 self._head = 0 # 队列首元素位置的下标 self._num = 0 # 表中元素个数 self._len = init_len # 当前表的长度，表满了的话，要换一个存储表 def peek(self): if self._num == 0: # 队空状态 raise QueueUnderflow return self._elems[self._head] def dequeue(self): if self._num == 0: # 队空状态 raise QueueUnderflow e = self._elems[self._head] self._head = (self._head+1) % self._len self._num -= 1 return e def enqueue(self, e): if self._num == self._len: # 队满状态 self.__extend() # 扩大存储区 # 新元素的入队位置 self._elems[(self._head + self._num) % self._len]=e self._num += 1 def __extend(self): # 扩容 old_len = self._len self._len *= 2 new_elems = [0] * self._len for i in range(old_len): new_elems[i] = self._elems[(self._head + i)%old_len] self._elems, self._head = new_elems, 0 if __name__ == '__main__': l = SQueue() for i in range(10): l.enqueue(i+1) print(l.peek()) l.dequeue() print(l.peek()) LeetCode 641. 设计循环双端队列 Design Circular Deque 设计实现双端队列。 你的实现需要支持以下操作： MyCircularDeque(k)：构造函数,双端队列的大小为k。 insertFront()：将一个元素添加到双端队列头部。 如果操作成功返回 true。 insertLast()：将一个元素添加到双端队列尾部。如果操作成功返回 true。 deleteFront()：从双端队列头部删除一个元素。 如果操作成功返回 true。 deleteLast()：从双端队列尾部删除一个元素。如果操作成功返回 true。 getFront()：从双端队列头部获得一个元素。如果双端队列为空，返回 -1。 getRear()：获得双端队列的最后一个元素。 如果双端队列为空，返回 -1。 isEmpty()：检查双端队列是否为空。 isFull()：检查双端队列是否满了。 示例： 12345678910MyCircularDeque circularDeque = new MycircularDeque(3); // 设置容量大小为3circularDeque.insertLast(1); // 返回 truecircularDeque.insertLast(2); // 返回 truecircularDeque.insertFront(3); // 返回 truecircularDeque.insertFront(4); // 已经满了，返回 falsecircularDeque.getRear(); // 返回 2circularDeque.isFull(); // 返回 truecircularDeque.deleteLast(); // 返回 truecircularDeque.insertFront(4); // 返回 truecircularDeque.getFront(); // 返回 4 提示： 所有值的范围为 [1, 1000] 操作次数的范围为 [1, 1000] 请不要使用内置的双端队列库。 方法 和上一题思路相同，用一个list实现类似的环形列表。 双向链表可以从头尾插入元素，对应了list的insert和append方法。注意，无论是在头尾插入，要移动的指针都是rear。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495class MyCircularDeque: def __init__(self, k: int): """ Initialize your data structure here. Set the size of the deque to be k. """ self._elems = [0]*k # 队列元素 self._head = 0 # 队列首元素位置的下标 self._num = 0 # 表中元素个数 self._len = k # 表的长度 def insertFront(self, value: int) -&gt; bool: """ Adds an item at the front of Deque. Return true if the operation is successful. """ if self._num == self._len: # 队满状态 return False # 新元素的入队位置 self._head = (self._head + self._len - 1) % self._len self._elems[self._head]= value self._num += 1 return True def insertLast(self, value: int) -&gt; bool: """ Adds an item at the rear of Deque. Return true if the operation is successful. """ if self._num == self._len: # 队满状态 return False # 新元素的入队位置 self._elems[(self._head + self._num) % self._len]= value self._num += 1 return True def deleteFront(self) -&gt; bool: """ Deletes an item from the front of Deque. Return true if the operation is successful. """ if self._num == 0: # 队空状态 return False # e = self._elems[self._head] self._head = (self._head+1) % self._len self._num -= 1 return True def deleteLast(self) -&gt; bool: """ Deletes an item from the rear of Deque. Return true if the operation is successful. """ if self._num == 0: # 队空状态 return False # e = self._elems[(self._head + self._num-1) % self._len] self._num -= 1 return True def getFront(self) -&gt; int: """ Get the front item from the deque. """ if self._num == 0: # 队空状态 return -1 return self._elems[self._head] def getRear(self) -&gt; int: """ Get the last item from the deque. """ if self._num == 0: # 队空状态 return -1 return self._elems[(self._head + self._num-1) % self._len] def isEmpty(self) -&gt; bool: """ Checks whether the circular deque is empty or not. """ return self._num == 0 def isFull(self) -&gt; bool: """ Checks whether the circular deque is full or not. """ return self._len == self._num# Your MyCircularDeque object will be instantiated and called as such:# obj = MyCircularDeque(k)# param_1 = obj.insertFront(value)# param_2 = obj.insertLast(value)# param_3 = obj.deleteFront()# param_4 = obj.deleteLast()# param_5 = obj.getFront()# param_6 = obj.getRear()# param_7 = obj.isEmpty()# param_8 = obj.isFull() LeetCode 239. 滑动窗口最大值 Sliding Window Maximum 方法：deque（双端队列） 遍历数组nums，使用双端队列deque维护滑动窗口内有可能成为最大值元素的数组下标。 当下标i从队尾入队时，顺次弹出队列尾值&lt;=nums[i]的数组下标。 当前下标为i，则滑动窗口的有效下标范围为[i - (k - 1), i] ,所以当队头元素dq[0] == i-k，就要从队头出队。 12345678910111213class Solution: def maxSlidingWindow(self, nums: List[int], k: int) -&gt; List[int]: dq = collections.deque() # 队列 res = [] for i in range(len(nums)): while dq and nums[dq[-1]] &lt;= nums[i]:#(循环)当dq队尾值小于新元素nums[i] dq.pop() #队尾值出队(直到dq中的值都大于新元素nums[i]) dq.append(i) #新元素入队 if dq[0] == i-k: # 窗口滑出，队头元素不在窗口区域内 dq.popleft() # 队头值出队 if i &gt;= k-1: # i遍历到一个窗口大小之后，每轮都能执行此行。 res.append(nums[dq[0]]) #窗口最大元素 return res 参考 《我的第一本算法书》 [LeetCode]Sliding Window Maximum]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>LeetCode</tag>
        <tag>数据结构</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python实现数据结构中的栈]]></title>
    <url>%2F2019%2F03%2F01%2Fpython_leetcode-stack(0)%2F</url>
    <content type="text"><![CDATA[栈是一种数据呈线性排列的、后入先出（LIFO，last-in-first-out）的数据结构。不过在这种结构中，我们只能访问最新添加的数据。添加移除新项总发生在同一端。这一端通常称为“顶部”。与顶部对应的端称为“底部”。 栈的底部很重要，因为在栈中靠近底部的项是存储时间最长的。最近添加的项是最先会被移除的。 对栈的两种主要操作是将一个元素压入栈和将一个元素弹出栈。入栈使用push()方法，出栈使用pop()方法。 在栈的应用上，比如深度优先搜索算法，通常会选择最新的数据作为候补顶点。在候补顶点的管理上就可以使用栈。 学习目标： 用数组实现一个顺序栈 用链表实现一个链式栈 编程模拟实现一个浏览器的前进、后退功能 最小栈 LeetCode 20. 有效的括号 LeetCode 32. 最长有效的括号 LeetCode 150. 逆波兰表达式求值 下一个更大元素 I 下一个更大元素 II 接雨水 用数组实现一个顺序栈 假定数组的结尾作为栈顶，后端插入和删除是 O(1) 操作。 栈有如下基本操作： - Stack() 创建一个空的新栈。 返回一个空栈。 - push(item)将一个新项添加到栈的顶部。它需要 item 做参数并不返回任何内容。 - pop() 从栈中删除顶部项。它返回 item 。栈被修改。 - top() 从栈返回顶部项，但不会删除它。不修改栈。 - isEmpty() 测试栈是否为空。返回布尔值。 - size() 返回栈中的 item 数量。返回一个整数。 1234567891011121314151617181920212223242526class SStack: def __init__(self): self.items = [] def isEmpty(self): return self.items == [] # return not self.items def push(self,item): self.items.append(item) def pop(self): return self.items.pop() def top(self): if self.items: return self.items[-1] else: return None def size(self): return len(self.items) if __name__ == "__main__": s = SStack() s.push('a') print(s.top()) s.push('b') s.push('c') print(s.pop()) 输出： 12ac 数组实现的缺点： 需要完整的大块存储空间 扩大存储的操作代价高 而用链表实现就没有以上的问题。 用链表实现一个链式栈 对于链接表，将表头作为栈顶，在前端插入和删除都是 O(1) 操作。 123456789101112131415161718192021222324252627282930class Node: # 链表的结点 def __init__(self, x, next_=None): self.val = x self.next = next_class LStack: #栈的链接表实现 def __init__(self): self._top = None def isEmpty(self): return self._top is None def push(self,item): self._top = Node(item, self._top) def pop(self): p = self._top self._top = p.next return p.val def top(self): if self._top: return self._top.val else: return None if __name__ == "__main__": s = LStack() s.push('a') print(s.top()) s.push('b') s.push('c') print(s.pop()) 输出： 12ac 编程模拟实现一个浏览器的前进、后退功能 每个 web 浏览器都有一个返回按钮。当你浏览网页时，这些网页被放置在一个栈中（实际是网页的网址）。你现在查看的网页在顶部，你第一个查看的网页在底部。如果按‘返回’按钮，将按相反的顺序浏览刚才的页面。 123456789101112131415161718192021222324252627282930313233343536class Page: # 一个网页 def __init__(self, url, prev_=None, next_=None): self.val = url self.next = next_ self.prev = prev_class History: def __init__(self): self._cur = Page(None) def loadPage(self, newPage): #加载新的页面 p = Page(newPage,self._cur,None) self._cur.next = p self._cur = self._cur.next return self._cur.val def back(self): #返回上一页面 if self._cur.prev is None: return self._cur = self._cur.prev return self._cur.val def forward(self): #前进页面 if self._cur.next is None: return self._cur = self._cur.next return self._cur.val if __name__ == '__main__': h = History() print('加载页面'+ h.loadPage('a')) print('加载页面'+ h.loadPage('b')) print('返回到'+ h.back()) print('加载页面'+ h.loadPage('c')) print('返回到'+ h.back()) print('前进到'+ h.forward()) 输出： 123456加载页面a加载页面b返回到a加载页面c返回到a前进到c 155. 最小栈 设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。 push(x) – 将元素 x 推入栈中。 pop() – 删除栈顶的元素。 top() – 获取栈顶元素。 getMin() – 检索栈中的最小元素。 示例: 12345678MinStack minStack = new MinStack();minStack.push(-2);minStack.push(0);minStack.push(-3);minStack.getMin(); --&gt; 返回 -3.minStack.pop();minStack.top(); --&gt; 返回 0.minStack.getMin(); --&gt; 返回 -2. 方法 这个题要求在常数时间内获得最小值，因此不能在getMin()的时候再去计算，应该在push的时候就计算了。 可以用一个栈，这个栈保存的是每个数字进入栈的时候的（值与最小值）。速度很快。 12345678910111213141516171819202122232425262728class MinStack: def __init__(self): """ initialize your data structure here. """ self.stack = [] def push(self, x: int) -&gt; None: if not self.stack: self.stack.append((x, x)) else: self.stack.append((x, min(x, self.stack[-1][1]))) def pop(self) -&gt; None: self.stack.pop() def top(self) -&gt; int: return self.stack[-1][0] def getMin(self) -&gt; int: return self.stack[-1][1]# Your MinStack object will be instantiated and called as such:# obj = MinStack()# obj.push(x)# obj.pop()# param_3 = obj.top()# param_4 = obj.getMin() LeetCode 20. 有效的括号 Valid Parentheses 给定一个只包括 ‘(’，‘)’，‘{’，‘}’，‘[’，’]’ 的字符串，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 注意空字符串可被认为是有效字符串。 示例 1: 12输入: &quot;()[]&#123;&#125;&quot;输出: true 示例 2: 12输入: &quot;([)]&quot;输出: false 示例 3: 12输入: &quot;&#123;[]&#125;&quot;输出: true 方法 先建立一个map 遍历字符串，对输入的字符串入栈操作（如果入栈的元素是key的话） 依次比较，直到出现不匹配或者栈里所有元素都比较结束(栈空)。 还要注意这样的问题：如果最后多余了’key‘，比如()(，所以最后还要判断一下len(stack)==0 1234567891011121314151617181920212223class Solution: def isValid(self, s): """ :type s: str :rtype: bool """ stack = list() match = &#123;'&#123;':'&#125;', '[':']', '(':')'&#125; for i in s: if i in match: stack.append(i) else: if len(stack) == 0: return False if match[stack[-1]] != i: return False stack.pop() if len(stack) != 0: return False return True LeetCode 32. 最长有效的括号 Longest Valid Parentheses 给定一个只包含 ‘(’ 和 ‘)’ 的字符串，找出最长的包含有效括号的子串的长度。 示例 1: 123输入: &quot;(()&quot;输出: 2解释: 最长有效括号子串为 &quot;()&quot; 示例 2: 123输入: &quot;)()())&quot;输出: 4解释: 最长有效括号子串为 &quot;()()&quot; 方法 用一个栈来存储左括号的索引. 遇到正确匹配的括号则弹出匹配的索引，所以栈中存储的是未匹配上的左括号。 新匹配上的括号位置减去前一段未匹配到的括号的索引的差，是当前有效子串的大小。 123456789101112131415161718192021class Solution: def longestValidParentheses(self, s: str) -&gt; int: maxlen = 0 # 最长的字串长度 last = -1 # 上一段有效子串的结尾位置 stack = [] # 栈里存放左括号的位置序号 for i in range(len(s)): if s[i] == '(': stack.append(i) # 存入左括号的位置序号 else:# 右括号 if stack == []: # 栈空 last = i # 配对失败，一段有效子串结尾 else: stack.pop() #取出配对左括号 if stack == []: # 配对完，栈空 #当前位置i减去上一段结尾last，是这一段有效子串的长度 maxlen = max(maxlen, i-last) else: # stack剩余的左括号未必能配对成功，先比较当前的有效子串 maxlen= max(maxlen, i - stack[-1]) return maxlen LeetCode 150. 逆波兰表达式求值 Evaluate Reverse Polish Notatio 根据逆波兰表示法，求表达式的值。 有效的运算符包括 +, -, *, / 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。 说明： 整数除法只保留整数部分。 给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。 示例 1： 123输入: [&quot;2&quot;, &quot;1&quot;, &quot;+&quot;, &quot;3&quot;, &quot;*&quot;]输出: 9解释: ((2 + 1) * 3) = 9 示例 2： 123输入: [&quot;4&quot;, &quot;13&quot;, &quot;5&quot;, &quot;/&quot;, &quot;+&quot;]输出: 6解释: (4 + (13 / 5)) = 6 方法 逆波兰式（Reverse Polish notation，RPN，或逆波兰记法），也叫后缀表达式（将运算符写在操作数之后） python 有个函数eval()，可以给它一个运算表达式，直接给你求值。中缀表达式转正常表达式很简单了，直接用栈就行。 但需要注意的是，python中的’/’负数除法和c语言不太一样。在python中，(-1)/2=-1，而在c语言中，(-1)/2=0。也就是c语言中，除法是向零取整，即舍弃小数点后的数。而在python中，是向下取整的。而这道题的oj是默认的c语言中的语法，所以需要在遇到’/’的时候注意一下。 可采用的方式是使用operator.truediv(int(a), int(b))变成和c相同的方式。 1234567891011121314151617class Solution: def evalRPN(self, tokens: List[str]) -&gt; int: stack = [] operators = ['+', '-','*','/'] for token in tokens: if token not in operators: stack.append(token) else: b = stack.pop() a = stack.pop() if token == '/': res = int(operator.truediv(int(a), int(b))) else: res = eval(a+token+b) stack.append(str(res)) return int(stack.pop()) 496. 下一个更大元素 I 给定两个没有重复元素的数组 nums1 和 nums2 ，其中nums1 是 nums2 的子集。找到 nums1 中每个元素在 nums2 中的下一个比其大的值。 nums1 中数字 x 的下一个更大元素是指 x 在 nums2 中对应位置的右边的第一个比 x 大的元素。如果不存在，对应位置输出-1。 示例 1: 123456输入: nums1 = [4,1,2], nums2 = [1,3,4,2].输出: [-1,3,-1]解释: 对于num1中的数字4，你无法在第二个数组中找到下一个更大的数字，因此输出 -1。 对于num1中的数字1，第二个数组中数字1右边的下一个较大数字是 3。 对于num1中的数字2，第二个数组中没有下一个更大的数字，因此输出 -1。 示例 2: 12345输入: nums1 = [2,4], nums2 = [1,2,3,4].输出: [3,-1]解释: 对于num1中的数字2，第二个数组中的下一个较大数字是3。 对于num1中的数字4，第二个数组中没有下一个更大的数字，因此输出 -1。 注意: nums1和nums2中所有元素是唯一的。 nums1和nums2 的数组大小都不超过1000。 方法一 先从nums2中找到对应的nums1数值的序号，然后从这个序号往又找，看有没有比nums1数字大的。 如果有，把这个数字放到结果里；如果没有，就把-1放到结果里。 1234567891011121314151617class Solution: def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -&gt; List[int]: ans = [] l2 = len(nums2) for x in nums1: index = -1 for i in range(l2): if x == nums2[i]: index = i #找到对应相同的元素 break while index &lt; l2 and x &gt;= nums2[index]: index += 1 if index == l2: ans.append(-1) else: ans.append(nums2[index]) return ans 方法二：单调递减栈 时间复杂度O(n + m) 其中n为nums的长度，m为findNums的长度 栈stack维护nums的递减子集，记nums的当前元素为n，栈顶元素为top 重复弹出栈顶，直到stack为空，或者top大于n为止 将所有被弹出元素的next greater element置为n 123456789class Solution: def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -&gt; List[int]: dmap = &#123;&#125; #存放对应元素的答案 stack = [] for n in nums2: while stack and stack[-1] &lt; n: dmap[stack.pop()] = n stack.append(n) return [dmap.get(x, -1) for x in nums1] 503. 下一个更大元素 II 给定一个循环数组（最后一个元素的下一个元素是数组的第一个元素），输出每个元素的下一个更大元素。数字 x 的下一个更大的元素是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1。 示例 1: 12345输入: [1,2,1]输出: [2,-1,2]解释: 第一个 1 的下一个更大的数是 2；数字 2 找不到下一个更大的数； 第二个 1 的下一个最大的数需要循环搜索，结果也是 2。 注意: 输入数组的长度不会超过 10000。 单调递减栈 对于循环数组的处理，将nums数组遍历两次，栈里保存的是索引, 下标对len(nums)取模 1234567891011class Solution: def nextGreaterElements(self, nums: List[int]) -&gt; List[int]: stack = [] size = len(nums) ans = [-1] * size for x in range(size * 2): i = x % size while stack and nums[stack[-1]] &lt; nums[i]: ans[stack.pop()] = nums[i] stack.append(i) return ans 42. 接雨水 Trapping Rain Water 给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。 示例: 12输入: [0,1,0,2,1,0,1,3,2,1,2,1]输出: 6 方法: 单调递增栈 如果出现一个元素比栈顶元素大的话，那么此时必然可以形成凹槽，此时我们只需要计算凹槽长度和边界的高度差那么必然可以计算出接水的面积。 12345678910111213class Solution: def trap(self, height: List[int]) -&gt; int: if len(height)&lt;3: return 0 res=0 stack = list() for i in range(len(height)): while stack and height[stack[-1]] &lt; height[i]: tmp = stack.pop() if stack: res += (min(height[i],height[stack[-1]])-height[tmp]) * (i-stack[-1]-1) stack.append(i) return res 参考 problem-solving-with-algorithms-and-data-structure-using-python How does the Back button in a web browser work? 【LeetCode】150. Evaluate Reverse Polish Notation 解题报告（Python） Leetcode 42：接雨水（超详细的解法！！！）]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>LeetCode</tag>
        <tag>数据结构</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python实现数据结构中的数组]]></title>
    <url>%2F2019%2F02%2F28%2Fpython_leetcode_array(0)%2F</url>
    <content type="text"><![CDATA[在数组中，访问数据十分简单，而添加和删除数据比较耗工夫。 由于数组中的数据是存储在连续空间内的，所以每个数据的内存地址（在内存上的位置）都可以通过数组下标算出，我们也就可以借此直接访问目标数据（这叫作“随机访问”），需要的运行时间仅为恒定的 O(1)。 向数组中添加新数据时，必须把目标位置后面的数据一个个移开。所以，如果在数组头部添加数据，就需要O(n)的时间。删除操作同理。 学习目标： 实现一个支持动态扩容的数组 实现一个大小固定的有序数组，支持动态增删改操作 Leetcode 88. 合并两个有序数组 Leetcode 1. 两数之和 三数之和 最接近的三数之和 支持动态扩容的数组 类似于Python的简化版list 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import ctypes class DynamicArray: def __init__(self): """ Create an empty array.""" self._n = 0 #count actual elements self._capacity = 1 #default array capacity self._A = self._make_array(self._capacity) #low-level array def __len__(self): """Return number of elements stored in the array.""" return self._n def __getitem__(self,k): """Return element at index k.""" if not 0 &lt;= k &lt; self._n: raise IndexError('invalid index') return self._A[k] #retrieve from array def append(self, obj): """Add object to end of the array.""" if self._n == self._capacity: # not enough room self._resize(2*self._capacity) #so double capacity self._A[self._n] = obj self._n += 1 def _resize(self, c): # nonpublic utitity """Resize internal array to capacity c.""" B = self._make_array(c) # new (bigger) array for k in range(self._n): # for each existing value B[k] = self._A[k] self._A = B self._capacity = c def _make_array(self, c): # nonpublic utitity """Return new array with capacity c.""" return (c * ctypes.py_object)() # see ctypes documentation if __name__ == '__main__': da = DynamicArray() da.append(6) da.append(2) for o in da: print(o) 输出： 1262 大小固定的有序数组，支持动态增删改操作 123456789101112131415161718192021222324252627282930313233343536373839404142class NewArray: """ A dynamic array class akin to a simplified Python list.""" def __init__(self,capacity=10): """ Create an empty array.""" self._n = 0 #数组大小 self._A = [None] * capacity def __getitem__(self,k): """Return element at index k.""" if not 0 &lt;= k &lt; self._n: raise IndexError('invalid index') return self._A[k] #retrieve from array def insert(self,k,v): if k &gt;= len(self._A): raise IndexError('Index out of range!') for i in range(self._n, k-1, -1): self._A[i+1] = self._A[i] self._A[k] = v self._n += 1 def delete(self,k): v = self._A[k] for i in range(k+1,self._n): self._A[i-1] = self._A[i] self._n -= 1 return v def __setitem__(self,k,v): self._A[k] = v if __name__ == '__main__': A = NewArray() for i in range(5): A.insert(i, i) # 增 print(A[2]) A.delete(0) # 删 print(A[2]) A[0] = 10 # 改 print(A[0]) # 查 输出： 1232310 88. 合并两个有序数组 给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。 说明: 初始化 nums1 和 nums2 的元素数量分别为 m 和 n。 你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。 示例: 1234输入:nums1 = [1,2,3,0,0,0], m = 3nums2 = [2,5,6], n = 3输出: [1,2,2,3,5,6] 方法：遍历比较，大的放最后 从后往前遍历两个数组，然后把对应的元素放在数组1对应的位置， 注意：最后我们只需判断数组2有没有遍历完即可，因为数组1没有遍历完的话，它已经是按顺序放在前面的了。 12345678910111213141516171819class Solution(object): def merge(self, nums1, m, nums2, n): """ :type nums1: List[int] :type m: int :type nums2: List[int] :type n: int :rtype: void Do not return anything, modify nums1 in-place instead. """ while m&gt;0 and n&gt;0: if nums1[m-1] &gt; nums2[n-1]: nums1[m+n-1] = nums1[m-1] m -= 1 else: nums1[m+n-1] = nums2[n-1] n -= 1 if n&gt;0: nums1[:n] = nums2[:n] 1. 两数之和 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例: 123给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 方法：哈希表 利用python中的字典记录记录下每个元素出现的位置。key记差值，value记已有数值的位置。 12345678910111213141516class Solution(object): def twoSum(self, nums, target): """ :type nums: List[int] :type target: int :rtype: List[int] """ dic = dict() for index,value in enumerate(nums): sub = target - value if sub in dic: return [dic[sub], index] else: dic[value]=index 15. 三数之和 给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。 注意：答案中不可以包含重复的三元组。 1234567例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，满足要求的三元组集合为：[[-1, 0, 1],[-1, -1, 2]] 方法：排序，循环Two_Sum 12345678910111213141516171819202122class Solution: def threeSum(self, nums): """ :type nums: List[int] :rtype: List[List[int]] """ nums= sorted(nums) #排序 O(nlogn) output = set() for k in range(len(nums)): target = -nums[k] i, j = k + 1, len(nums)-1 while i &lt; j: sum_two = nums[i] + nums[j] if sum_two &lt; target: i += 1 elif sum_two &gt;target: j -= 1 else: output.add((nums[k], nums[i], nums[j])) i += 1 j -= 1 return list(set(output)) Time Complexity: O(n2) 16.最接近的三数之和 给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。 例如，给定数组 nums = [-1，2，1，-4], 和 target = 1. 与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2). 方法：排序，循环比较三种情况 等于，则返回 大于，则最后的指针-1 小于，则首位的指针+1 1234567891011121314151617181920212223242526class Solution: def threeSumClosest(self, nums, target): """ :type nums: List[int] :type target: int :rtype: int """ nums.sort() # 排序 n = len(nums) d = 2**32 ans = 0 for i in range(n-2): s, e = i+1, n-1 while s &lt; e: sum3 = nums[i]+nums[s]+nums[e] if sum3 == target: return target diff = abs(sum3 - target) if diff &lt; d: ans, d = sum3, diff if sum3 &gt; target: e -= 1 else: s += 1 return ans 参考 mplementation of Dynamic Array in Python 任务1-数组与链表]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>LeetCode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python解LeetCode链表(1)]]></title>
    <url>%2F2019%2F02%2F28%2Fpython_linklist(1)%2F</url>
    <content type="text"><![CDATA[链表是数据结构之一，其中的数据呈线性排列。 链表在前一结点里用链接的方式显示地记录与下一结点的关系。不同于数组，链表的元素的物理地址可以任意。 优点：插入、删除操作方便，不会导致元素的移动，因为元素增减，只需要调整指针。 空间大小可以随意扩大 缺点：只能通过顺次指针访问，查找不方便 学习目标： 实现单链表、循环链表、双向链表，支持增删操作。 实现单链表 只需要掌握这个表的首结点，从它出发可以找到这个表里的下一结点，以至于找到表里的所有数据元素。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061class Node: # 链表的结点 def __init__(self, x, next_=None): self.val = x self.next = next_class SingleLinkList: # 单链表 def __init__(self): # 空表 self.head = None #增 def insertAsFirst(self, x): #x在首位插入 node = Node(x) node.next = self.head self.head = node def insertAsLast(self, x): #x在尾部插入 if not self.head: self.head = Node(x) return cur = self.head while cur.next != None: cur = cur.next node = Node(x) cur.next = node #删 def remove(self, p):#删除在位置p处的结点，返回其数值 k = self.head for i in range(p-1): k = k.next x = k.next.val k.next = k.next.next return x def remove_last(self): #删除表尾的结点 p = self.head if p.next is None: x = p.val self.head = None return x while p.next.next is not None: # 直到 p.next 是最后结点 p = p.next x = p.next.val p.next = None return x def show(self): cur = self.head while cur != None: # cur是一个有效的节点 print(cur.val, end=' --&gt; ') cur = cur.next print() if __name__ == '__main__': l = SingleLinkList() for i in range(10): l.insertAsLast(i) l.show() l.remove_last() l.show() 输出： 10 --&gt; 1 --&gt; 2 --&gt; 3 --&gt; 4 --&gt; 5 --&gt; 6 --&gt; 7 --&gt; 8 --&gt; 9 --&gt; 双向链表 增加了反向的链接，结点操作更加方便。但是每个结点都需要增加一个链接域，增加的空间开销与结点数成正比，O(n) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465class DLNode: # 链表的结点 def __init__(self, x, prev=None, next_=None): self.val = x self.next = next_ self.prev = prevclass DoubleLinkList: # 双链表 def __init__(self): # 空表 self.head = None #增 def insertAsFirst(self, x): #x在首位插入 if not self.head: self.head = DLNode(x) else: node = DLNode(x,None,self.head) self.head.prev = node self.head = node # node 作为新的头结点 def insertAsLast(self, x): #x在尾部插入 if not self.head: self.head = DLNode(x) else: cur = self.head while cur.next != None: # 移动到链表尾部 cur = cur.next node = DLNode(x) cur.next = node node.prev = cur #删 def remove(self, p):#删除在位置p处的结点，返回其数值 k = self.head for i in range(p-1): k = k.next x = k.next.val k.next = k.next.next k.next.prev = k return x def show(self): cur = self.head while cur != None: # cur是一个有效的节点 print(cur.val, end=' -- ') cur = cur.next print() def show_reverse(self): cur = self.head while cur.next != None: cur = cur.next while cur != None: print(cur.val, end=' -- ') cur = cur.prev print() if __name__ == '__main__': l = DoubleLinkList() for i in range(10): l.insertAsLast(i) l.show() l.remove(2) l.show() l.show_reverse() 输出： 1230 -- 1 -- 2 -- 3 -- 4 -- 5 -- 6 -- 7 -- 8 -- 9 -- 0 -- 1 -- 3 -- 4 -- 5 -- 6 -- 7 -- 8 -- 9 -- 9 -- 8 -- 7 -- 6 -- 5 -- 4 -- 3 -- 1 -- 0 --]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>LeetCode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python解LeetCode数组(2)]]></title>
    <url>%2F2019%2F02%2F26%2Fpython_leetcode-array(2)%2F</url>
    <content type="text"><![CDATA[求众数 旋转数组 存在重复元素 存在重复元素 II 除自身以外数组的乘积 缺失数字 第三大的数 找到所有数组中消失的数字 最大连续1的个数 数组中的K-diff数对 数组拆分 I 重塑矩阵 最短无序连续子数组 169. 求众数 Majority Element 给定一个大小为 n 的数组，找到其中的众数。众数是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。 你可以假设数组是非空的，并且给定的数组总是存在众数。 示例 1: 12输入: [3,2,3]输出: 3 方法： 遍历 最多的元素出现的次数大于数组长度的一半，在最极端的情况下，最后的count都会大于0 12345678910111213141516171819class Solution(object): def majorityElement(self, nums): """ :type nums: List[int] :rtype: int """ count = 1 res = nums[0] for i in range(1, len(nums)): if nums[i] == res: count += 1 else: count -= 1 if count == 0: res = nums[i] count = 1 return res 189. 旋转数组 Rotate Array 题目描述 给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。 示例 1: 123456输入: [1,2,3,4,5,6,7] 和 k = 3输出: [5,6,7,1,2,3,4]解释:向右旋转 1 步: [7,1,2,3,4,5,6]向右旋转 2 步: [6,7,1,2,3,4,5]向右旋转 3 步: [5,6,7,1,2,3,4] 方法：直接拼接数组 123456789class Solution(object): def rotate(self, nums, k): """ :type nums: List[int] :type k: int :rtype: None Do not return anything, modify nums in-place instead. """ n = len(nums) nums[:] = nums[n-k:] + nums[:n-k] 217. 存在重复元素 Contains Duplicate 题目描述 给定一个整数数组，判断是否存在重复元素。 如果任何值在数组中出现至少两次，函数返回 true。如果数组中每个元素都不相同，则返回 false。 示例 1: 输入: [1,2,3,1] 输出: true 示例 2: 输入: [1,2,3,4] 输出: false 方法：set() 1234567class Solution(object): def containsDuplicate(self, nums): """ :type nums: List[int] :rtype: bool """ return len(nums) != len(set(nums)) 219. 存在重复元素 II Contains Duplicate II 题目描述 给定一个整数数组和一个整数 k，判断数组中是否存在两个不同的索引 i 和 j，使得 nums [i] = nums [j]，并且 i 和 j 的差的绝对值最大为 k。 示例 1: 输入: nums = [1,0,1,1], k = 1 输出: true 示例 2: 输入: nums = [1,2,3,1,2,3], k = 2 输出: false 方法 用dict保存数组元素出现的位置，两种情况下更新 1234567891011121314class Solution(object): def containsNearbyDuplicate(self, nums, k): """ :type nums: List[int] :type k: int :rtype: bool """ dic = dict() for index,value in enumerate(nums): if value in dic and index - dic[value] &lt;= k: return True dic[value] = index return False 238. 除自身以外数组的乘积 给定长度为 n 的整数数组 nums，其中 n &gt; 1，返回输出数组 output ，其中 output[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积。 示例: 12345输入: [1,2,3,4]输出: [24,12,8,6]12说明: 请不要使用除法，且在 O(n) 时间复杂度内完成此题。 方法 可以发现每个位置其实都是它前面所有数的乘积再乘上它后面所有数的乘积。按照这种想法建立返回数组，首先该数组中从第二个数开始每个数都是前面数的乘积，这样完成了第一步，其实此时数组中的最后一个数已经是返回值了。接下来从返回数组的倒数第二个数开始向前，每个返回值都是该数字（也就是nums中该数以前数的乘积）与nums该数字以后数字乘积的乘积。 12345678910111213class Solution: def productExceptSelf(self, nums: List[int]) -&gt; List[int]: temp = 1 res = [] res.append(1) for i in range(len(nums)-1): temp *= nums[i] res.append(temp) temp = 1 for i in range(len(nums)-2,-1,-1): temp *= nums[i+1] res[i] *= temp return res 268. 缺失数字 Missing Number 题目描述 给定一个包含 0, 1, 2, …, n 中 n 个数的序列，找出 0 .. n 中没有出现在序列中的那个数。 示例 1: 输入: [3,0,1] 输出: 2 示例 2: 输入: [9,6,4,2,3,5,7,0,1] 输出: 8 方法：数学公式 123456789class Solution(object): def missingNumber(self, nums): """ :type nums: List[int] :rtype: int """ n = len(nums) return n* (n+1)/2 - sum(nums) 移动零 Move Zeroes 题目描述 给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。 示例: 12输入: [0,1,0,3,12]输出: [1,3,12,0,0] 说明: 必须在原数组上操作，不能拷贝额外的数组。 尽量减少操作次数。 方法 遍历数组，用一个变量记录当前不为0的个数，同时也是新不为零元素插入的位置： 123456789101112class Solution: def moveZeroes(self, nums: List[int]) -&gt; None: """ Do not return anything, modify nums in-place instead. """ index = 0 for i in nums: if i != 0: nums[index]=i index += 1 for i in range(index,len(nums)): nums[i] = 0 414. 第三大的数 给定一个非空数组，返回此数组中第三大的数。如果不存在，则返回数组中最大的数。要求算法时间复杂度必须是O(n)。 示例 1: 12345输入: [3, 2, 1]输出: 1解释: 第三大的数是 1. 示例 2: 12345输入: [1, 2]输出: 2解释: 第三大的数不存在, 所以返回最大的数 2 . 示例 3: 123456输入: [2, 2, 3, 1]输出: 1解释: 注意，要求返回第三大的数，是指第三大且唯一出现的数。存在两个值为2的数，它们都排第二。 方法一 123456789101112class Solution: def thirdMax(self, nums: List[int]) -&gt; int: max1 = max2 = max3 = float('-inf') for num in nums: if num&gt;max1: max2,max3 = max1,max2 max1 = num elif num&gt;max2 and num &lt; max1: max2, max3 = num,max2 elif num&gt;max3 and num &lt; max2: max3 = num return max1 if max3==float('-inf') else max3 方法二 12345678class Solution: def thirdMax(self, nums: List[int]) -&gt; int: a=set(nums) if len(a)&lt;3: return max(a) else: a.remove(max(a)) a.remove(max(a)) return max(a) 448. 找到所有数组中消失的数字 给定一个范围在 1 ≤ a[i] ≤ n ( n = 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出现一次。 找到所有在 [1, n] 范围之间没有出现在数组中的数字。 您能在不使用额外空间且时间复杂度为O(n)的情况下完成这个任务吗? 你可以假定返回的数组不算在额外空间内。 示例: 12345输入:[4,3,2,7,8,2,3,1]输出:[5,6] 方法 注意到数组元素个数跟元素范围是一样的，所以我们可以把出现过的元素对应下标位置的数字变成负数，最后把所有正数对应的下标拿出来，就是缺失的数字。 123456class Solution: def findDisappearedNumbers(self, nums: List[int]) -&gt; List[int]: for i in range(len(nums)): index = abs(nums[i])-1 nums[index] = -abs(nums[index]) return [i+1 for i in range(len(nums)) if nums[i]&gt;0] 485. 最大连续1的个数 给定一个二进制数组， 计算其中最大连续1的个数。 示例 1: 123输入: [1,1,0,1,1,1]输出: 3解释: 开头的两位和最后的三位都是连续1，所以最大连续1的个数是 3. 注意： 输入的数组只包含 0 和1。 输入数组的长度是正整数，且不超过 10,000。 方法：遍历数组 1234567891011class Solution: def findMaxConsecutiveOnes(self, nums: List[int]) -&gt; int: cnt = 0 ans = 0 for num in nums: if num==1: cnt += 1 ans = max(ans,cnt) else: cnt = 0 return ans 532. 数组中的K-diff数对 给定一个整数数组和一个整数 k, 你需要在数组里找到不同的 k-diff 数对。这里将 k-diff 数对定义为一个整数对 (i, j), 其中 i 和 j 都是数组中的数字，且两数之差的绝对值是 k. 示例 1: 1234输入: [3, 1, 4, 1, 5], k = 2输出: 2解释: 数组中有两个 2-diff 数对, (1, 3) 和 (3, 5)。尽管数组中有两个1，但我们只应返回不同的数对的数量。 示例 2: 123输入:[1, 2, 3, 4, 5], k = 1输出: 4解释: 数组中有四个 1-diff 数对, (1, 2), (2, 3), (3, 4) 和 (4, 5)。 示例 3: 123输入: [1, 3, 1, 5, 4], k = 0输出: 1解释: 数组中只有一个 0-diff 数对，(1, 1)。 注意: 123数对 (i, j) 和数对 (j, i) 被算作同一数对。数组的长度不超过10,000。所有输入的整数的范围在 [-1e7, 1e7]。 方法 如果k大于0，则返回两个set的交集 如果k=0，则计数，找出出现1次以上的元素的个数 如果k小于0，返回0 12345678class Solution: def findPairs(self, nums: List[int], k: int) -&gt; int: if k&gt;0: return len(set(nums) &amp; set(num+k for num in nums)) elif k==0: return sum(v&gt;1 for v in collections.Counter(nums).values()) else: return 0 561. 数组拆分 I 给定长度为 2n 的数组, 你的任务是将这些数分成 n 对, 例如 (a1, b1), (a2, b2), …, (an, bn) ，使得从1 到 n 的 min(ai, bi) 总和最大。 示例 1: 1234输入: [1,4,3,2]输出: 4解释: n 等于 2, 最大总和为 4 = min(1, 2) + min(3, 4). 提示: n 是正整数,范围在 [1, 10000]. 数组中的元素范围在 [-10000, 10000]. 方法 返回排序后第1，3，5，。。2n-1小的数 123class Solution: def arrayPairSum(self, nums: List[int]) -&gt; int: return sum(sorted(nums)[::2]) 566. 重塑矩阵 在MATLAB中，有一个非常有用的函数 reshape，它可以将一个矩阵重塑为另一个大小不同的新矩阵，但保留其原始数据。 给出一个由二维数组表示的矩阵，以及两个正整数r和c，分别表示想要的重构的矩阵的行数和列数。 重构后的矩阵需要将原始矩阵的所有元素以相同的行遍历顺序填充。 如果具有给定参数的reshape操作是可行且合理的，则输出新的重塑矩阵；否则，输出原始矩阵。 示例 1: 123456789输入: nums = [[1,2], [3,4]]r = 1, c = 4输出: [[1,2,3,4]]解释:行遍历nums的结果是 [1,2,3,4]。新的矩阵是 1 * 4 矩阵, 用之前的元素值一行一行填充新矩阵。 示例 2: 12345678910输入: nums = [[1,2], [3,4]]r = 2, c = 4输出: [[1,2], [3,4]]解释:没有办法将 2 * 2 矩阵转化为 2 * 4 矩阵。 所以输出原矩阵。 注意： 给定矩阵的宽和高范围在 [1, 100]。 给定的 r 和 c 都是正数。 方法 将数组转换为1行，然后根据要转换的行列数进行转换 1234567class Solution: def matrixReshape(self, nums: List[List[int]], r: int, c: int) -&gt; List[List[int]]: if len(nums)*len(nums[0]) != r*c: return nums else: onerow = [nums[i][j] for i in range(len(nums)) for j in range(len(nums[0]))] return [onerow[t*c:(t+1)*c] for t in range(r)] 581. 最短无序连续子数组 给定一个整数数组，你需要寻找一个连续的子数组，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。 你找到的子数组应是最短的，请输出它的长度。 示例 1: 123输入: [2, 6, 4, 8, 10, 9, 15]输出: 5解释: 你只需要对 [6, 4, 8, 10, 9] 进行升序排序，那么整个表都会变为升序排序。 说明 : 输入的数组长度范围在 [1, 10,000]。 输入的数组可能包含重复元素 ，所以升序的意思是&lt;=。 方法 all_same.index(False)是元素从前往后看第一个为False的元素的序数。all_same[::-1]是从后往前看。 1234class Solution: def findUnsortedSubarray(self, nums: List[int]) -&gt; int: all_same = [a==b for (a,b) in zip(nums, sorted(nums))] return 0 if all(all_same) else len(nums)-all_same.index(False)-all_same[::-1].index(False) 参考 3个月用python刷完leetcode600题!-数组简单题（二）]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>LeetCode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python解LeetCode数组(1)]]></title>
    <url>%2F2019%2F02%2F22%2Fpython_leetcode-array(1)%2F</url>
    <content type="text"><![CDATA[数组是一种基本的数据结构，占据一块连续的内存，并按照顺序存储数据。 创建数组时，需要首先指定数组的容量大小，然后根据大小分配内存。 - 26. 删除排序数组中的重复项 - 27. 移除元素 - 35. 搜索插入位置 - 53. 最大子序和 - 66. 加一 - 118. 杨辉三角 - 119. 杨辉三角 II - 121. 买卖股票的最佳时机 - 122. 买卖股票的最佳时机 II - 167. 两数之和 II - 输入有序数组 26. 删除排序数组中的重复项 Remove Duplicates from Sorted Array 题目描述 给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 示例 1: 123给定数组 nums = [1,1,2], 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 你不需要考虑数组中超出新长度后面的元素。 示例 2: 123给定 nums = [0,0,1,1,1,2,2,3,3,4],函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。你不需要考虑数组中超出新长度后面的元素。 说明: 为什么返回数值是整数，但输出的答案是数组呢? 请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 你可以想象内部操作如下: 12345678// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝int len = removeDuplicates(nums);// 在函数里修改输入数组对于调用者是可见的。// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。for (int i = 0; i &lt; len; i++) &#123; print(nums[i]);&#125; 方法：遍历一次 需要一个 flag 标记：从flag=0开始，当前数与flag位置的数比较，不相同则flag+1,并替换flag+1位的数。 123456789101112131415161718class Solution(object): def removeDuplicates(self, nums): """ :type nums: List[int] :rtype: int """ if not nums: return 0 index = 0 for i in range(1,len(nums)): if nums[i] != nums[index]: index += 1 nums[index] = nums[i] return index+1 27. 移除元素 Remove Element 题目描述 给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。 示例 1: 给定 nums = [3,2,2,3], val = 3, 函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。 你不需要考虑数组中超出新长度后面的元素。 示例 2: 给定 nums = [0,1,2,2,3,0,4,2], val = 2, 函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。 注意这五个元素可为任意顺序。 你不需要考虑数组中超出新长度后面的元素。 方法：遍历一次 12345678910111213class Solution(object): def removeElement(self, nums, val): """ :type nums: List[int] :type val: int :rtype: int """ index = 0 for i in range(0,len(nums)): if nums[i]!=val: nums[index] = nums[i] index += 1 return index 35. 搜索插入位置 Search Insert Position 题目描述 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。 你可以假设数组中无重复元素。 示例 1: 输入: [1,3,5,6], 5 输出: 2 示例 2: 输入: [1,3,5,6], 2 输出: 1 示例 3: 输入: [1,3,5,6], 7 输出: 4 方法一：顺序查找 123456789101112class Solution(object): def searchInsert(self, nums, target): """ :type nums: List[int] :type target: int :rtype: int """ if target &gt; nums[-1]: return len(nums) for index, value in enumerate(nums): if value &gt;= target: return index 方法二：二分查找 1234567891011121314151617181920class Solution(object): def searchInsert(self, nums, target): """ :type nums: List[int] :type target: int :rtype: int """ left = 0 right = len(nums)-1 while left &lt;= right: mid = (right-left)/2 + left if nums[mid] == target: return mid elif nums[mid] &gt; target: right = mid-1 else: left = mid+1 return left 理论上应该比前一个方法快，实际测评结果较慢。 53. 最大子序和 Maximum Subarray 题目描述 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 示例: 输入: [-2,1,-3,4,-1,2,1,-5,4], 输出: 6 解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。 方法：Kadane’s algorithm 用两个指针：max_so_far 指针记录此前所有碰到的最大和，max_ending_here 指针记录循环到当前元素的最大和。 当循环到元素i时， 如果 max_ending_here &lt; 0 的话，说明此前的和是负的，需要舍弃，所以将 max_ending_here 的值变为 i。 反之，表明当前的和还是正值， 将 max_ending_here 的值变为 i + max_ending_here,可以继续向前探索。 max_so_far 和 max_ending_here 比较，取较大值。 12345678910111213141516class Solution(object): def maxSubArray(self, nums): """ :type nums: List[int] :rtype: int """ max_so_far = max_ending_here = nums[0] for i in range(1,len(nums)): if max_ending_here &lt; 0: max_ending_here = nums[i] else: max_ending_here += nums[i] if max_ending_here &gt; max_so_far: max_so_far = max_ending_here return max_so_far 方法： 动态规划 1234567class Solution: def maxSubArray(self, nums: List[int]) -&gt; int: maxsum = res = nums[0] for i in range(1, len(nums)): maxsum = max(maxsum + nums[i], nums[i]) res = max(maxsum, res) return res 结果不如前一种方法快 66. 加一 Plus One 给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。 最高位数字存放在数组的首位， 数组中每个元素只存储一个数字。 你可以假设除了整数 0 之外，这个整数不会以零开头。 示例 1: 123输入: [1,2,3]输出: [1,2,4]解释: 输入数组表示数字 123。 示例 2: 123输入: [4,3,2,1]输出: [4,3,2,2]解释: 输入数组表示数字 4321。 方法一：反过来遍历 从最后一位，找一个记录当前进位的变量，然后遍历一遍数组 123456789101112131415class Solution: def plusOne(self, digits): """ :type digits: List[int] :rtype: List[int] """ for i in reversed(range(len(digits))): if digits[i] == 9: digits[i] = 0 else: digits[i] += 1 return digits digits[0] = 1 digits.append(0) return digits 方法二：转数字→字符串→int 12345678910class Solution: def plusOne(self, digits): """ :type digits: List[int] :rtype: List[int] """ sum = 0 for i in digits: sum = sum*10+i return [int(i) for i in str(sum+1)] 118. 杨辉三角 Pascal’s Triangle 题目描述 给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。 示例: 输入: 5 输出: 1234567[ [1], [1,1], [1,2,1], [1,3,3,1], [1,4,6,4,1]] 方法 在杨辉三角中，每个数是它左上方和右上方的数的和。 每一行前补0，后补0，相加求和即为下一行的数。 1 3 3 1 0 + 0 1 3 3 1 = 1 4 6 4 1 12345678910111213class Solution(object): def generate(self, numRows): """ :type numRows: int :rtype: List[List[int]] """ if numRows == 0: return [] res = [[1]] for i in range(1, numRows): res.append(map(lambda x,y:x+y, res[-1]+[0], [0]+res[-1])) return res 119. 杨辉三角 II Pascal’s Triangle II 题目描述 给定一个非负索引 k，其中 k ≤ 33，返回杨辉三角的第 k 行。 示例: 12输入: 3输出: [1,3,3,1] 方法 在杨辉三角中，每个数是它左上方和右上方的数的和。 思路同上一题 12345678910class Solution(object): def getRow(self, rowIndex): """ :type rowIndex: int :rtype: List[int] """ res = [1] for i in range(1, rowIndex+1): res = list(map(lambda x,y:x+y, res+[0], [0]+res)) return res 121. 买卖股票的最佳时机 Best Time to Buy and Sell Stock 题目描述 给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。 注意你不能在买入股票前卖出股票。 示例 1: 1234输入: [7,1,5,3,6,4]输出: 5解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。 示例 2: 123输入: [7,6,4,3,1]输出: 0解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 方法一：遍历 根据题意，我们只需要找出数组中最大的差值即可，即 max(prices[j] – prices[i]) ，i &lt; j 。 如何得到最大的差值，只需要一次遍历即可，在遍历的用一个变量记录遍历到当前时的最小值即可。时间复杂度为 O(n). 12345678910111213141516171819class Solution(object): def maxProfit(self, prices): """ :type prices: List[int] :rtype: int """ if prices is None or len(prices)&lt;2: return 0 buy = prices[0] # 买入 profit = 0 # 利润 for i in range(1,len(prices)): if prices[i] &lt; buy: buy = prices[i] else: if prices[i] - buy &gt; profit: profit = prices[i] - buy return profit 方法二：Kadane’s algorithm 方法同上面的53题-求数组中和最大的连续子数组序列。 如何转化为求数组中的和最大的连续子序列？相邻两个数作差即可，这样的话子序列的和就是我们在子序列开始卖出股票，在子序列最后买回股票所能得到的收益。 12345678910111213class Solution(object): def maxProfit(self, prices): """ :type prices: List[int] :rtype: int """ max_so_far = max_ending_here = 0 for i in range(1, len(prices)): max_ending_here = max(0, max_ending_here + prices[i] - prices[i-1]) max_so_far = max(max_so_far, max_ending_here) return max_so_far 测试结果比前一个方法慢 122. 买卖股票的最佳时机 II Best Time to Buy and Sell Stock II 题目描述 给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 示例 1: 输入: [7,1,5,3,6,4] 输出: 7 解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。 示例 2: 输入: [1,2,3,4,5] 输出: 4 解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。 因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。 示例 3: 输入: [7,6,4,3,1] 输出: 0 解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 方法：遍历 如果后面的股价比前面的大，我们就买卖 1234567class Solution(object): def maxProfit(self, prices): """ :type prices: List[int] :rtype: int """ return sum(max(prices[i+1]-prices[i], 0) for i in range(len(prices)-1)) 167. 两数之和 II - 输入有序数组 题目描述 给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。 函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。 说明: 返回的下标值（index1 和 index2）不是从零开始的。 你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。 示例: 输入: numbers = [2, 7, 11, 15], target = 9 输出: [1,2] 解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。 方法 思路同第1题 123456789101112131415class Solution(object): def twoSum(self, numbers, target): """ :type numbers: List[int] :type target: int :rtype: List[int] """ dic = dict() for index, value in enumerate(numbers): sub = target - value if sub in dic: return (dic[sub]+1, index+1) else: dic[value] = index 参考 3个月用python刷完leetcode600题!-数组简单题（一） Largest Sum Contiguous Subarray]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>LeetCode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python解LeetCode链表(2)]]></title>
    <url>%2F2019%2F02%2F20%2Fpython_linklist(2)%2F</url>
    <content type="text"><![CDATA[练习题目： 合并有序链表 合并两个有序链表 合并K个排序链表 删除节点 删除链表的倒数第N个节点 删除排序链表中的重复元素 删除排序链表中的重复元素 II 移除链表元素 删除链表中的节点 环形链表 环形链表 II 相交链表 回文链表 21. 合并两个有序链表 Merge Two Sorted Lists 将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 示例： 12输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 方法 同时遍历两个链表，每次选取两个链表中较小值的节点，依次连接起来，就能得到最终的链表。 注意： 1. 返回值要返回head.next 2. 无需判断循环后哪个不为空，or返回第一个为真的值 12345678910111213141516171819202122232425# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def mergeTwoLists(self, l1, l2): """ :type l1: ListNode :type l2: ListNode :rtype: ListNode """ head = cur = ListNode(0) while l1 and l2: if l1.val &lt; l2.val: cur.next = l1 l1 = l1.next else: cur.next = l2 l2 = l2.next cur = cur.next cur.next = l1 or l2 return head.next 23.合并K个排序链表 合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。 示例: 1234567输入:[ 1-&gt;4-&gt;5, 1-&gt;3-&gt;4, 2-&gt;6]输出: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6 方法 把问题简化为merge2的问题，这种思路可以每次递归值归并前两个，或是或是每次把相邻的两个都归并了，后者的栈的深度要更小。 123456789101112131415161718192021222324252627class Solution: def mergeKLists(self, lists: List[ListNode]) -&gt; ListNode: if not lists: return amount = len(lists) interval = 1 while interval &lt; amount: for i in range(0, amount - interval, interval * 2): lists[i] = self.merge2Lists(lists[i], lists[i + interval]) interval *= 2 return lists[0] def merge2Lists(self, l1, l2): head = point = ListNode(0) while l1 and l2: if l1.val &lt;= l2.val: point.next = l1 l1 = l1.next else: point.next = l2 l2 = l1 l1 = point.next.next point = point.next if not l1: point.next=l2 else: point.next=l1 return head.next 19. 删除链表的倒数第N个节点 给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。 示例： 12给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5. 说明：给定的 n 保证是有效的。 方法：快慢指针 实际面试中考虑：n从0计还是从1计; n不合法，负数或者大于链表长度如何处理（保证n合法） 用两个指针（只需要遍历一次），一个快指针从前到后扫描整个链表，另一个慢指针的步数差n+1，那么当p指向尾部的Null时，指针q恰好指向要删除节点的前一个节点。 由于可能删除头部节点，伪装一个新的头部方便操作。 123456789101112class Solution: def removeNthFromEnd(self, head: ListNode, n: int) -&gt; ListNode: dummyHead = ListNode(0) # 可能删除了头结点 dummyHead.next = head fast = slow = dummyHead for i in range(n+1): fast = fast.next while fast: fast = fast.next slow = slow.next slow.next = slow.next.next # 删除第n个 return dummyHead.next 83. 删除排序链表中的重复元素 Remove Duplicates from Sorted List 题目描述 给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。 示例 1: 输入: 1-&gt;1-&gt;2 输出: 1-&gt;2 示例 2: 输入: 1-&gt;1-&gt;2-&gt;3-&gt;3 输出: 1-&gt;2-&gt;3 方法一：两个指针 用两个指针来完成，分别记录要删除的链表元素和上一个元素。 123456789101112131415161718192021222324# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def deleteDuplicates(self, head): """ :type head: ListNode :rtype: ListNode """ if not head: return head p = head q = head.next while q: if p.val == q.val: p.next = q.next q = q.next else: p = p.next q = q.next return head 方法二： 一个指针 12345678910111213class Solution: def deleteDuplicates(self, head): """ :type head: ListNode :rtype: ListNode """ cur = head while cur: while cur.next and cur.val == cur.next.val: cur.next = cur.next.next cur = cur.next return head 82. 删除排序链表中的重复元素 II 给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中 没有重复出现的数字。 示例 1: 12输入: 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5输出: 1-&gt;2-&gt;5 示例 2: 12输入: 1-&gt;1-&gt;1-&gt;2-&gt;3输出: 2-&gt;3 方法：dummy node 注意审题啊，这个distinct的意思并不是去重，而是删除出现次数不止一次的。 去重的可以看这个题：83. Remove Duplicates from Sorted List 因此必须先遍历一遍，统计每个节点出现的次数。 第二次遍历的时候，查找下个节点的值出现的次数如果不是1次，那么就删除下个节点。修改这个节点的下个指针指向下下个节点，这是指向该节点位置的指针不要动，因为还要判断新的next值。 1234567891011121314151617class Solution: def deleteDuplicates(self, head: ListNode) -&gt; ListNode: dummy = ListNode(0) # 设立链表的虚拟头结点 dummy.next = head valist = [] while head: valist.append(head.val) head = head.next counter = collections.Counter(valist) head = dummy while head and head.next: if counter[head.next.val] != 1: head.next = head.next.next else: head = head.next return dummy.next 203. 移除链表元素 题目描述 删除链表中等于给定值 val 的所有节点。 示例: 输入: 1-&gt;2-&gt;6-&gt;3-&gt;4-&gt;5-&gt;6, val = 6 输出: 1-&gt;2-&gt;3-&gt;4-&gt;5 方法：dummy node 有了第83题的思路，我们这里可以用一个指针来进行链表的遍历， 注意：头节点也需要进行判断，如果头节点的值等于val的话，我们不能返回头节点，所以这里很巧妙的重新生成了一个无关的头节点dummy node。（设立链表的虚拟头结点） 123456789101112131415class Solution(object): def removeElements(self, head, val): """ :type head: ListNode :type val: int :rtype: ListNode """ dummy = ListNode(-1) #设立链表的虚拟头结点 dummy.next = head cur = dummy while cur: while cur.next and cur.next.val == val: cur.next = cur.next.next cur = cur.next return dummy.next 237. 删除链表中的节点 Delete Node in a Linked List 输入：要求被删除的（非末尾）节点 函数功能：删除某个链表中的这个节点。无返回。 示例 1: 123输入: head = [4,5,1,9], node = 5输出: [4,1,9]解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9. 示例 2: 123输入: head = [4,5,1,9], node = 1输出: [4,5,9]解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9. 说明: 链表至少包含两个节点。 链表中所有节点的值都是唯一的。 给定的节点为非末尾节点并且一定是链表中的一个有效节点。 不要从你的函数中返回任何结果。 方法:替换值 关键是理解题意，不给你整个链表，只给你一个节点，如何把这个节点删除。 其实没必要真的把这个节点删除，而是把这个节点对应的val值删除即可， 所以可以偷天换日，把下一个节点的值赋给这个节点，再把下一个节点删除。 12345678class Solution(object): def deleteNode(self, node): """ :type node: ListNode :rtype: void Do not return anything, modify node in-place instead. """ node.val = node.next.val node.next = node.next.next 141. 环形链表 Linked List Cycle 给定一个链表，判断链表中是否有环。 方法：快慢双指针 通过使用具有不同速度的快、慢两个指针遍历链表，空间复杂度可以被降低至 O(1)。慢指针每次移动一步，而快指针每次移动两步。 如果列表中不存在环，最终快指针将会最先到达尾部，此时我们可以返回 false。 考虑一个环形链表，把慢指针和快指针想象成两个在环形赛道上跑步的运动员（分别称之为walker与runner）。而runner最终一定会追上walker。这是为什么呢？考虑下面这种情况（记作情况 A） - 假如runner只落后walker一步，在下一次迭代中，它们就会分别跑了一步或两步并相遇。 其他情况又会怎样呢？例如，我们没有考虑快跑者在慢跑者之后两步或三步的情况。但其实不难想到，因为在下一次或者下下次迭代后，又会变成上面提到的情况 A。 1234567891011121314151617class Solution(object): def hasCycle(self, head): """ :type head: ListNode :rtype: bool """ if not head: return False walker = head runner = head.next try: while walker != runner: walker = walker.next runner = runner.next.next return True except: return False 略微改变语法形式，思路没有区别： 1234567891011121314151617class Solution(object): def hasCycle(self, head): """ :type head: ListNode :rtype: bool """ if not head or not head.next : return False walker = head runner = head.next while walker != runner: # 改成判断快指针先到达尾部 if not runner or not runner.next: return False walker = walker.next runner = runner.next.next return True 更简洁的写法 12345678910111213class Solution(object): def hasCycle(self, head): """ :type head: ListNode :rtype: bool """ fast = slow = head while slow and fast and fast.next: slow = slow.next fast = fast.next.next if slow is fast: return True return False 142. 环形链表 II 给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。 说明：不允许修改给定的链表。 示例 1： 123输入：head = [3,2,0,-4], pos = 1输出：tail connects to node index 1解释：链表中有一个环，其尾部连接到第二个节点。 方法一：set() 如果我们保存走过的每个位置不就好了吗？所以，对于Python来说，可以直接把对象放到set中去，这样，当我们再次遍历到已经访问过的节点时，说明有了环，直接返回该节点即可。 123456789101112131415class Solution(object): def detectCycle(self, head): """ :type head: ListNode :rtype: ListNode """ if not head: return None visited = set() while head: if head in visited: return head visited.add(head) head = head.next return None 方法二：快慢指针 1234567891011121314151617181920class Solution(object): def detectCycle(self, head): """ :type head: ListNode :rtype: ListNode """ slow, fast = head, head while fast and fast.next: fast = fast.next.next slow = slow.next if fast == slow: # 相遇点 break if not fast or not fast.next: return None slow = head # 从头开始走 while slow != fast: slow = slow.next # 从头开始走 fast = fast.next # 从相遇点开始走 return fast 160. 相交链表 Intersection of Two Linked Lists 编写一个程序，找到两个单链表相交的起始节点。 如下面的两个链表： avatar 在节点 c1 开始相交。 注意： 如果两个链表没有交点，返回 null. 在返回结果后，两个链表仍须保持原有的结构。 可假定整个链表结构中没有循环。 程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。 方法：两指针 判断链表是否有交集，可以设置两个指针，一个指针从第一个链表开始遍历，遍历完第一个链表再遍历第二个链表，另一个指针从第二个链表开始遍历，遍历完第二个链表再遍历第一个链表. 不管两个链表在交集前的长度如何，遍历两个链表长度总和相同。 如果有交集的话，两个指针肯定会同时遍历到最后的交集部分。 1234567891011121314class Solution(object): def getIntersectionNode(self, headA, headB): """ :type head1, head1: ListNode :rtype: ListNode """ if not headA or not headB: return None pa = headA pb = headB while pa is not pb: pa = headB if pa == None else pa.next pb = headA if pb == None else pb.next return pa 234. 回文链表 Palindrome Linked List 请判断一个链表是否为回文链表。 示例 1: 12输入: 1-&gt;2输出: false 示例 2: 12输入: 1-&gt;2-&gt;2-&gt;1输出: true 方法：两个指针 两个指针，一个指针从前往后走，一个指针从后往前走，判断元素值是否相同，这里要分几个步骤来进行求解： 找到链表长度的一半，用追赶法，一个指针一次走两步，一个指针一次走一步 将后一半数组反转 比较两边元素是否相同，判断链表是否是回文链表 123456789101112131415161718192021222324class Solution(object): def isPalindrome(self, head): """ :type head: ListNode :rtype: bool """ slow = fast = head while fast and fast.next: slow = slow.next fast = fast.next.next node = None #反转后一半链表 while slow: nxt = slow.next slow.next = node node = slow # node是反转后的第一个元素 slow = nxt while node and head: if node.val != head.val: return False node = node.next head = head.next return True 参考 3个月用python刷完leetcode600题!-linked_list简单题 21. Merge Two Sorted Lists [easy] (Python)]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>链表</tag>
        <tag>pythongit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[贪心算法]]></title>
    <url>%2F2018%2F10%2F24%2Fweek3-Greedy%20Algorithms%2F</url>
    <content type="text"><![CDATA[概述 贪心算法是指，在对问题求解时，每一步选择中总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的是在某种意义上的局部最优解。 实现过程 从问题的某一初始解出发；while 能朝给定总目标前进一步 do，求出可行解的一个解元素； 最后，由所有解元素组合成问题的一个可行解。 创建数学模型来描述问题。 把求解的问题分成若干个子问题。 对每一子问题求解，得到子问题的局部最优解。 把子问题的解局部最优解合成原来解问题的一个解。 注意： 贪心算法与动态规划的不同在于它对每个子问题的解决方案都做出选择，不能回退。动态规划则会保存以前的运算结果，并根据以前的结果对当前进行选择，有回退功能。 贪心法可以解决一些最优化问题，如：求图中的最小生成树、求哈夫曼编码…… 对于大部分的问题，贪心法通常都不能找出最佳解（不过也有例外），因为他们一般没有测试所有可能的解。贪心法容易过早做决定，因而没法达到最佳解。例如，所有对图着色问题。 学习目标 Practice implementing greedy solutions Build greedy algorithms Create a program for changing money optimally Create a program for maximizing the value of a loot Create a program for maximizing the number of prize places in a competition Apply greedy strategy to solve various computational problems. This will usually require you to design an algorithm that repeatedly makes the most profitable move to construct a solution. You will then need to show that the moves of your algorithm are safe, meaning that they are consistent with at least one optimal solution. Design and implement an eficient greedy algorithm for the following problems: changing money with a minimum number of coins; maximizing the total value of a loot; maximizing revenue in online ad placement; minimizing work while collecting signatures; maximizing the number of prize places in a competition; finally, maximizing your salary! 兑换零钱 Money Change Task. 根据输入值，找到需要兑换 1, 5, 10面额硬币的最少个数. Input Format. 输入一个整数\(m\). Constraints. \(1 ≤ n ≤ 10^3\). Output Format. Output the minimum number of coins with denominations 1, 5, 10 that changes \(m\). Sample 1. 1234Input:28Output:6 28 = 10 + 10 + 5 + 1 + 1 + 1. 方法一 12345678910111213def get_change(m): coins = [10, 5, 1] n = 0 for a in coins: while m &gt;= a: n += 1 m -= a if m == 0: break return nprint(get_change(2))print(get_change(28))print(get_change(999)) 2 6 104 方法二 123456789101112def get_changeC(m): coins = [10, 5, 1] n = 0 for a in coins: # Update the the number of coins 'held' in the amount. n += m // a # Put remainder to the residuary amount. m %= a return nprint(get_changeC(2))print(get_changeC(28))print(get_changeC(999)) 2 6 104 背包问题 Maximum Value of the Loot Task. A thief finds much more loot than his bag can fit. Help him to find the most valuable combination of items assuming that any fraction of a loot item can be put into his bag. Input Format. 输入包可承受的重量(capacity)\(W\)，\(n\)件掠夺品的重量weights和价值values分别是\(w_i,v_i\) Constraints. \(1 ≤ n ≤ 10^3, 0 ≤W≤ 2·10^6, 0 ≤v_i≤ 2·10^6, 0 ≤ w_i ≤ 2·10^6\) 所有数字都是整数. Output Format. Output the maximal value of fractions of items that fit into the knapsack. Sample 1. 1234Input:50, [20,50,30], [60,100,120]Output:180.0000 选了第1件和第3件东西。 方法一 12345678910111213141516171819202122232425def get_optimal_value(capacity, weights, values): value = 0 n = len(weights) # A = [None] * n pers = [None] * n for i in range(n): pers[i] = values[i] / weights[i] for _ in range(n): if capacity == 0: return value m = pers.index(max(pers)) a = min(weights[m], capacity) value += a*pers[m] weights[m] -= a if weights[m] == 0: pers[m] = 0 # A[m] += a capacity -= a return valueprint("&#123;:.10f&#125;".format(get_optimal_value(10, [30], [500])))print("&#123;:.10f&#125;".format(get_optimal_value(50, [20,50,30], [60,100,120]))) 166.6666666667 180.0000000000 方法二 Optimization 首先按降序将 \(\frac{v}{w}\) 排序 1234567891011121314151617181920212223def get_optimal_value(capacity, weights, values): value = 0 weight_value_pairs = sorted(list(zip(weights, values)), key = lambda x:x[1]/x[0], reverse=True) for (w, v) in weight_value_pairs: # If the item fit into the knapsack, put it and recalculate space left. if capacity - w &gt;= 0: value += v capacity -= w else: # Otherwise calculate weight of unit of the item and fill # the knapsack's left space. value += (v / w) * capacity capacity = 0 if not capacity: break return valueprint("&#123;:.10f&#125;".format(get_optimal_value(10, [30], [500])))print("&#123;:.10f&#125;".format(get_optimal_value(50, [20,50,30], [60,100,120]))) 166.6666666667 180.0000000000 广告点击最大收益 Maximum Advertisement Revenue Task. You have \(n\) ads to place on a popular Internet page. For each ad, you know how much is the advertiser willing to pay for one click on this ad. You have set up \(n\) slots on your page and estimated the expected number of clicks per day for each slot. Now, your goal is to distribute the ads among the slots to maximize the total revenue. Input Format. 给定两组序列\(a_1,a_2,...,a_n\)(\(a_i\) 是第 \(i\) 条广告的点击利润)，\(b_1,b_2,...,b_n\)(\(b_i\) 是第 \(i\) 个位置的平均每天点击数)，把它们对应分成\(n\)组\((a_i,b_j)\)使他们乘积的总和最大。 Constraints. \(1 ≤ n ≤ 10^3, -10^5 ≤a_i,b_i≤ 10^5\) Output Format. 输出 \(\sum^n_{i=1}a_ic_i\) 的最大值。\(c_1,c_2,...,c_n\)是\(b_1,b_2,...,b_n\)的重排列 Sample 1. 1234Input:[1,3,-5], [-2,4,1]Output:23 \(23 = 3 · 4 + 1 · 1 + (−5) · (−2).\) 先排好序，最大的在前，最大的两个乘积，随后循环,这样得到的乘积和最大。 1234567891011def max_dot_product(a, b): a = sorted(a, reverse=True) b = sorted(b, reverse=True) res = 0 for i in range(len(a)): res += a[i] * b[i] return resprint(max_dot_product([23], [39]))print(max_dot_product([1,3,-5], [-2,4,1])) 897 23 找房客签字的最佳时间点 Collecting Signatures Task. You are responsible for collecting signatures from all tenants of a certain building. For each tenant, you know a period of time when he or she is at home. You would like to collect all signatures by visiting the building as few times as possible.Your goal is to mark as few points on a line as possible so that each segment contains at least one marked point.找最少的标记时间点数\(m\)，使每个时间段内都有标记时间点。 Input Format. \(n\)段时间 \(\{[a_0,b_0],[a_1,b_1],...,[a_{n-1},b_{n-1}]\}\) Constraints. \(1 ≤ n ≤ 100, -0≤a_i ≤b_i≤ 10^9\) Output Format. 标记的位置点 Sample 1. 1234Input:[(4,7), (1,3), (2,5), (5,6)]Output:3 6 1234567891011121314151617181920212223242526272829def optimal_points(segments): # 按结束时间先后排序 segments.sort(key = lambda x:x[1]) points = [] for s in segments: points.append(s[0]) points.append(s[1]) result = [] n = len(segments) c = 1 i = 1 result.append(points[c]) # 加入第一个结束时间点为标记点 while i &lt; n: if points[i*2] &gt; points[c]: # 如果下一段起始时间点晚于标记点 c = i*2+1 # 则把这段的结束时间点加入标记点 result.append(points[c]) i += 1 return resultpoints1 = optimal_points([(1,3), (2,5), (3,6)])#print(len(points1))for p in points1: print(p, end=' ')print("\n") points2 = optimal_points([(4,7), (1,3), (2,5), (5,6)])#print(len(points2))for p in points2: print(p, end=' ') 3 3 6 分不同数量的奖品 Task. 你在给孩子们组织一场有趣的竞赛。你有\(n\) 个糖果作为奖品.你想把这些奖品给比赛前 \(k\) 名的孩子。名次越高，获奖糖果应该越多。为了使尽可能多孩子开心，你要找最多的获奖名额\(k\). Input Format. 整数 \(n\) Constraints. $1 ≤ n ≤ 10^9 $ Output Format. 获奖名额 \(k\) 和 分别获得的糖果数 (每个名次的获奖糖果数不应相同.) Sample 1. 12345Input:7Output:31 2 4 1234567891011121314151617181920212223242526272829303132def optimal_summands(n): summands = [1] #被加数 n -= 1 # 剩余糖果数 while n: last_element = summands[-1] # Save move: check whether the incremented last element can be used as # the next summand. if (last_element + 1) * 2 &lt;= n: # 如果最后一个数比n的一半还小 n -= last_element + 1 summands.append(last_element + 1) # 添加获奖名额及获奖数 else: if last_element &gt;= n: # 如果最后一个数大于n n += summands.pop() summands.append(n) # 添加获奖名额及获奖数 n = 0 return summandssummands = optimal_summands(2)print(len(summands))for x in summands: print(x, end=' ')print("\n")summands = optimal_summands(6)print(len(summands))for x in summands: print(x, end=' ')print("\n")summands = optimal_summands(7)print(len(summands))for x in summands: print(x, end=' ')print("\n") 1 2 3 1 2 3 3 1 2 4 这里设置&lt;=n 而不是&lt;n 是要考虑要奖品数为2的情况，必须把之前的1退回去。 最大薪水 Maximum Salary Task. As the last question of a successful interview, your boss gives you a few pieces of paper with numbers on it and asks you to compose a largest number from these numbers. The resulting number is going to be your salary, so you are very much interested in maximizing this number. How can you do this?不同的数拼成一个最大数(这些数未必只是一位数。(比如23和3，应该拼成323最大) Input Format. \(n\)个数 \(a_0,a_1,...,a_n\) Constraints. \(1 ≤ n ≤ 100, 1≤a_i ≤ 10^3\) Output Format. 可组成的最大数 Sample 1. 1234Input:[21,2]Output:221 12345678910111213141516171819202122232425import sysdef isGreaterOrEqual(digit,maxDigit): d = int(str(digit)+str(maxDigit)) m = int(str(maxDigit)+str(digit)) return (d &gt;= m)def largest_number(a): res = "" r=[] while a != []: maxDigit = 0 for digit in a: if isGreaterOrEqual(digit,maxDigit): maxDigit = digit r.append(maxDigit) a.remove(maxDigit) for rr in r: res += str(rr) return resprint(largest_number([21,2]))print(largest_number([23,39,92]))print(largest_number([9,4,6,1,9])) 221 923923 99641 参考： - Coursera：algorithmic toolbox(week3)]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>Algorithm -   背包问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[week2-Algorithm Warmup]]></title>
    <url>%2F2018%2F09%2F28%2Fweek2-algorithm_warmup%2F</url>
    <content type="text"><![CDATA[Estimate the running time of an algorithm Practice implementing efficient solutions Practice solving programming challenges Implement programs that are several orders of magnitude faster than straightforward programs 斐波那契数列 Fibonacci Numbers Task. Given an integer \(n\), find the last digit of the nth Fibonacci number \(F_n\). Input Format. The input consists of a single integer \(n\). Constraints. $0 ≤ n ≤ 45 $. Output Format. Output \(F_n\). Sample 1. 1234Input:10Output:55 \(F_{10} = 55\) 0 1 1 2 3 5 8 13 递归 Naive Algorithm 123456789def calc_fib(n): if (n &lt;= 1): return n return calc_fib(n - 1) + calc_fib(n - 2)print(calc_fib(6))print(calc_fib(20))print(calc_fib(34)) 8 6765 5702887 时间复杂度：\(O(2^n)\) 动态规划 Fast Algorithm 递归 + 记忆化 -&gt; 递推 递推公式：A[i] = A[i-1] + A[i-2] 1234567891011def calc_fibFast(n): A = [None]* (n+1) A[0] = 0 A[1] = 1 for i in range(2, n+1): A[i] = A[i-1] + A[i-2] return A[n]print(calc_fibFast(6))print(calc_fibFast(20))print(calc_fibFast(34)) 8 6765 5702887 时间复杂度：\(O(n)\) 123456789101112131415def calc_fibFast(n): if n &lt;= 1: return n previous = 0 current = 1 for _ in range(n - 1): previous, current = current, previous + current return currentprint(calc_fibFast(6))print(calc_fibFast(20))print(calc_fibFast(34)) 8 6765 5702887 斐波那契数的个位数 Last Digit of a Large Fibonacci Number Task. Given an integer \(n\), fnd the last digit of the nth Fibonacci number \(F_n\) mod \(m\) (that is, \(F_n\) mod 10). Input Format. The input consists of a single integer \(n\). Constraints. $0 ≤ n ≤ 10^{7} $. Output Format. Output the last digit of \(F_n\). Sample 1. 1234Input:3Output:2 \(F_3 = 2\). Naive Algorithm 1234567891011121314151617def get_fibonacci_last_digit_naive(n): if n &lt;= 1: return n previous = 0 current = 1 for _ in range(n - 1): previous, current = current, previous + current return current % 10print(get_fibonacci_last_digit_naive(6))print(get_fibonacci_last_digit_naive(20))print(get_fibonacci_last_digit_naive(34))print(get_fibonacci_last_digit_naive(331)) 8 5 7 9 Fast Algorithm 每次只保留斐波那契数的个位数 1234567891011121314151617def get_fibonacci_last_digit_Fast(n): if n &lt;= 1: return n previous = 0 current = 1 for _ in range(n - 1): previous, current = current, (previous + current) % 10 return currentprint(get_fibonacci_last_digit_Fast(6))print(get_fibonacci_last_digit_Fast(20))print(get_fibonacci_last_digit_Fast(34))print(get_fibonacci_last_digit_Fast(331)) 8 5 7 9 最大公约数 Greatest Common Divisor Task. Given two integers \(a\) and \(b\), find their greatest common divisor. Input Format. The two integers \(a\) and \(b\) are given in the same line separated by space.. Constraints. \(1 ≤ a, b ≤ 2·10^{9}\). Output Format. Output GCD(a, b). Sample 1. 1234Input:18 35Output:1 18 and 35 do not have common non-trivial divisors. Naive Algorithm 同时能整除a和b的最大的数 1234567891011def gcd_naive(a, b): current_gcd = 1 for d in range(2, min(a, b) + 1): if a % d == 0 and b % d == 0: if d &gt; current_gcd: current_gcd = d return current_gcdprint(gcd_naive(12, 4))print(gcd_naive(18, 35))print(gcd_naive(28851538, 1183019)) 4 1 17657 辗转相除法 又名欧几里德算法（Euclidean algorithm） 对两个数字进行 mod 取余运算 接下来再用除数和余数进行 mod 运算。 继续重复同样的操作。 余数为0时，最后一次运算中的除数就是两个数字的最大公约数。 123456789def gcd_Euclid(a, b): if b == 0: return a r = a % b return gcd_Euclid(b, r) print(gcd_Euclid(12, 4))print(gcd_Euclid(18, 35))print(gcd_Euclid(28851538, 1183019)) 4 1 17657 使用欧几里得算法，只需重复做除法便能求得最大公约数。 这个算法最大的优势就在于，即使两个数字再大，只要按照步骤进行操作就能高效地求得两者的最大公约数。 最小公倍数 Least Common Multiple Task. Given two integers \(a\) and \(b\), fnd their least common multiple. Input Format. The two integers \(a\) and \(b\) are given in the same line separated by space.. Constraints. \(1 ≤ a, b ≤ 2·10^{9}\). Output Format. Output the least common multiple of \(a\) and \(b\). Sample 1. 1234Input:6 8Output:24 Among all the positive integers that are divisible by both 6 and 8 (e.g., 48, 480, 24), 24 is the smallest one. Naive Algorithm 同时是a和b的倍数的最小值 123456789def lcm_naive(a, b): for l in range(1, a*b + 1): if l % a == 0 and l % b == 0: return l return a*bprint(lcm_naive(6, 8))print(lcm_naive(28851538, 1183019)) 24 1933053046 Fast Algorithm 性质：两个数的乘积等于这两个数的最大公约数与最小公倍数的积。用辗转相除法求出最大公约数，再求最小公倍数。 1234567891011def gcd_Euclid(a, b): if b == 0: return a r = a % b return gcd_Euclid(b, r)def lcm_fast(a, b): return a*b // gcd_Euclid(a, b)print(lcm_fast(6, 8))print(lcm_fast(28851538, 1183019)) 24 1933053046 斐波那契数取余 Fibonacci Number modulo m \(i\) 0 \(F_i\) 0 \(F_i\) mod 2 0 \(F_i\) mod 3 0 可以看出序列是有周期性的。模3以01120221循环，模2以011循环。此类循环都是以01开始，称为皮萨诺周期(pisano period) \(F_(2015)\) mod 3 只需要找到2015被8除的余数. Since 2015 = 251 · 8 + 7, we conclude that \(F_(2015)\) mod 3 = \(F_7\) mod 3 = 1. Task. Given two integers \(m\) and \(n\), output \(F_n\) mod \(m\) (that is, the remainder of \(F_n\) when divided by \(m\)). Input Format. The input consists of two integers \(m\) and \(n\) given on the same line (separated by a space). Constraints. \(1 ≤ n ≤ 10^{18},2 ≤ m ≤ 10^{3}\). Output Format. Output \(F_n\) mod \(m\). Sample 1. 1234Input:239 1000Output:161 \(F_239 mod 1000 = 39 679 027 332 006 820 581 608 740 953 902 289 877 834 488 152 161 (mod 1 000) = 161\). Naive Algorithm 123456789101112def get_fibonacci_huge_naive(n, m): if n &lt;= 1: return n previous = 0 current = 1 for _ in range(n - 1): previous, current = current, previous + current return current % mprint(get_fibonacci_huge_naive(239, 1000)) 161 Fast Algorithm 计算Fibonacci数直到m平方，因为pisano period不可能大于这个数。 因为最后一个数的后面是下一周期的0和1，那假设最后两个数分别是x和y，则(x+y)%m=0, (y+0)%m=1，所以 y=1, x=m-1为判别式。 1234567891011121314def get_fibonacci_huge_fast(n, m): A = [None]* (m**2) A[0] = 0 A[1] = 1 for i in range(2, m**2): A[i] = (A[i-1] + A[i-2]) % m if A[i] == 1 and A[i-1] == m-1: period = i+1 break t = n % period return A[t] % mprint(get_fibonacci_huge_fast(239, 1000))print(get_fibonacci_huge_fast(2816213588, 239)) 161 151 斐波那契数之和的个位数 Last Digit of the Sum of Fibonacci Numbers Task. Given an integer \(n\), fnd the last digit of the sum \(F_0 + F_1 + · · · + F_n\). Input Format. The input consists of a single integer \(n\). Constraints. \(0 ≤ n ≤ 10^{18}\). Output Format. Output the last digit of \(F_0 + F_1 + · · · + F_n\). Sample 1. 1234Input:3Output:4 \(F_0 + F_1 + F_2 + F_3 = 0 + 1 + 1 + 2= 4\). Naive Algorithm 12345678910111213141516def fibonacci_sum_naive(n): if n &lt;= 1: return n previous = 0 current = 1 sum = 1 for _ in range(n - 1): previous, current = current, previous + current sum += current return sum % 10print(fibonacci_sum_naive(3))print(fibonacci_sum_naive(100))print(fibonacci_sum_naive(240)) 4 5 0 Fast Algorithm 斐波那契数列的递归定义形式如下： \[a_n= \begin{cases} a_{n-1}+a_{n-2},\\ 1,&amp; {n\leq 1} \end{cases} \] 斐波那契数列求和公式： \[S_n= 2a_n+a_{n-1}-1\] 123456789101112131415def fibonacci_sum_fast(n): if n &lt;= 1: return n previous = 0 current = 1 for _ in range(n - 1): previous, current = current, (previous + current) return (2*current + previous - 1) % 10print(fibonacci_sum_fast(3))print(fibonacci_sum_fast(100))print(fibonacci_sum_fast(240))print(fibonacci_sum_fast(999999)) 4 5 0 0 More Fast Algorithm 去掉循环,用pisano period方法 123456789101112131415161718192021def fibonacci_sum_more_fast(n): if n &lt;= 1: return n A = [None]* (100) A[0] = 0 A[1] = 1 for i in range(2, 100): A[i] = (A[i-1] + A[i-2]) % 10 if A[i] == 1 and A[i-1] == 9: period = i+1 break t = n % period if t == 0: t = period-1 return (2*A[t] + A[t-1] - 1) % 10print(fibonacci_sum_more_fast(0))print(fibonacci_sum_more_fast(3))print(fibonacci_sum_more_fast(100))print(fibonacci_sum_more_fast(240))print(fibonacci_sum_more_fast(999999))print(fibonacci_sum_more_fast(832564823476)) 0 4 5 0 0 3 考虑到余数t==0的情况，A[t-1]值会出问题，因为是新一周期循环，值为0，所以，可以令t=period-1 斐波那契数之部分和的个位数 Last Digit of the Sum of Fibonacci Numbers Again Task. Given two non-negative integers \(m\) and \(n\), where \(m≤n\), fnd the last digit of the sum \(F_m + F_{m+1} + · · · + F_n\). Input Format. The input consists of two non-negative integers \(m\) and \(n\) separated by a space. Constraints. \(0 ≤m≤ n ≤ 10^{18}\). Output Format. Output the last digit of \(F_m + F_{m+1} + · · · + F_n\). Sample 1. 1234Input:3 7Output:1 \(F_3 + F_4 + F_5 + F_6 + F_7 = 2 + 3 + 5 + 8 + 13 = 31\). Naive Algorithm 12345678910111213141516171819def fibonacci_partial_sum_naive(from_, to): sum = 0 current = 0 next = 1 for i in range(to + 1): if i &gt;= from_: sum += current current, next = next, current + next return sum % 10print(fibonacci_partial_sum_naive(0, 1))print(fibonacci_partial_sum_naive(1, 2))print(fibonacci_partial_sum_naive(3, 7))print(fibonacci_partial_sum_naive(5, 7))print(fibonacci_partial_sum_naive(10, 10))print(fibonacci_partial_sum_naive(10, 200)) 1 2 1 6 5 2 Fast Algorithm 123456789101112131415161718192021222324252627def fibonacci_partial_sum_fast(from_, to): if to == 0: return 0 A = [None]* (100) A[0] = 0 A[1] = 1 for i in range(2, 100): A[i] = (A[i-1] + A[i-2])%10 if A[i] == 1 and A[i-1] == 9: period = i+1 break t = to % period f = (from_ - 1) % period if from_ == (0 or 1): return (2*A[t] + A[t-1] - 1) % 10 return (2*(A[t]-A[f]) + A[t-1] - A[f-1]) % 10print(fibonacci_partial_sum_fast(0, 1))print(fibonacci_partial_sum_fast(1, 2))print(fibonacci_partial_sum_fast(3, 7))print(fibonacci_partial_sum_fast(5, 7))print(fibonacci_partial_sum_fast(10, 10))print(fibonacci_partial_sum_fast(10, 200)) 1 2 1 6 5 2 12345678910A = [None]* (100)A[0] = 0A[1] = 1for i in range(2, to-1): A[i] = (A[i-1] + A[i-2]) % 10 if A[i] == 1 and A[i-1] == 9: period = i+1 breakt = (to-1) % periodreturn (2*(A[t]-A[] + A[t-1] - 1) % 10 斐波那契数平方之和的个位数 Last Digit of the Sum of Squares of Fibonacci Numbers Task. Compute the last digit of \(F_0^2 + F_1^2 + · · · + F_n^2\). Input Format. Integer n. Constraints. \(0 ≤ n ≤ 10^{18}\). Output Format. The last digit of \(F_0^2 + F_1^2 + · · · + F_n^2\). Sample 1. 1234Input:7Output:3 \(F_0^2 + F_1^2 + · · · + F_7^2 = 0 + 1 + 1 + 4 + 9 + 25 + 64 + 169 = 273\). Naive Algorithm 1234567891011121314151617def fibonacci_sum_squares_naive(n): if n &lt;= 1: return n previous = 0 current = 1 sum = 1 for _ in range(n - 1): previous, current = current, previous + current sum += current * current return sum % 10print(fibonacci_sum_squares_naive(7))print(fibonacci_sum_squares_naive(73))print(fibonacci_sum_squares_naive(211))print(fibonacci_sum_squares_naive(239)) 3 1 1 0 Fast Algorithm 斐波那契数列各项相加的平方和为： \[\sum_{n}a_n^2=a_1^2+a_2^2+\ldots + a_n^2=a_{n}a_{n+1}\] 12345678910111213141516171819202122def fibonacci_sum_squares_fast(n): if n &lt;= 1: return n A = [None]* (100) A[0] = 0 A[1] = 1 for i in range(2, 100): A[i] = (A[i-1] + A[i-2])%10 if A[i] == 1 and A[i-1] == 9: period = i+1 A[i+1] = (A[i-1] + A[i])%10 break t = n % period return (A[t] * A[t+1]) % 10print(fibonacci_sum_squares_fast(0))print(fibonacci_sum_squares_fast(7))print(fibonacci_sum_squares_fast(73))print(fibonacci_sum_squares_fast(211))print(fibonacci_sum_squares_fast(239))print(fibonacci_sum_squares_fast(832564823476)) 0 3 1 1 0 9 break 前面加了一行 A[i+1] = (A[i-1] + A[i])%10 的原因是，当余数为边界值period-1时，还要计算A[t+1] 参考： - Coursera：algorithmic toolbox(week2)]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>Algorithm - Fibonacci</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maximum Pairwise Product Problem]]></title>
    <url>%2F2018%2F09%2F25%2FMaximum_Pairwise%2F</url>
    <content type="text"><![CDATA[问题：两数最大乘积 Find the maximum product of two distinct numbers in a sequence of non-negative integers. Input: A sequence of non-negative integers. Output: The maximum value that can be obtained by multiplying two different elements from the sequence. Constraints: $ 2 ≤ n ≤ 2 · 10^5; 0 ≤ a_1,...,a_n ≤ 2 · 10^5 $. Sample: 1234Input:1 2 3Output:6 这个问题其实就是要找到列表中最大的两个数。 Naive Algorithm 1234567891011def max_pairwise_productNaive(A): n = len(A) max_product = 0 for i in range(n): for j in range(n): if i != j: if max_product &lt; A[i] * A[j]: max_product = A[i] * A[j] return max_productmax_pairwise_productNaive([9,2,4,5,6,7]) 63 代码可以优化为如下形式： 123456789def max_pairwise_productNaive(A): n = len(A) max_product = 0 for i in range(n): for j in range(i+1, n): max_product = max(max_product, A[i]*A[j]) return max_productmax_pairwise_productNaive([9,2,4,5,6,7]) 63 这样的代码在数值很大时会超过运行时间限制。 Fast Algorithm 第一次循环找到最大值，第二次循环找到除此之外的最大值。经过 2n 次比较,运行时间 O(n) 123456789101112131415161718def max_pairwise_productFast(A): n = len(A) j = 0 for i in range(1, n): if A[i] &gt; A[j]: j = i if j == 0: h = 1 else: h = 0 for i in range(1, n): if i!=j and A[i] &gt; A[h]: h = i return A[j]*A[h]max_pairwise_productFast([9,2,4,5,6,7]) 63 压力测试 是一种test和debug的方法。 12345678910111213141516import random def StressTest(N, M): while True: n = random.randint(2, N) A=[random.randint(0,M) for i in range(n)] print(A) result_1 = max_pairwise_productNaive(A) result_2 = max_pairwise_productFast(A) if result_1 == result_2: print("OK") else: print("Wrong answer:",result_1,result_2) returnStressTest(10,100000) 找出列表中最大的两个数 1234567891011121314151617def max_pairwise(A): n = len(A) max1 = A[0] max2 = A[1] if A[0] &lt; A[1]: max1, max2 = max2, max1 for i in range(2,n): if A[i] &gt;= max1: max2 = max1 max1 = A[i] elif(A[i] &lt; max1 and A[i] &gt; max2): max2 = A[i] return max1, max2max_pairwise([20,9,2,4,5,11,6,7,4,9,10]) (20, 11) 更简洁的写法 但运行时间较长，为 O(nlogn) 123456def max_pairwise_productSort(A): n = len(A) A.sort() return A[n-1] * A[n-2]max_pairwise_productSort([9,2,4,5,6,7]) 63 参考 Coursera_algorithmic-toolbox_week1]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>python -   Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[贝尔曼方程(The Bellman Equation)]]></title>
    <url>%2F2018%2F09%2F10%2FThe%20Bellman%20Equation%2F</url>
    <content type="text"><![CDATA[基本原理 贝尔曼方程（Bellman Equation）也被称作动态规划方程（Dynamic Programming Equation） \[ Q^{\pi}(s, a)=\sum_{s^{\prime}} \mathcal{P}_{s s^{\prime}}^{a}\left[\mathcal{R}_{s s^{\prime}}^{a}+\gamma \sum_{a^{\prime}} \pi\left(s^{\prime}, a^{\prime}\right) Q^{\pi}\left(s^{\prime}, a^{\prime}\right)\right] \] 其中，转移概率 \(\mathcal{P}\) 为 \[ \mathcal{P}_{s s^{\prime}}^{a}=\operatorname{Pr}\left(s_{t+1}=s^{\prime} | s_{t}=s, a_{t}=a\right) \] 期望奖励为 \(\mathcal{R}\) \[ \mathcal{R}_{s s^{\prime}}^{a}=\mathbb{E}\left[r_{t+1} | s_{t}=s, s_{t+1}=s^{\prime}, a_{t}=a\right] \] 从状态 \(s\) 开始，经过动作 \(a\) ，以概率 \(\mathcal{P}_{s s^{\prime}}^{a}\) 转到状态 \(s^{\prime}\) ， 期望奖励为 \(\mathcal{R}_{s s^{\prime}}^{a}\) 。 参考 Reinforcement Learning: an introduction” by Sutton and Barto (freely downloadable) Understanding RL: The Bellman Equations]]></content>
      <categories>
        <category>强化学习</category>
      </categories>
      <tags>
        <tag>强化学习</tag>
        <tag>原理</tag>
        <tag>Reinforcement Learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LogisticRegression的sklearn参数说明]]></title>
    <url>%2F2018%2F08%2F24%2Flogistic-regression-sklearn%2F</url>
    <content type="text"><![CDATA[class sklearn.linear_model.LogisticRegression(penalty=’l2’, dual=False, tol=0.0001, C=1.0, fit_intercept=True, intercept_scaling=1, class_weight=None, random_state=None, solver=’liblinear’, max_iter=100, multi_class=’ovr’, verbose=0, warm_start=False, n_jobs=1) 在scikit-learn中，主要是基于LogisticRegression模型来解决Logistic回归算法，其中，有两种不同的代价函数(cost function)： L1: \[ \min _ { w,c }\|w\| _ 1+C\sum _ { i=1 }^n log ( exp ( -y_ i(X _ { i }^ \mathrm { T }w+c))+1)\] L2： \[ \min _{ w, c } \frac { 1 }{ 2 }w^ \mathrm { T }w +C \sum _{ i=1 }^nlog(exp(-y _i (X _{i}^ \mathrm { T }w+c))+1)\] 每个式子中前一项是正则化项（Regularizer）（包含w的范数），后一项是损失函数（loss function），参数 C 控制了两者在最终的损失函数中所占的比重。 求解w参数的方法根据L1/L2代价函数的不同，也存在不同的求解拟合参数的方法： Case Solver L2 penalty “saga”, “liblinear” , “lbfgs”, “sag”, “newton-cg” L1 penalty “saga”, “liblinear” Multinomial loss “saga”, “lbfgs”, “sag”, “newton-cg” Very Large dataset (n_samples) “saga”, “sag” penalty：惩罚项，str类型，可选参数为l1和l2，默认为l2。 用于指定惩罚项中使用的规范。加上约束，使得模型更不会过拟合(overfit)，可以获得泛化能力更强的结果 newton-cg、sag和lbfgs求解算法只支持L2规范。 L1规范假设的是模型的参数满足拉普拉斯分布，L2假设的模型参数满足高斯分布， dual：对偶或原始方法，bool类型，默认为False。 对偶方法只用在求解线性多核(liblinear)的L2惩罚项上。 当样本数量&gt;样本特征的时候，dual通常设置为False。 tol：停止求解的标准，float类型，默认为1e-4。 就是求解到多少的时候，停止，认为已经求出最优解。 c：正则化系数λ的倒数，float类型，默认为1.0。必须是正浮点型数。 像SVM一样，越小的数值表示越强的正则化。 fit_intercept：是否存在截距或偏差，bool类型，默认为True。 intercept_scaling： float类型，默认为1。 仅在正则化项为“liblinear”，且fit_intercept设置为True时有用。 class_weight：用于标示分类模型中各种类型的权重. 默认为None，也就是不考虑权重。可以输入一个字典或者’balanced’字符串。 可以{class_label:weight}形式自己输入各个类型的权重。举个例子，比如对于0,1的二元模型，我们可以定义class_weight={0:0.9,1:0.1}，这样类型0的权重为90%，而类型1的权重为10%。 也可以选择balanced，那么类库会根据训练样本量来计算权重。某种类型样本量越多，则权重越低，样本量越少，则权重越高。类权重计算方法如下：n_samples/(n_classes *np.bincount(y))。 n_samples为样本数，n_classes为类别数量，np.bincount(y)会输出每个类的样本数，例如 y=[1,0,0,1,1], 则 np.bincount(y)=[2,3]。 那么class_weight有什么作用呢？ 在分类模型中，我们经常会遇到两类问题： 第一种是误分类的代价很高。比如对合法用户和非法用户进行分类，将非法用户分类为合法用户的代价很高，我们宁愿将合法用户分类为非法用户，这时可以人工再甄别，但是却不愿将非法用户分类为合法用户。这时，我们可以适当提高非法用户的权重。 第二种是样本是高度失衡的。比如我们有合法用户和非法用户的二元样本数据10000条，里面合法用户有9995条，非法用户只有5条，如果我们不考虑权重，则我们可以将所有的测试集都预测为合法用户，这样预测准确率理论上有99.95%，但是却没有任何意义。这时，我们可以选择balanced，让类库自动提高非法用户样本的权重。提高了某种分类的权重，相比不考虑权重，会有更多的样本分类划分到高权重的类别，从而可以解决上面两类问题。 random_state：随机数种子，int类型，可选参数，默认为None。 仅在正则化优化算法为 sag, liblinear 时有用。 solver：优化方法选择。默认为liblinear。 有五个可选参数，即newton-cg, lbfgs, liblinear, sag, saga。 liblinear：使用了开源的liblinear库实现，内部使用了坐标轴下降法来迭代优化损失函数。 lbfgs：L-BFGS算法，拟牛顿法的一种，利用损失函数二阶导数矩阵即海森矩阵来迭代优化损失函数。 newton-cg：也是牛顿法家族的一种，利用损失函数二阶导数矩阵即海森矩阵来迭代优化损失函数。 sag：即随机平均梯度下降(Stochastic Average Gradient descent)，是梯度下降法的变种，和普通梯度下降法的区别是每次迭代仅仅用一部分的样本来计算梯度，适合于样本数据多的时候。 saga：线性收敛的随机优化算法的的变重。 总结： liblinear适用于小数据集，而sag和saga适用于大数据集因为速度更快。 对于多分类问题，只有newton-cg,sag,saga和lbfgs能够处理多项损失，而liblinear受限于一对剩余(OvR)。意思就是用liblinear的时候，如果是多分类问题，得先把一种类别作为一个类别，剩余的所有类别作为另外一个类别。一次类推，遍历所有类别，进行分类。 newton-cg, sag 和 lbfgs 这三种优化算法时都需要损失函数的一阶或者二阶连续导数，因此不能用于没有连续导数的L1正则化，只能用于L2正则化。而 liblinear 和 saga 通吃L1正则化和L2正则化。 同时，sag每次仅仅使用了部分样本进行梯度迭代，所以当样本量少的时候不要选择它，而如果样本量非常大，比如大于10万，sag是第一选择。但是sag不能用于L1正则化，所以当你有大量的样本，又需要L1正则化的话就要自己做取舍了。要么通过对样本采样来降低样本量，要么回到L2正则化。 逻辑回归有二元逻辑回归和多元逻辑回归。对于多元逻辑回归常见的有one-vs-rest(OvR)和many-vs-many(MvM)两种。而MvM一般比OvR分类相对准确一些。而liblinear只支持OvR，不支持MvM，这样如果我们需要相对精确的多元逻辑回归时，就不能选择liblinear了。也意味着如果我们需要相对精确的多元逻辑回归不能使用L1正则化了。 max_iter：算法收敛最大迭代次数，int类型，默认为10。 仅在正则化优化算法为newton-cg, sag 和lbfgs才有用。 multi_class：分类方式选择参数，str类型，可选参数为ovr和multinomial，默认为ovr。 如果是二元逻辑回归，ovr和multinomial并没有任何区别，区别主要在多元逻辑回归上。 ovr即前面提到的one-vs-rest(OvR)。OvR的思想是无论你是多少元逻辑回归，我们都可以看做二元逻辑回归。具体做法是，对于第K类的分类决策，我们把所有第K类的样本作为正例，除了第K类样本以外的所有样本都作为负例，然后在上面做二元逻辑回归，得到第K类的分类模型。其他类的分类模型获得以此类推。 而multinomial即前面提到的many-vs-many(MvM)。MvM相对复杂，这里举MvM的特例one-vs-one(OvO)作讲解。如果模型有T类，我们每次在所有的T类样本里面选择两类样本出来，不妨记为T1类和T2类，把所有的输出为T1和T2的样本放在一起，把T1作为正例，T2作为负例，进行二元逻辑回归，得到模型参数。我们一共需要T(T-1)/2次分类。 可以看出OvR相对简单，但分类效果相对略差（这里指大多数样本分布情况，某些样本分布下OvR可能更好）。而MvM分类相对精确，但是分类速度没有OvR快。 如果选择了ovr，则4种损失函数的优化方法liblinear，newton-cg,lbfgs和sag都可以选择。但是如果选择了multinomial,则只能选择 newton-cg, lbfgs 和 sag 了。 verbose:日志冗长度，int类型。默认为0。就是不输出训练过程。 1的时候偶尔输出结果，大于1，对于每个子模型都输出。 warm_start：热启动参数，bool类型。默认为False。 如果为True，则下一次训练是以追加树的形式进行（重新使用上一次的调用作为初始化）。 n_jobs：并行数。int类型，默认为1。 1的时候，用CPU的一个内核运行程序， 2的时候，用CPU的2个内核运行程序。 为-1的时候，用所有CPU的内核运行程序。 参考 sklearn.linear_model.LogisticRegression-scikit-learn 0.19.2 documentation Logistic回归(Logistic Regression)算法笔记(二)-scikit learn LogisticRegression - 参数说明]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>sklearn</tag>
        <tag>逻辑回归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python3 zip(), lambda, map()]]></title>
    <url>%2F2018%2F08%2F19%2Fpython3%20zip()%2Clambda%2Cmap()%2F</url>
    <content type="text"><![CDATA[zip() 函数 函数用于将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的对象，这样做的好处是节约了不少的内存。简单来说，就是将序列合并打包。 我们可以使用list()转换来输出列表。 如果各个迭代器的元素个数不一致，则返回列表长度与最短的对象相同，利用 * 号操作符，可以将元组解压为列表。 语法 : zip(*iterables) 参数说明： iterables – 一个或多个迭代器,可以内置的迭代器（比如list, string, dict）也可以是用户自定义的迭代器(有__iter__方法的对象). 例1 基本用法 123456789101112numberList = [1, 2, 3]strList = ['one', 'two', 'three']result = zip() # 没有传入可迭代量resultList = list(result) # 转为列表print(resultList)result = zip(numberList, strList) # 传入两个可迭代量resultSet = set(result) # 转为集合print(resultSet) [] {(1, &#39;one&#39;), (3, &#39;three&#39;), (2, &#39;two&#39;)} 12a1, a2 = zip(*zip(a,b)) # 与 zip 相反，*zip 可理解为解压，返回二维矩阵式list(a1),list(a2) ([1, 2, 3], [4, 5, 6]) 例2 传入个数不同的可迭代量 1234567891011numbersList = [1, 2, 3]strList = ['one', 'two']numbersTuple = ('ONE', 'TWO', 'THREE', 'FOUR')result = zip(numbersList, numbersTuple) # 元素个数与最短的列表一致，3个resultSet = set(result)print(resultSet)result = zip(numbersList, strList, numbersTuple)# 2个元素resultSet = set(result)print(resultSet) {(2, &#39;TWO&#39;), (1, &#39;ONE&#39;), (3, &#39;THREE&#39;)} {(2, &#39;two&#39;, &#39;TWO&#39;), (1, &#39;one&#39;, &#39;ONE&#39;)} 例3 用*和zip()来解压列表 1234x = [1,2,3]y = [4,5,6]unzipped_x, unzipped_y = zip(*zip(x,y))print(unzipped_x, unzipped_y) (1, 2, 3) (4, 5, 6) 12345zipper_list = [(1, 'a'), (2, 'b'), (3, 'c')] l_a, l_b = zip(*zipper_list)print(l_a, l_b)print(list(l_a), list(l_b)) (1, 2, 3) (&#39;a&#39;, &#39;b&#39;, &#39;c&#39;) [1, 2, 3] [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;] lambda匿名函数 lambda表达式是一行函数。 它们在其他语言中也被称为匿名函数。如果你不想在程序中对一个函数使用两次，你也许会想用lambda表达式，它们和普通的函数完全一样。 语法 lambda 参数:操作(参数) 例1 基本用法 12add = lambda x, y: x + yprint(add(3, 5)) 8 例2 列表排序 12345a = [(1, 2), (4, 1), (9, 10), (13, -3)]a.sort(key=lambda x: x[1])print(a) # Output: [(13, -3), (4, 1), (1, 2), (9, 10)] [(13, -3), (4, 1), (1, 2), (9, 10)] 例3 在lambda中嵌套逻辑 可以使用if/else三元表达式，或者对等的但需要些技巧的and/or组合。正如我们前面所了解到的，如下语句： 1234if a: belse: c 能够由以下的概括等效的表达式来模拟： b if a else c ((a and b) or c) 因为这样类似的表达式能够放在lambda中，所以它们能够在lambda函数中来实现选择逻辑。 12lower = (lambda x, y: x if x &lt; y else y)lower('bb', 'aa') &#39;aa&#39; 例4 在lambda中执行循环 嵌入map调用或列表解析表达式这样的工具来实现。 123456import sysshowall = lambda x: list(map(sys.stdout.write, x)) # mapshowall(['spam\n', 'toast\n', 'eggs\n'])showall = lambda x: [sys.stdout.write(line) for line in x] # 列表解析showall(['music ', 'song ', 'sing']) spam toast eggs music song sing [None, None, None] map()函数 map() 将一个序列中的每一个迭代元素应用于给定函数， 并返回一个包含所有函数调用结果的一个列表. 语法 : map(fun, iter) 参数 : fun : 给定函数; iter : 可迭代序列(list, tuple 等等) 。 例1 基本用法 123456def addition(n): return n + nnumbers = (1, 2, 3, 4)result = map(addition, numbers)print(list(result)) [2, 4, 6, 8] 例2 在map()中使用lambda函数 123numbers = (1, 2, 3, 4)result = list(map(lambda x: x + x, numbers))print(result) [2, 4, 6, 8] 例3 传入多个迭代序列 12345numbers1 = [1, 2, 3]numbers2 = [4, 5, 6] result = list(map(lambda x, y: x + y, numbers1, numbers2))print(result) [5, 7, 9] 例4 列表中每个字符串分别序列化 1234l = ['sat', 'bat', 'cat', 'mat']test = list(map(list, l))print(test) [[&#39;s&#39;, &#39;a&#39;, &#39;t&#39;], [&#39;b&#39;, &#39;a&#39;, &#39;t&#39;], [&#39;c&#39;, &#39;a&#39;, &#39;t&#39;], [&#39;m&#39;, &#39;a&#39;, &#39;t&#39;]] 参考 Python zip() - programiz Python3 zip() 函数 | 菜鸟教程 lambda表达式 - python进阶 Python3之lambda匿名函数详解-Professor哥-51CTO博客 Python map() function - GeeksforGeeks]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>基础学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo常用命令]]></title>
    <url>%2F2018%2F06%2F21%2Fhexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[hexo init &lt;folder&gt; 创建并初始化一个站点文件夹 hexo new 'article title' 新增一篇文章 hexo clean 用于主题切换等涉及到站点整体布局效果改变时清除hexo原有缓存 文章编辑完后 开启本地服务器，测试静态页面的效果： hexo server 或 hexo s 为文章自动生成静态页面的文件：hexo generate 或 hexo g 将本地页面部署到GitHub Pages上：hexo deploy 或 hexo d (合并替换前两项)生成静态页面的文件并直接部署：hexo generate -d 或hexo deploy -g]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动词て形]]></title>
    <url>%2F2018%2F06%2F20%2F%E5%8A%A8%E8%AF%8D%E3%81%A6%E5%BD%A2%2F</url>
    <content type="text"><![CDATA[一类动词 词尾 替换 基本形 て形 (あうお段)+る って 売る (うる) うって う って 買う (かう) かって つ って 待つ (まつ) まって く いて 書く (かく) かいて ぐ いで 急ぐ (いそぐ) いそいで む んで 読む (よむ) よんで ぶ んで 飛ぶ (とぶ) とんで ぬ んで 死ぬ (しぬ) しんで す して 話す (はなす) はなして 只有“行(い)く”是例外，て形为“行(い)って”。 二类动词 词尾 替换 基本形 て形 (いえ段)+る て 見る (みる) みて 三类动词 词尾 替换 基本形 て形 する して する して くる きて 来る (くる) きて 用法 1. 请求对方做某事 动词て形 + ください - 黒板（こくばん）を 見て ください。 请看黑板。 - 早（はや）く 来て ください。 请快点儿来。 - ちょっと 待って ください。 请等一下。]]></content>
      <categories>
        <category>日语学习</category>
      </categories>
      <tags>
        <tag>动词</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模型选择]]></title>
    <url>%2F2018%2F04%2F16%2F%E6%A8%A1%E5%9E%8B%E9%80%89%E6%8B%A9%2F</url>
    <content type="text"><![CDATA[评估回归模型 这里将都使用波士顿房价的数据集，用10折交叉验证来分离数据，通过均方误差来评估模型性能。 在scikit-learn中用cross_val_score()函数来测试模型，选用负均方误差（neg_mean_squared_error）作为score，得分是负数，这里的neg_mean_squared_error是一种奖励函数，优化的目标是使其最大化。 线性算法 线性回归 12345678910111213141516import pandas as pdfrom sklearn.model_selection import KFoldfrom sklearn.model_selection import cross_val_scorefrom sklearn.linear_model import LinearRegression#导入数据data = pd.read_csv('housing.csv')#划分数据X = data.values[:,0:13]Y = data.values[:,13]seed = 7kfold = KFold(n_splits=10, random_state = seed)model = LinearRegression()scoring = 'neg_mean_squared_error'result = cross_val_score(model, X, Y, cv=kfold, scoring=scoring)print('Linear Regression: %.3f' %result.mean()) 执行结果如下： 1Linear Regression: -34.705 岭回归(Ridge Regression) 岭回归是加入L2正则的最小二乘，Sklearn库提供了函数Ridge(alpha)，alpha是超参数，是正则化项的系数，用来弱化变量参数共线性，限制变量权重（参数）过大，alpha越大，越不容易过拟合。 12345678910111213141516import pandas as pdfrom sklearn.model_selection import KFoldfrom sklearn.model_selection import cross_val_scorefrom sklearn.linear_model import Ridge#导入数据data = pd.read_csv('housing.csv')#划分数据X = data.values[:,0:13]Y = data.values[:,13]seed = 7kfold = KFold(n_splits=10, random_state = seed)model = Ridge()scoring = 'neg_mean_squared_error'result = cross_val_score(model, X, Y, cv=kfold, scoring=scoring)print('Ridge Regression: %.3f' %result.mean()) 执行结果如下： 1Ridge Regression: -34.078 LASSO回归 12345678910111213141516import pandas as pdfrom sklearn.model_selection import KFoldfrom sklearn.model_selection import cross_val_scorefrom sklearn.linear_model import Lasso#导入数据data = pd.read_csv('housing.csv')#划分数据X = data.values[:,0:13]Y = data.values[:,13]seed = 7kfold = KFold(n_splits=10, random_state = seed)model = Lasso()scoring = 'neg_mean_squared_error'result = cross_val_score(model, X, Y, cv=kfold, scoring=scoring)print('Lasso Regression: %.3f' %result.mean()) 执行结果如下： 1Lasso Regression: -34.464 弹性网络(Elastic Net)回归 1234567891011121314151617import pandas as pdfrom sklearn.model_selection import KFoldfrom sklearn.model_selection import cross_val_scorefrom sklearn.linear_model import ElasticNet#导入数据data = pd.read_csv('housing.csv')#划分数据X = data.values[:,0:13]Y = data.values[:,13]seed = 7kfold = KFold(n_splits=10, random_state = seed)scoring = 'neg_mean_squared_error'model = ElasticNet()result = cross_val_score(model, X, Y, cv=kfold, scoring=scoring)print('ElasticNet Regression: %.3f' % result.mean()) 执行结果如下： 1ElasticNet Regression: -31.165 非线性算法 这里介绍在scikit-learn中的三种非线性的机器学习的回归算法。 K近邻（KNN） 决策树（CART） 支持向量机（SVM） 这三个算法在分类算法中同样存在，代码类似于上面的算法，这里就写在一起。 1234567891011121314151617181920212223242526import pandas as pdfrom sklearn.model_selection import KFoldfrom sklearn.model_selection import cross_val_scorefrom sklearn.neighbors import KNeighborsRegressorfrom sklearn.tree import DecisionTreeRegressorfrom sklearn.svm import SVR#导入数据data = pd.read_csv('housing.csv')#划分数据X = data.values[:,0:13]Y = data.values[:,13]seed = 7kfold = KFold(n_splits=10, random_state = seed)scoring = 'neg_mean_squared_error'models = &#123;&#125;models['KNN'] = KNeighborsRegressor()models['DecisionTree'] = DecisionTreeRegressor()models['SVM'] = SVR()results = []for name in models: result = cross_val_score(models[name], X, Y, cv=kfold, scoring=scoring) results.append(result) print('%s: %.3f' % (name, result.mean())) 执行结果如下： 123KNN: -107.287DecisionTree: -44.421SVM: -91.048 评估分类模型 这里会介绍6种分类算法： 线性算法： 逻辑回归 线性判别（LDA） 非线性算法： K近邻（KNN） 贝叶斯分类器 决策树 支持向量机（SVM） 12345678910111213141516171819202122232425262728293031323334353637383940414243import pandas as pdfrom matplotlib import pyplotfrom sklearn.model_selection import KFoldfrom sklearn.model_selection import cross_val_scorefrom sklearn.linear_model import LogisticRegressionfrom sklearn.discriminant_analysis import LinearDiscriminantAnalysisfrom sklearn.neighbors import KNeighborsClassifierfrom sklearn.tree import DecisionTreeClassifierfrom sklearn.svm import SVCfrom sklearn.naive_bayes import GaussianNB#导入数据data = pd.read_csv('pima_data.csv')#划分数据X = data.values[:,0:8]Y = data.values[:,8]seed = 7kfold = KFold(n_splits=10, random_state = seed)models = &#123;&#125;models['LR'] = LogisticRegression()models['LDA'] = LinearDiscriminantAnalysis()models['KNN'] = KNeighborsClassifier()models['CART'] = DecisionTreeClassifier()models['SVM'] = SVC()models['NB'] = GaussianNB()results = []for name in models: result = cross_val_score(models[name], X, Y, cv=kfold) results.append(result) print('%s: %.3f(%.3f)' % (name, result.mean(), result.std()))# 图表显示fig = pyplot.figure()fig.suptitle('Algorithm Comparison')ax = fig.add_subplot(111)pyplot.boxplot(results)ax.set_xticklabels(models.keys())pyplot.show() 执行结果如下： 123456LR: 0.770(0.048)LDA: 0.773(0.052)KNN: 0.727(0.062)CART: 0.690(0.062)SVM: 0.651(0.072)NB: 0.755(0.043) 图表显示 参考： 1.《机器学习之python》]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>sklearn</tag>
        <tag>机器学习</tag>
        <tag>模型选择</tag>
        <tag>交叉验证法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Conda常用命令]]></title>
    <url>%2F2018%2F02%2F14%2FConda%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[Conda 环境 123456789101112131415161718192021222324252627282930313233343536# 创建一个名为python34的环境，指定Python版本是3.4 conda create --name python34 python=3.4# 激活某个环境activate python34 # for Windowssource activate python34 # for Linux &amp; Macdeactivate python34 # for Windowssource deactivate python34 # for Linux &amp; Mac# 删除一个已有的环境conda remove --name python34 --all# 创建制定python版本的环境conda create --name your_env_name python=2.7conda create --name your_env_name python=3conda create --name your_env_name python=3.5# 创建包含某些包的环境conda create --name your_env_name numpy scipy# 创建指定python版本下包含某些包的环境conda create --name your_env_name python=3.5 numpy scipy# 列举当前所有环境conda info --envsconda env list# 进入某个环境activate your_env_name# 退出当前环境deactivate # 复制某个环境conda create --name new_env_name --clone old_env_name Conda包管理 123456789101112131415161718192021# 安装xxxxconda install xxxx# 查看当前环境下已安装的包conda list# 查看某个指定环境的已安装包conda list -n python34# 查找package信息conda search numpy# 安装package# 如果不用-n指定环境名称，则被安装在当前活跃环境 也可以通过-c指定通过某个channel安装conda install -n python34 numpy # 加一个-c表示从http://anaconda.org下载资源包conda install -c spyder-ide spyder=3.0.0# 更新所有库conda update --all cheat-sheet下载]]></content>
      <categories>
        <category>cheatsheet</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>basic</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Logistic回归]]></title>
    <url>%2F2018%2F01%2F23%2Flogistic-regression%2F</url>
    <content type="text"><![CDATA[基本原理 Logistic回归是统计学习中的经典分类方法。其实仅在线性回归的基础上，套用了一个逻辑函数。本文主要详述逻辑回归模型的基础。 假设有输入向量 \(x=(x_1;x_2;...;x_n)\)， 由线性回归模型产生的预测值 \[z=w ^ \mathrm{ T }x+b\tag{1}\] 是实值，需要转换为 0/1 值才能进行分类。因此找一个单调可微函数来替代，将\(z\) 的值映射到 (0,1) 之间，这里采用logistic函数： \[y=\frac{1}{1+e^{-z}}\tag{2}\] 从图中可以看出，对数几率函数是一种“Sigmoid函数”，当 \(z=0\) 时，函数值为0.5。随着 \(z\) 的增大，对应的值将逼近于1；而随着 \(z\) 的减小，输出值将逼近于0。如果横坐标刻度足够大，函数将看起来很像一个阶跃函数，其输出值在 \(z=0\) 附近变化很陡。 将式(1)代入得到 \[y=\frac{1}{1+e^{-(w ^ \mathrm{ T }x+b)}}\tag{3}\] 上式就是logistic回归模型的分类函数。最后， \(y\) 是一个范围在0~1之间的数值。结果大于0.5的数据被归入1类，小于0.5的即被归入0类。所以，Logistic回归也可以被看成是一种概率估计。 (3)式可变化为对数几率形式： \[\ln \frac{y}{1-y}=w ^ \mathrm{ T }x+b\tag{4}\] 由此看出，真实标记 \(y\) 的对数几率是输入 \(x\) 的线性函数。 将 \(y\) 视为类后验概率估计 \(p(y=1|x)\) ，则上式可重写为 \[\ln \frac{p(y=1|x)}{p(y=0|x)}=w ^ \mathrm{ T }x+b\tag{5}\] 显然有 \[p(y=1|x)=\frac{e^{w ^ \mathrm{ T }x+b}}{1+e^{w ^ \mathrm{ T }x+b}}\tag{6}\] \[p(y=0|x)=\frac{1}{1+e^{w ^ \mathrm{ T }x+b}}\tag{7}\] 此时线性函数的值越接近正无穷，概率值就越接近1；线性函数的值越接近负无穷，概率值就越接近0。由此得以分类。 接下来可通过“极大似然法”来估计 \(w\) 和 \(b\) 。 # 用优化方法来估计参数 优化方法有很多，这里主要了解梯度下降，牛顿法和BFGS 参考 浅析Logistic Regression]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>原理</tag>
        <tag>机器学习</tag>
        <tag>Logistic回归</tag>
      </tags>
  </entry>
</search>
