<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[用python刷LeetCode链表题(中等级)]]></title>
    <url>%2F2019%2F04%2F05%2F%E7%94%A8python%E5%88%B7LeetCode%E9%93%BE%E8%A1%A8%E9%A2%98(%E4%B8%AD%E7%AD%89%E7%BA%A7)%2F</url>
    <content type="text"><![CDATA[两两交换链表中的节点 LeetCode 24. 两两交换链表中的节点 Swap Nodes in Pairs 题目描述 给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。 示例: 1给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3. 方法 a, b, pre 三个变量 123456789101112131415# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def swapPairs(self, head: ListNode) -&gt; ListNode: pre, pre.next = self, head while pre.next and pre.next.next: #考虑奇数和偶数 a = pre.next b = a.next # a,b是要调换的相邻元素 pre.next, b.next, a.next =b, a, b.next # next连线重置 pre = a return self.next]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>LeetCode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划]]></title>
    <url>%2F2019%2F04%2F05%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%2F</url>
    <content type="text"><![CDATA[递归 + 记忆化 ——&gt; 递推（动态规划） 状态的定义：数组 opt[n], dp[n], fib[n] 状态转移方程：opt[n] = best_of(opt[n-1], opt[n-2], ...) 从前面的n-1个值得到最优的第n个值 最优子结构 学习内容： LeetCode 509. 斐波那契数列 LeetCode 70. 爬楼梯 0-1 背包问题 最小路径和（详细可看 Minimum Path Sum） 编程实现莱文斯坦最短编辑距离 编程实现查找两个字符串的最长公共子序列 编程实现一个数据序列的最长递增子序列 斐波那契数列求值 f(n)=f(n-1)+f(n-2) LeetCode 509. Fibonacci Number 斐波那契数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。 [0,1,1,2,3,5,8,13,...] 给定n,计算 f(N) 方法：动态规划 递归 + 记忆化 -&gt; 递推 递推公式：A[i] = A[i-1] + A[i-2] 12345678910class Solution: def fib(self, N: int) -&gt; int: if (N &lt;= 1): return N A = [None]*(N+1) A[0] = 0 A[1] = 1 for i in range(2, N+1): A[i] = A[i-1] + A[i-2] return A[N] 更简洁的写法： 123456789class Solution: def fib(self, N: int) -&gt; int: if (N &lt;= 1): return N previous = 0 current = 1 for _ in range(N-1): previous, current = current, previous + current return current LeetCode 70. 爬楼梯 Climbing Stairs 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 注意：给定 n 是一个正整数。 示例 ： 123456输入： 3输出： 3解释： 有三种方法可以爬到楼顶。1. 1 阶 + 1 阶 + 1 阶2. 1 阶 + 2 阶3. 2 阶 + 1 阶 方法：动态规划 当有n个台阶时，可供选择的走法可以分两类：1，先跨一阶再跨完剩下n-1阶；2，先跨2阶再跨完剩下n-2阶。所以n阶的不同走法的数目是n-1阶和n-2阶的走法数的和。 这和斐波那契数列的规律相同，可以用这个思路。 动态规划来记录历史数据。 12345678910class Solution: def climbStairs(self, n): """ :type n: int :rtype: int """ prev, current = 0, 1 for i in range(n): prev, current = current, prev + current return current]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>LeetCode</tag>
        <tag>数据结构</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[随机森林(Random Forest)算法梳理]]></title>
    <url>%2F2019%2F04%2F04%2F%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97%2F</url>
    <content type="text"><![CDATA[学习任务： 集成学习 什么是集成学习？ 集成学习的种类有哪些？ 集成学习的基本步骤：个体学习器的选择、训练、结合 bagging算法 随机森林思想 随机森林的推广 sklearn参数 集成学习 集成学习（ensemble learning）是机器学习中的一种思想，而不是指某一具体算法，它通过构建并结合多个学习器来完成学习任务。 集成学习通过将多个学习器进行结合，常可获得比单一学习器显著优越的泛化性能。 集成学习的种类 根据个体学习器的生成方式，目前的集成学习方法大致可分为两大类： 个体学习器问存在强依赖关系、必须串行生成的序列化方法，代表是 Boosting； 个体学习器间不存在强依赖关系、可同时生成的并行化方法，代表是 Bagging 和&quot;随机森林&quot; (Random Forest)。 Boosting 的基本思路是将基分类器层层叠加， 每一层在训练的时候， 对前一层基分类器中分错的样本， 给予更高的权重。 测试时， 根据各层分类器的结果的加权得到最终结果。（降低偏差） Bagging 方法更像是一个集体决策的过程， 每个个体都进行单独学习， 学习的内容可以相同， 也可以不同， 也可以部分重叠。 但由于个体之间存在差异性， 最终做出的判断不会完全一致。 在最终做决策时， 每个个体单独作出判断， 再通过投票的方式做出最后的集体决策。 （降低方差） 集成学习的基本步骤 集成学习一般可分为以下3个步骤。 找到误差互相独立的个体学习器。 这里可以选取ID3决策树作为基分类器。 事实上， 任何分类模型都可以作为基分类器， 但树形模型由于结构简单且较易产生随机性所以比较常用。 训练个体学习器。 在集成学习中需有效地生成多样性大的个体学习器。与简单地直接用初始数据训练出个体学习器相比，如何增强多样性呢?一般思路是在学习过程中引入随机性，常见做法主要是对数据样本、 输入属性、输出表示 、 算法参数进行扰动。 数据样本扰动：通常是基于采样法， 例如在 Bagging中使用自助采样(即有放回的采样)，在 AdaBoost 中使用序列采样. 输入属性扰动：从初始属性集中抽取出若干个属性子集，再基于每个属性子集训练一个基学习器。比如随机子空间 (random subspace)算法。 输出表示扰动：可对训练样本的类标记稍作变动，如&quot;翻转法&quot; (Flipping Output)随机改变一些训练样本的标记;也可对输出表示进行转化，如&quot;输出调制法&quot; (Output Smearing) 将分类输出转化为回归输出后构建个体学习器; 算法参数扰动：基学习算法一般都有参数需进行设置，例如神经网络的隐层神经元数、初始连接权值等。通过随机设置不同的参数，往往可产生差别较大的个体学习器. 合并个体学习器的结果。 常见的结合策略：平均法(averaging)，投票法(voting)，学习法(比如 stacking) averaging 常用于数值型输出。有简单平均法、加权平均法等。 voting 是用投票的方式， 将获得最多选票的结果作为最终的结果。常用于分类任务。 stacking 是用串行的方式， 把前一个基分类器的结果输出到下一个分类器， 将所有基分类器的输出结果相加（或者用更复杂的算法融合） 作为最终的输出。 Bagging算法 采样，训练 在Bootstrap(有放回抽样)的基础上可以构造出Bagging（Bootstrap Aggregating）算法。这种方法对训练样本集进行多次Bootstrap抽样，用每次抽样形成的数据集训练一个弱学习器模型，得到多个独立的弱学习器（对于分类问题，称为弱分类器），最后用它们的组合进行预测。 结合策略 在对预测输出进行结合时， Bagging 通常对分类任务使用简单投票法，对回归任务使用简单平均法. 若分类预测时出现两个类收到同样票数的情形，则最简单的做法是随机选择一个，也可进一步考察学习器投票的置信度来确定最终胜者. 算法特点 假定基学习器的计算复杂度为 O(m) ， 则 Bagging 的复杂度大致为\(T(O(m) + O (s))\) ，考虑到采样与投票/平均过程的复杂度 \(O(s)\) 很小，而\(T\)通常是一个不太大的常数，因此，训练一个 Bagging 集成与直接使用基学习算法训练一个学习器的复杂度同阶，这说明 Bagging 是一个很高效的集成学习算法. 因为Boostrap采样过程，每个基学习器只使用了初始训练集中约 63.2% 的样本，那么剩下约 36.8% 的样本可用作验证集来对泛化性能进行&quot;包外估计&quot; (out-oιbag estimate) 从偏差方差分解的角度看， Bagging 主要关注降低方差，因此它在不剪枝 决策树、神经网络等易受样本扰动的学习器上效用更为明显. 随机森林思想 随机森林(Random Forest，简称RF)是 Bagging 的一个扩展变体. RF 在以决策树为基学习器构建 Bagging 集成的基础上，进一步在决策树的训练过程中引入了随机属性选择. (数据样本扰动 + 输入属性扰动) 传统决策树在选择划分属性时是在当前结点的属性集合(假定有 d 个属性)中选择一个最优属性; 而在RF 中，对基决策树的每个结点，先从该结点的属性集合中随机选择一个包含 k 个属性的子集，然后再从这个子集中选择一个最优属性用于划分. 这里的参数 k 控制了随机性的引入程度： 若令 \(k = d\) ， 则基决策树的构建与传统决策树相同; 若令 \(k = 1\) ， 则是随机选择一个属性用于划分 ; 一般情况下，推荐值 \(k = log_{2}d\) 特点 随机森林简单、容易实现、计算开销小，令人惊奇的是，它在很多现实任务中展现出强大的性能。 随机森林的训练效率常优于 Bagging。 因为在个体决策树的构建过程中，Bagging使用的是 &quot;确定型&quot; 决策树，在选择划分属性时要对结点的所有属性进行考察，而随机森林使用的&quot;随机型&quot;决策树则只需考察一个属性子集。 由于可以随机选择决策树节点划分特征，这样在样本特征维度很高的时候，仍然能高效的训练模型。 在训练后，可以给出各个特征对于输出的重要性。 缺点 在某些噪音比较大的样本集上，RF模型容易陷入过拟合。 随机森林的推广 基于RF，有很多变种算法，应用也很广泛，不光可以用于分类回归，还可以用于特征转换，异常点检测等。 sklearn参数 RF的分类器是RandomForestClassifier，回归器是RandomForestRegressor。RF需要调的参数包括两部分，第一部分是Bagging框架的参数，第二部分是CART决策树的参数。 1234567891011class sklearn.ensemble.RandomForestClassifier( n_estimators=’warn’, criterion=’gini’, max_depth=None, min_samples_split=2, min_samples_leaf=1, min_weight_fraction_leaf=0.0, max_features=’auto’, max_leaf_nodes=None, min_impurity_decrease=0.0, min_impurity_split=None, bootstrap=True, oob_score=False, n_jobs=None, random_state=None, verbose=0, warm_start=False, class_weight=None) Bagging框架的参数解释 n_estimators：弱学习器的最大迭代次数，或者说最大的弱学习器的个数。 一般来说n_estimators太小，容易过拟合，太大又容易欠拟合，一般选择一个适中的数值。默认是100.实际调参的过程中，我们常常将n_estimators和下面介绍的参数learning_rate一起考虑。 oob_score：即是否采用袋外样本来评估模型的好坏。默认设置False。个人推荐设置为True，因为袋外分数反应了一个模型拟合后的泛化能力。 criterion：即CART决策树做划分时对特征的评价标准。分类模型和回归模型的损失函数不一样。 分类RF对应的CART分类树默认是基尼系数，另一个可选择的标准是信息增益。 回归RF对应的CART回归树默认是均方差mse，另一个可以选择的标准时绝对值mae。 一般来说选择默认的标准就已经很好了。 RF重要的框架参数比较少，主要关注的是n_estimators，即RF最大的决策树个数。 RF决策树参数 RF的决策树参数，它要调参的参数基本和GBDT相同，如下: max_features:RF划分时考虑的最大特征，可以使用很多种类型的值. 默认是&quot;auto&quot;，意味着划分时最多考虑 \(\sqrt{N}\) 个特征； 如果是&quot;log2&quot;意味着划分时最多考虑 \(log_{2}N\) 个特征； 如果是&quot;sqrt&quot;或者&quot;auto&quot;意味着划分时最多可考虑 \(\sqrt{N}\) 个特征。 如果是整数，代表考虑的特征绝对数。 如果是浮点数，代表考虑特征百分比，即考虑（百分比xN）取整后的特征数。 其中N为样本总特征数。 一般我们默认的&quot;auto&quot;就可以了，如果特征数非常多，我们可以灵活使用刚才描述的其他取值来控制划分时考虑的最大特征数，以控制决策树的生成时间。 max_depth: 决策树最大深度。默认可以不输入，如果不输入的话，决策树在建立子树的时候不会限制子树的深度。 一般来说，数据少或者特征少的时候可以不管这个值。 如果模型样本量多，特征也多的情况下，推荐限制这个最大深度，具体的取值取决于数据的分布。常用的可以取值10-100之间。 min_samples_split: 内部节点再划分所需最小样本数。这个值限制了子树继续划分的条件，如果某节点的样本数少于min_samples_split，则不会继续再尝试选择最优特征来进行划分。 默认是2.如果样本量不大，不需要管这个值。如果样本量数量级非常大，则推荐增大这个值。 min_samples_leaf: 叶子节点最少样本数。这个值限制了叶子节点最少的样本数，如果某叶子节点数目小于样本数，则会和兄弟节点一起被剪枝。 默认是1,可以输入最少的样本数的整数，或者最少样本数占样本总数的百分比。如果样本量不大，不需要管这个值。如果样本量数量级非常大，则推荐增大这个值。 min_weight_fraction_leaf：叶子节点最小的样本权重和。这个值限制了叶子节点所有样本权重和的最小值，如果小于这个值，则会和兄弟节点一起被剪枝。 默认是0，就是不考虑权重问题。一般来说，如果我们有较多样本有缺失值，或者分类树样本的分布类别偏差很大，就会引入样本权重，这时我们就要注意这个值了。 max_leaf_nodes: 最大叶子节点数。通过限制最大叶子节点数，可以防止过拟合，默认是&quot;None”，即不限制最大的叶子节点数。如果加了限制，算法会建立在最大叶子节点数内最优的决策树。如果特征不多，可以不考虑这个值，但是如果特征很多的话，可以加以限制，具体的值可以通过交叉验证得到。 min_impurity_split: 节点划分最小不纯度。这个值限制了决策树的增长，如果某节点的不纯度(基于基尼系数，均方差)小于这个阈值，则该节点不再生成子节点。即为叶子节点 。一般不推荐改动默认值1e-7。 上面决策树参数中最重要的包括最大特征数 max_features， 最大深度 max_depth， 内部节点再划分所需最小样本数min_samples_split 和叶子节点最少样本数 min_samples_leaf。 参考 《机器学习》周志华 《百面机器学习》诸葛越 随机森林概述 by SIGAI 随机森林算法介绍(理论) scikit-learn随机森林调参小结]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>sklearn</tag>
        <tag>机器学习</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[梯度提升树(GBDT)算法梳理]]></title>
    <url>%2F2019%2F04%2F04%2F%E6%A2%AF%E5%BA%A6%E6%8F%90%E5%8D%87%E5%86%B3%E7%AD%96%E6%A0%91(GBDT)%E7%AE%97%E6%B3%95%E6%A2%B3%E7%90%86%2F</url>
    <content type="text"><![CDATA[梯度提升决策树（Gradient Boosting Decision Tree， GBDT）是Boosting算法中非常流行的模型，也是近来在机器学习竞赛、商业应用中表现都非常优秀的模型。GBDT非常好地体现了“从错误中学习”的理念，基于决策树预测的残差进行迭代的学习。 学习任务： 前向分步算法 负梯度拟合 损失函数 回归 二分类，多分类 正则化 优缺点 sklearn参数 GDBT 基本思想是根据当前模型损失函数的负梯度信息来训练新加入的弱分类器， 然后将训练好的弱分类器以累加的形式结合到现有模型中。 采用决策树作为弱分类器的Gradient Boosting算法被称为GBDT，有时又被称为MART（Multiple Additive Regression Tree）。GBDT中使用的决策树通常为CART。 GBDT中每一棵树学的是之前所有树结论和的残差， 这个残差就是一个加预测值后能得真实值的累加量。 举例子来说，假设对每个用户的年龄做出预测，例如用户A的真实年龄是25岁， 但第一棵决策树的预测年龄是22岁， 差了3岁， 即残差为3。 那么在第二棵树里我们把A的年龄设为3岁去学习， 如果第二棵树能把A分到3岁的叶子节点， 那两棵树的结果相加就可以得到A的真实年龄； 如果第二棵树的结论是5岁， 则A仍然存在−2岁的残差， 第三棵树里A的年龄就变成−2岁，继续学。 这里使用残差继续学习， 就是GBDT中Gradient Boosted所表达的意思。 前向分步算法 在GBDT的迭代中，假设我们前一轮迭代得到的强学习器（即当前模型）是 \(f_{m-1}(x)\), 损失函数是 \(L(y, f_{m-1}(x))\) , 我们本轮迭代的目标是找到一个CART回归树模型的弱学习器 \(h(x:\alpha_{m})\)，让本轮的损失函数 \(L(y, f_{m}(x) =L(y, f_{m-1}(x)+ h(x:\alpha))\) 最小。也就是说，从前向后，每一步只学习一个基函数及其系数，逐步逼近优化损失函数。 输入：训练数据集 \(T=\{(x_,y_1),(x_2,y_2), ...(x_N,y_N)\}\); 损失函数是 \(L(y, f(x))\); 基函数集 \({h(x:\alpha)}\); 输出：加法模型\(f(x)\). 初始化\(f_{0}(x)=0\) For \(m=1\) to \(M\) do： 通过极小化损失函数(如下公式1)得到下一颗决策树的参数:\(\beta_{m},\alpha_{m}\). \[(\beta_{m},\alpha_{m}) = arg\min \limits_{\beta,\alpha}\sum\limits_{i=1}^{N} L(y_i,f_{m-1}(x_i) + \beta h(x:\alpha))\tag{1}\] 更新 \[f_{m}(x) = f_{tm-1}(x) + \beta_{m} h(x:\alpha_{m}))\tag{2}\] 5. 前三步循环结束即可得到加法模型： \[f(x) = f_{M}(x) = \sum\limits_{m=1}^{M} \beta_{m} h(x:\alpha_{m}))\tag{3}\] GBDT 的负梯度拟合 若上述算法采用平方误差损失函数, \[L(y, f(x)) = (y-f(x))^2\tag{4}\] 其损失变为 \[L(y,f_{m-1}(x) + \beta h(x:\alpha) \\=[y-f_{m-1}(x) - \beta h(x:\alpha)]^2 \\=[r - \beta h(x:\alpha)]^2\] 这里， \[r = y - f_{m-1}(x)\tag{5}\] 是当前模型拟合数据的残差（residual ). 所以， 对冋归问题的提升树算法来说，只需简单地拟合当前模型的残差. 提升树利用加法模型与前向分歩算法实现学习的优化过程. 当损失函数是平方损失和指数损失函数时， 每一步优化是很简单的. 但对一般损失函数而言， 往往每一步优化并不那么容易. 损失函数各种各样，怎么找到一种通用的拟合方法呢？ 针对这一问题， Freidman 提出了梯度提升（gradient boosting) 算法. 这是利用最速下降法的近似方法， 其关键是利用损失函数的负梯度在当前模型的值来拟合本轮损失（即残差）的近似值。第m轮的第i个样本的损失函数的负梯度表示为下式(6): \[r_{mi} = -\bigg[\frac{\partial L(y_i, f(x_i)))}{\partial f(x_i)}\bigg]_{f(x) = f_{m-1}\;\; (x)}\tag{6}\] GBDT 的算法思想 在每一轮迭代中， 计算出当前模型在所有样本上的负梯度（可以作为残差的近似值） 以该值为目标训练一个新的弱分类器进行拟合 计算出该弱分类器的权重 最终实现对模型的更新 Gradient Boosting算法的伪代码如下： 输入：训练数据集 \(T=\{(x_,y_1),(x_2,y_2), ...(x_N,y_N)\}\); 损失函数是 \(L(y, f(x))\); 基函数集 \({h(x:\alpha)}\); 输出：加法模型\(f(x)\). 初始化\(f_{0}(x)= arg\min \limits_{\rho}\sum\limits_{i=1}^{N} L(y_i,\rho))\) For \(m=1\) to \(M\) do： 计算负梯度 \[r_{mi} = -\bigg[\frac{\partial L(y_i, f(x_i)))}{\partial f(x_i)}\bigg]_{f(x) = f_{m-1}\;\; (x)}\tag{6}\] 通过极小化损失函数得到新的学习器的参数:下降的步长\(\beta_{m}\)和方向 \(\alpha_{m}\). \[\alpha_{m} = arg\min \limits_{\beta,\alpha}\sum\limits_{i=1}^{N} (r_{mi} - \beta h(x_i:\alpha))^2\tag{7}\] - (3) 计算新学习器的权重 \[\rho_m = arg\min \limits_{\rho}\sum\limits_{i=1}^{N} L(y_i,f_{m-1}(x_i) + \rho h(x_i:\alpha_{m}))\tag{8}\] 更新 \[f_{m}(x) = f_{m-1}(x) + \rho_{m} h(x:\alpha_{m}))\tag{9}\] 5. 循环结束即可得到加法模型： \[f(x) = f_{M}(x) = \sum\limits_{m=1}^{M} \rho_{m} h(x:\alpha_{m}))\tag{10}\] 由于GBDT是利用残差训练的， 在预测的过程中， 我们需要把所有树的预测值加起来， 得到最终的预测结果。 GBDT回归算法 输入是训练集样本\(T=\{(x_,y_1),(x_2,y_2), ...(x_m,y_m)\}\)， 最大迭代次数T, 损失函数L。 输出是强学习器f(x) 初始化弱学习器 \[f_0(x) = \underbrace{arg\; min}_{c}\sum\limits_{i=1}^{m}L(y_i, c)\] 对迭代轮数t=1,2,...T有： a)对样本i=1,2，...m，计算负梯度 \[r_{ti} = -\bigg[\frac{\partial L(y_i, f(x_i)))}{\partial f(x_i)}\bigg]_{f(x) = f_{t-1}\;\; (x)}\] b)利用\((x_i,r_{ti})\;\; (i=1,2,..m)\), 拟合一颗CART回归树,得到第t颗回归树，其对应的叶子节点区域为\(R_{tj}, j =1,2,..., J\)。其中J为回归树t的叶子节点的个数。 对叶子区域j =1,2,..J,计算最佳拟合值 \[c_{tj} = \underbrace{arg\; min}_{c}\sum\limits_{x_i \in R_{tj}} L(y_i,f_{t-1}(x_i) +c)\] 更新强学习器 \[f_{t}(x) = f_{t-1}(x) + \sum\limits_{j=1}^{J}c_{tj}I(x \in R_{tj})\] 得到强学习器f(x)的表达式 \[f(x) = f_T(x) =f_0(x) + \sum\limits_{t=1}^{T}\sum\limits_{j=1}^{J}c_{tj}I(x \in R_{tj})\] GBDT分类算法 GBDT的分类算法从思想上和GBDT的回归算法没有区别，但是由于样本输出不是连续的值，而是离散的类别，导致我们无法直接从输出类别去拟合类别输出的误差。 为了解决这个问题，主要有两个方法， 用指数损失函数，此时GBDT退化为Adaboost算法。 是用类似于逻辑回归的对数似然损失函数的方法。也就是说，我们用的是类别的预测概率值和真实概率值的差来拟合损失。 本文仅讨论用对数似然损失函数的GBDT分类。对此我们又有二元分类和多元分类的区别。 二元GBDT分类算法 对于二元GBDT，如果用类似于逻辑回归的对数似然损失函数，则损失函数为： \[L(y, f(x)) = log(1+ exp(-yf(x)))\] 其中\(y∈\{−1,+1\}\).则此时的负梯度误差为: \[r_{mi} = -\bigg[\frac{\partial L(y, f(x_i)))}{\partial f(x_i)}\bigg]_{f(x) = f_{m-1}\;\; (x)} = \frac{y_i}{1+exp(y_if(x_i))}\] 对于生成的决策树，我们各个叶子节点的最佳负梯度拟合值为: \[c_{mj} = \underbrace{arg\; min}_{c}\sum\limits_{x_i \in R_{mj}} log(1+exp(-y_i(f_{m-1}(x_i) +c)))\] 由于上式比较难优化，我们一般使用近似值代替 \[c_{mj} = \frac{\sum\limits_{x_i \in R_{mj}}r_{mi}} {\sum\limits_{x_i \in R_{mj}}|r_{mi}|(1-|r_{mi}|)}\] 除了负梯度计算和叶子节点的最佳负梯度拟合的线性搜索，二元GBDT分类和GBDT回归算法过程相同。 多元GBDT分类算法 多元GBDT要比二元GBDT复杂一些，对应的是多元逻辑回归和二元逻辑回归的复杂度差别。 假设类别数为K，则此时我们的对数似然损失函数为： \[L(y, f(x)) = - \sum\limits_{k=1}^{K}y_klog\;p_k(x)\] 其中如果样本输出类别为k，则\(y_k=1\)。第k类的概率\(p_k(x)\)的表达式为： \[p_k(x) = \frac{exp(f_k(x))} {\sum\limits_{l=1}^{K} exp(f_l(x))}\] 集合上两式，我们可以计算出第t轮的第i个样本对应类别l的负梯度误差为 \[r_{mil} = -\bigg[\frac{\partial L(y_i, f(x_i)))}{\partial f(x_i)}\bigg]_{f_k(x) = f_{l, m-1}\;\; (x)} = y_{il} - p_{l, m-1}(x_i)\] 观察上式可以看出，其实这里的误差就是样本i对应类别l的真实概率和m−1轮预测概率的差值。 对于生成的决策树，我们各个叶子节点的最佳负梯度拟合值为 \[c_{mjl} = \underbrace{arg\; min}_{c_{jl}}\sum\limits_{i=0}^{m}\sum\limits_{k=1}^{K} L(y_k, f_{m-1, l}(x) + \sum\limits_{j=0}^{J}c_{jl} I(x_i \in R_{mj}))\] 由于上式比较难优化，我们一般使用近似值代替 \[c_{tjl} = \frac{K-1}{K} \; \frac{\sum\limits_{x_i \in R_{tjl}}r_{til}}{\sum\limits_{x_i \in R_{til}}|r_{til}|(1-|r_{til}|)}\] 除了负梯度计算和叶子节点的最佳负梯度拟合的线性搜索，多元GBDT分类和二元GBDT分类以及GBDT回归算法过程相同。 GBDT常用损失函数 分类算法 损失函数一般有对数损失函数和指数损失函数两种: 指数损失函数 \[L(y, f(x)) = exp(-yf(x))\] 其负梯度计算和叶子节点的最佳负梯度拟合和Adaboost原理相同。 对数损失函数，分为二元分类和多元分类两种，参见上文的GBDT分类算法。 回归算法 常用损失函数有如下4种: 均方差，最常见的回归损失函数 \[L(y, f(x)) =(y-f(x))^2\] 2. 绝对损失，这个损失函数也很常见 \[L(y, f(x)) =|y-f(x)|\] 对应负梯度误差为： \[sign(y_i-f(x_i))\] Huber损失，它是均方差和绝对损失的折衷产物，对于远离中心的异常点，采用绝对损失，而中心附近的点采用均方差。这个界限一般用分位数点度量。损失函数如下： \[L(y, f(x))= \begin{cases} \frac{1}{2}(y-f(x))^2&amp; {|y-f(x)| \leq \delta}\\ \delta(|y-f(x)| - \frac{\delta}{2})&amp; {|y-f(x)| &gt; \delta} \end{cases}\] 对应的负梯度误差为： \[r(y_i, f(x_i))= \begin{cases} y_i-f(x_i)&amp; {|y_i-f(x_i)| \leq \delta}\\ \delta sign(y_i-f(x_i))&amp; {|y_i-f(x_i)| &gt; \delta} \end{cases}\] 分位数损失。它对应的是分位数回归的损失函数，表达式为 \[L(y, f(x)) =\sum\limits_{y \geq f(x)}\theta|y - f(x)| + \sum\limits_{y &lt; f(x)}(1-\theta)|y - f(x)|\] 其中θ为分位数，需要我们在回归前指定。对应的负梯度误差为： \[r(y_i, f(x_i))= \begin{cases} \theta&amp; { y_i \geq f(x_i)}\\ \theta - 1 &amp; {y_i &lt; f(x_i) } \end{cases}\] 对于Huber损失和分位数损失，主要用于健壮回归，也就是减少异常点对损失函数的影响。 GBDT的正则化 和Adaboost一样，我们也需要对GBDT进行正则化，防止过拟合。GBDT的正则化主要有三种方式。 步长(learning rate) 第一种是和Adaboost类似的正则化项，即步长(learning rate)。定义为ν,对于前面的弱学习器的迭代 \[f_{k}(x) = f_{k-1}(x) + h_k(x)\] 如果我们加上了正则化项，则有 \[f_{k}(x) = f_{k-1}(x) + \nu h_k(x)\] ν的取值范围为0&lt;ν≤1。对于同样的训练集学习效果，较小的ν意味着我们需要更多的弱学习器的迭代次数。通常我们用步长和迭代最大次数一起来决定算法的拟合效果。 子采样 第二种正则化的方式是通过子采样比例（subsample）。取值为(0,1]。注意这里的子采样和随机森林不一样，随机森林使用的是放回抽样，而这里是不放回抽样。如果取值为1，则全部样本都使用，等于没有使用子采样。如果取值小于1，则只有一部分样本会去做GBDT的决策树拟合。选择小于1的比例可以减少方差，即防止过拟合，但是会增加样本拟合的偏差，因此取值不能太低。推荐在[0.5, 0.8]之间。 使用了子采样的GBDT有时也称作随机梯度提升树(Stochastic Gradient Boosting Tree, SGBT)。由于使用了子采样，程序可以通过采样分发到不同的任务去做boosting的迭代过程，最后形成新树，从而减少弱学习器难以并行学习的弱点。 正则化剪枝 针对于弱学习器（即CART回归树）进行正则化剪枝。就是决策树的正则化方法 GBDT的优点和局限性 优点 预测阶段的计算速度快， 树与树之间可并行化计算。 在分布稠密的数据集上， 泛化能力和表达能力都很好， 这使得GBDT在Kaggle的众多竞赛中， 经常名列榜首。 采用决策树作为弱分类器使得GBDT模型具有较好的解释性和鲁棒性，能够自动发现特征间的高阶关系， 并且也不需要对数据进行特殊的预处理如归一化等。 局限性 GBDT在高维稀疏的数据集上， 表现不如支持向量机或者神经网络。 GBDT在处理文本分类特征问题上， 相对其他模型的优势不如它在处理数值特征时明显。 训练过程需要串行训练， 只能在决策树内部采用一些局部并行的手段提高训练速度。 sklearn参数 在sacikit-learn中，GradientBoostingClassifier为GBDT的分类类， 而GradientBoostingRegressor为GBDT的回归类。两者的参数类型完全相同，当然有些参数比如损失函数loss的可选择项并不相同。 这些参数中，类似于Adaboost，我们把重要参数分为两类， - 第一类是Boosting框架的重要参数， - 第二类是弱学习器（即CART回归树）的重要参数。 下面我们就从这两个方面来介绍这些参数的使用。 ## GBDT类库boosting框架参数 由于GradientBoostingClassifier和GradientBoostingRegressor的参数绝大部分相同，我们下面会一起来讲，不同点会单独指出。 n_estimators: 也就是弱学习器的最大迭代次数，或者说最大的弱学习器的个数。一般来说n_estimators太小，容易欠拟合，n_estimators太大，又容易过拟合，一般选择一个适中的数值。 默认是100。在实际调参的过程中，我们常常将n_estimators和下面介绍的参数learning_rate一起考虑。 learning_rate: 即每个弱学习器的权重缩减系数ν，也称作步长，加上了正则化项，我们的强学习器的迭代公式为\(f_{k}(x) = f_{k-1}(x) + \nu h_k(x)\)。ν的取值范围为0&lt;ν≤1。对于同样的训练集拟合效果，较小的ν意味着我们需要更多的弱学习器的迭代次数。通常我们用步长和迭代最大次数一起来决定算法的拟合效果。 所以这两个参数n_estimators和learning_rate要一起调参。一般来说，可以从一个小一点的ν开始调参，默认是1。 subsample: 即我们在上文的正则化章节讲到的子采样，取值为(0,1]。注意这里的子采样和随机森林不一样，随机森林使用的是放回抽样，而这里是不放回抽样。如果取值为1，则全部样本都使用，等于没有使用子采样。如果取值小于1，则只有一部分样本会去做GBDT的决策树拟合。选择小于1的比例可以减少方差，即防止过拟合，但是会增加样本拟合的偏差，因此取值不能太低。 推荐在[0.5, 0.8]之间，默认是1.0，即不使用子采样。 init: 即我们的初始化的时候的弱学习器，拟合对应原理里面的f0(x)，如果不输入，则用训练集样本来做样本集的初始化分类回归预测。否则用init参数提供的学习器做初始化分类回归预测。一般用在我们对数据有先验知识，或者之前做过一些拟合的时候，如果没有的话就不用管这个参数了。 loss: 即我们GBDT算法中的损失函数。分类模型和回归模型的损失函数是不一样的。 对于分类模型，有对数似然损失函数&quot;deviance&quot;和指数损失函数&quot;exponential&quot;两者输入选择。默认是对数似然损失函数&quot;deviance&quot;。在原理篇中对这些分类损失函数有详细的介绍。一般来说，推荐使用默认的&quot;deviance&quot;。它对二元分离和多元分类各自都有比较好的优化。而指数损失函数等于把我们带到了Adaboost算法。 对于回归模型，有均方差&quot;ls&quot;, 绝对损失&quot;lad&quot;, Huber损失&quot;huber&quot;和分位数损失“quantile”。默认是均方差&quot;ls&quot;。一般来说，如果数据的噪音点不多，用默认的均方差&quot;ls&quot;比较好。如果是噪音点较多，则推荐用抗噪音的损失函数&quot;huber&quot;。而如果我们需要对训练集进行分段预测的时候，则采用“quantile”。 alpha：这个参数只有GradientBoostingRegressor有，当我们使用Huber损失&quot;huber&quot;和分位数损失“quantile”时，需要指定分位数的值。默认是0.9，如果噪音点较多，可以适当降低这个分位数的值。 GBDT类库弱学习器参数 由于GBDT使用了CART回归决策树，因此它的参数基本来源于决策树类，也就是说，和DecisionTreeClassifier和DecisionTreeRegressor的参数基本类似。 划分时考虑的最大特征数max_features: 可以使用很多种类型的值，默认是&quot;None&quot;,意味着划分时考虑所有的特征数；如果是&quot;log2&quot;意味着划分时最多考虑log2N个特征；如果是&quot;sqrt&quot;或者&quot;auto&quot;意味着划分时最多考虑N−−√个特征。如果是整数，代表考虑的特征绝对数。如果是浮点数，代表考虑特征百分比，即考虑（百分比xN）取整后的特征数。其中N为样本总特征数。 一般来说，如果样本特征数不多，比如小于50，我们用默认的&quot;None&quot;就可以了，如果特征数非常多，我们可以灵活使用刚才描述的其他取值来控制划分时考虑的最大特征数，以控制决策树的生成时间。 决策树最大深度max_depth: 默认可以不输入，如果不输入的话，默认值是3。一般来说，数据少或者特征少的时候可以不管这个值。如果模型样本量多，特征也多的情况下，推荐限制这个最大深度，具体的取值取决于数据的分布。 常用的可以取值10-100之间。 内部节点再划分所需最小样本数min_samples_split: 这个值限制了子树继续划分的条件，如果某节点的样本数少于min_samples_split，则不会继续再尝试选择最优特征来进行划分。 默认是2.如果样本量不大，不需要管这个值。如果样本量数量级非常大，则推荐增大这个值。 叶子节点最少样本数min_samples_leaf: 这个值限制了叶子节点最少的样本数，如果某叶子节点数目小于样本数，则会和兄弟节点一起被剪枝。 默认是1,可以输入最少的样本数的整数，或者最少样本数占样本总数的百分比。 如果样本量不大，不需要管这个值。如果样本量数量级非常大，则推荐增大这个值。 叶子节点最小的样本权重和min_weight_fraction_leaf：这个值限制了叶子节点所有样本权重和的最小值，如果小于这个值，则会和兄弟节点一起被剪枝。 默认是0，就是不考虑权重问题。一般来说，如果我们有较多样本有缺失值，或者分类树样本的分布类别偏差很大，就会引入样本权重，这时我们就要注意这个值了。 最大叶子节点数max_leaf_nodes: 通过限制最大叶子节点数，可以防止过拟合，默认是&quot;None”，即不限制最大的叶子节点数。如果加了限制，算法会建立在最大叶子节点数内最优的决策树。 如果特征不多，可以不考虑这个值，但是如果特征分成多的话，可以加以限制，具体的值可以通过交叉验证得到。 节点划分最小不纯度min_impurity_split: 这个值限制了决策树的增长，如果某节点的不纯度(基于基尼系数，均方差)小于这个阈值，则该节点不再生成子节点。即为叶子节点 。 一般不推荐改动默认值1e-7。 参考 《百面机器学习》 梯度提升树(GBDT)原理小结 scikit-learn 梯度提升树(GBDT)调参小结]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>sklearn</tag>
        <tag>机器学习</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pandas 处理时间类型数据]]></title>
    <url>%2F2019%2F04%2F01%2Fpandas%E5%A4%84%E7%90%86%E6%97%B6%E9%97%B4%E5%92%8C%E6%97%A5%E6%9C%9F%E7%B1%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[学习目标： - 时间序列数据导入，并转为时间类型 - 导入一个时间相关的数据集 123456import numpy as npimport pandas as pd## importing a dataseturl="http://mlr.cs.umass.edu/ml/machine-learning-databases/event-detection/CalIt2.data"data = pd.read_csv(url, header = None) 查看数据的属性 12345678910111213&gt;&gt;&gt; data.head(3) 0 1 2 30 7 07/24/05 00:00:00 01 9 07/24/05 00:00:00 02 7 07/24/05 00:30:00 1## 查看所有列的数据类型&gt;&gt;&gt; data.dtypes0 int641 object2 object3 int64dtype: object 可以看出来第1列和第2列包含时间时间序列数据，但却是object类型，我们可以转换成时间类型。 ## 数据类型转化(object → datetime) 12345678910&gt;&gt;&gt; data[1] = pd.to_datetime(data[1])&gt;&gt;&gt; data[2] = pd.to_datetime(data[2])&gt;&gt;&gt; data.dtypes0 int641 datetime64[ns]2 datetime64[ns]3 int64dtype: object 查看datetime类型数据 查看这个数据集中的时间数据中包含了哪些年、月、日等。 123456789&gt;&gt;&gt; data[1].dt.year.unique()array([2005], dtype=int64)&gt;&gt;&gt; data[1].dt.month.unique()array([ 7, 8, 9, 10, 11], dtype=int64)&gt;&gt;&gt; data[1].dt.day.unique()array([24, 25, 26, 27, 28, 29, 30, 31, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23], dtype=int64) 查看某月的数据有多少 12&gt;&gt;&gt; data[data[1].dt.month == 10].shape(2976, 4) 查看两个时间相差多久 12&gt;&gt;&gt; data.loc[6624,1] - data.loc[0,1]Timedelta('69 days 00:00:00') 第1行和第6624行的数据相差69天，结果是个Timedelta数据类型。 参考：Working with Dates and timedelta in Pandas]]></content>
      <categories>
        <category>数据分析</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>pandas</tag>
        <tag>时间序列</tag>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模型评估指标]]></title>
    <url>%2F2019%2F03%2F21%2F%E6%A8%A1%E5%9E%8B%E9%AA%8C%E8%AF%81%2F</url>
    <content type="text"><![CDATA[先加载数据 12345678910111213# Data Loadingimport pandas as pd# Load datamelbourne_file_path = '../input/melbourne-housing-snapshot/melb_data.csv'melbourne_data = pd.read_csv(melbourne_file_path) # Filter rows with missing price valuesfiltered_melbourne_data = melbourne_data.dropna(axis=0)# Choose target and featuresy = filtered_melbourne_data.Pricemelbourne_features = ['Rooms', 'Bathroom', 'Landsize', 'BuildingArea', 'YearBuilt', 'Lattitude', 'Longtitude']X = filtered_melbourne_data[melbourne_features] 回归模型评价指标MSE、RMSE、MAE、R-Squared 均方误差(MAE) MSE （Mean Squared Error）叫做均方误差。看公式 \[ \frac{1}{m}\sum _ { i=1 }^m (y_ i-\hat{y_i})^2\] 参考 Model Validation]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[梯度下降(gradient boosting)]]></title>
    <url>%2F2019%2F03%2F18%2F%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>机器学习</tag>
        <tag>梯度下降</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[决策树(Decision trees)]]></title>
    <url>%2F2019%2F03%2F18%2F%E5%86%B3%E7%AD%96%E6%A0%91%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[回溯、分治、动态规划]]></title>
    <url>%2F2019%2F03%2F16%2F%E5%9B%9E%E6%BA%AF%E3%80%81%E5%88%86%E6%B2%BB%E3%80%81%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%20%2F</url>
    <content type="text"><![CDATA[回溯法是暴力搜索法中的一种。 对于某些计算问题而言，回溯法是一种可以找出所有解的一般性算法，尤其适用于约束满足问题。回溯法采用试错的思想，它尝试分步的去解决一个问题。 在分步解决问题的过程中，当它通过尝试发现现有的分步答案不能得到有效的正确的解答的时候，它将取消上一步甚至是上几步的计算，再通过其它的可能的分步解答再次尝试寻找问题的答案。回溯法通常用最简单的递归方法来实现，在反复重复上述的步骤后可能出现两种情况： 找到一个可能存在的正确的答案 在尝试了所有可能的分步方法后宣告该问题没有答案 学习目标： - 利用回溯算法求解八皇后问题 - 利用回溯算法求解 0-1 背包问题 分治 利用分治算法求一组数据的逆序对个数 动态规划 0-1 背包问题 最小路径和（详细可看 Minimum Path Sum） 编程实现莱文斯坦最短编辑距离 编程实现查找两个字符串的最长公共子序列 编程实现一个数据序列的最长递增子序列 对应的 LeetCode 练习题 实战递归：完成Leetcode上的Letter Combinations of a Phone Number(17)及permutations(46) （保留往期第六天任务） 实战DP：完成0-1背包问题实现(自我实现)及Leetcode上Palindrome Partitioning II(132) （保留往期第七天任务） Regular Expression Matching（正则表达式匹配） 英文版：https://leetcode.com/problems/regular-expression-matching/ 中文版：https://leetcode-cn.com/problems/regular-expression-matching/ Minimum Path Sum（最小路径和） 英文版：https://leetcode.com/problems/minimum-path-sum/ 中文版：https://leetcode-cn.com/problems/minimum-path-sum/ Coin Change （零钱兑换） 英文版：https://leetcode.com/problems/coin-change/ 中文版：https://leetcode-cn.com/problems/coin-change/ Best Time to Buy and Sell Stock（买卖股票的最佳时机） 英文版：https://leetcode.com/problems/best-time-to-buy-and-sell-stock/ 中文版：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/ Maximum Product Subarray（乘积最大子序列） 英文版：https://leetcode.com/problems/maximum-product-subarray/ 中文版：https://leetcode-cn.com/problems/maximum-product-subarray/ Triangle（三角形最小路径和） 英文版：https://leetcode.com/problems/triangle/ 中文版：https://leetcode-cn.com/problems/triangle/ 八皇后问题 有一个棋盘和8个要放到上面的皇后。唯一的要求是皇后之间不能形成威胁。（必须把它们放置成每个皇后都不能吃掉其他皇后的状态）皇后要如何放置呢？ 假设不只是8个，而是有任意数目的皇后，怎么解决？ 方法：回溯 + 生成器 这是一个典型的回溯问题。首先尝试在第一行放置第1个皇后，然后第二行放置第2个，依次类推。 如果发现不能放置下一个皇后，就回溯到上一步，试着将皇后放到其他的位置。最后，或者尝试完所有的可能，或者找到解决方案。 状态表示 元组表示：每个元组中的元素都指示相应行的皇后的列的位置信息。 比如 state[0] == 3 就是第一行的皇后在第4列。 寻找冲突 定义一个 conflict 函数，传入已知的皇后位置，判断下一个皇后可能的位置是否与它们有冲突。 冲突指的是水平位置(即列数)相同，或者对角线位置相同(即行数之差==列数之差)。 基本情况：最后一个皇后该怎么做？ 已知其他行皇后的位置(相互间没有冲突)，遍历这一行的每一列，返回没有冲突发生的位置。 需要递归的情况 同样已知底层的所有行皇后位置(相互间没有冲突)，判断当前行的这一列没有冲突，则加入包含位置信息的元组中，递归传到下一层，下一层返回它的所有正确位置，加入到当前层的位置信息中。 打包 清理输出。将输出处理得更容易理解一点。 1234567891011121314151617181920212223242526272829303132333435363738394041def conflict(state, nextX): #nextX是当前列数 nextY = len(state) # 当前行数 for i in range(nextY):# 遍历之前所有行 if abs(state[i]-nextX) in (0, nextY-i): return True # 同一列或统一对角线上，就冲突 return False#生成器def queens(num=8, state=()): for pos in range(num):#遍历所有列 if not conflict(state,pos): #如果这一列不冲突 if len(state) == num-1:#到了最后一个皇后 yield (pos,) else:#递归 for result in queens(num,state+(pos,)):#加上当前层的正确列数pos去下一层 #result就是递归的下一层返回来的一个列结果 yield (pos,) + result # 当前层应该返回的结果# 生成器给出所有解决方案print(list(queens(3))) # []print(list(queens(4))) # [(1, 3, 0, 2), (2, 0, 3, 1)]# 8个皇后有多少中解决方案：print(len(list(queens(8)))) # 92# 打包：更形象得随机输出解决方案def prettyprint(solution): def line(pos,length=len(solution)): # 对于每一行pos return '. '*pos + 'X ' + '. '*(length-pos-1) for pos in solution:# 对于每一行pos print(line(pos)) import randomprettyprint(random.choice(list(queens(8))))#输出：#. . . . . . X . #X . . . . . . . #. . X . . . . . #. . . . . . . X #. . . . . X . . #. . . X . . . . #. X . . . . . . #. . . . X . . .]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>LeetCode</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python 魔法方法]]></title>
    <url>%2F2019%2F03%2F14%2Fpython%E9%AD%94%E6%B3%95%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Python 中有的方法的名称前后都有两个下划线，这些方法被称为魔法方法。如果对象实现了这些方法中的某一个，那么这个方法就会在特殊的情况下被 Python 所调用，而这一切都是自动发生的。 这里总结一些重要的魔法方法： - 构造方法 __init__ , __new__ 构造方法 __init__ 在定义类的时候，会去定义构造方法。当一个对象被创造后，会立即调用构造方法，定义这个对象的初始值。 12345678class FooBar: def __init__(self,s=8): self.var = 40 self.some = sf = FooBar(9)print(f.var) # 40print(f.some) # 9 可以给构造函数传几个参数。 __new__ 这个方法我们一般很少定义，不过我们在一些开源框架中偶尔会遇到定义这个方法的类。实际上，这才是“真正的构造方法”，它会在对象实例化时第一个被调用，然后再调用__init__，它们的区别主要如下： __new__的第一个参数是clsxz，而__init__的第一个参数是self __new__返回值是一个实例，而__init__没有任何返回值，只做初始化操作 __new__由于是返回一个实例对象，所以它可以给所有实例进行统一的初始化操作 由于 __new__ 优先于 __init__ 调用，且返回一个实例。 看下面例子： 123456789101112131415class Person(object): def __new__(cls, *args, **kwargs): print("in __new__") instance = object.__new__(cls) return instance def __init__(self, name, age): print("in __init__") self._name = name self._age = agep = Person("Wang", 33)#输出：#in __new__#in __init__ 可以每次返回同一个实例来实现一个单例类： 123456789101112131415class Singleton(object): _instance = None def __new__(cls, *args, **kwargs): if cls._instance is None: cls._instance = object.__new__(cls, *args, **kwargs) return cls._instances1 = Singleton()s2 = Singleton()print(s1)print(s2) #输出：# &lt;__main__.Singleton object at 0x000001AEC9403400&gt;# &lt;__main__.Singleton object at 0x000001AEC9403400&gt; 可以看到s1和s2都指向同一个对象，实现了单例模式。 再来看下工厂模式的实现 12345678910111213141516171819202122232425262728293031323334353637383940class Fruit(object): def __init__(self): pass def print_color(self): passclass Apple(Fruit): def __init__(self): pass def print_color(self): print("apple is in red")class Orange(Fruit): def __init__(self): pass def print_color(self): print("orange is in orange")class FruitFactory(object): fruits = &#123;"apple": Apple, "orange": Orange&#125; def __new__(cls, name): if name in cls.fruits.keys(): return cls.fruits[name]() else: return Fruit()fruit1 = FruitFactory("apple")fruit2 = FruitFactory("orange")fruit1.print_color() fruit2.print_color() fruit3 = FruitFactory("banana")print(fruit2)print(fruit3)# 输出：# apple is in red# orange is in orange# &lt;__main__.Orange object at 0x000001AEC940F2E8&gt;# &lt;__main__.Fruit object at 0x000001AEC94277F0&gt; 另外一种使用场景是当你需要继承内置类时，例如int、str、tuple，只能通过__new__来达到初始化数据的效果： 12345678class g(float): """千克转克""" def __new__(cls, kg): return float.__new__(cls, kg * 2)# 50千克转为克a = g(50)print(a) # 100.0print(a + 100) # 200.0, 由于继承了float，所以可以直接运算，非常方便！ __del__ 这是析构方法，也就是在对象被垃圾回收之前被调用。 自定义序列和映射 序列和映射是对象的集合。为了实现它们的基本行为，如果对象是不可变的，就需要使用 __len__ 和 __getitem__ 两个魔法方法，如果是可变的，则还需要使用 __setitem__ 和 __delitem__ 。 __len__(self) 返回容器的长度，可变和不可变类型都需要实现。 __getitem__(self, key) 定义对容器中某一项使用 self[key] 的方式进行读取操作时的行为。这也是可变和不可变容器类型都需要实现的一个方法。它应该在键的类型错误式产生 TypeError 异常，同时在没有与键值相匹配的内容时产生 KeyError 异常。 __setitem__(self, key) 定义对容器中某一项使用 self[key] 的方式进行赋值操作时的行为。它是可变容器类型必须实现的一个方法，同样应该在合适的时候产生 KeyError 和 TypeError 异常。 __delitem__(self, key) 这个方法在对一部分对象使用 del 语句时被调用，同时必须删除和键相关的键。 访问控制 __str__ 当被 str() 调用时会执行__str__。此方法类似JAVA中的toString方法。 1234567891011121314151617class A: def __init__(self,name): self.name = nameclass B: def __init__(self,name): self.name = name def __str__(self):#重写__str__方法 return self.namea = A("Tom")print(a)b = B("Jake")print(b)#输出：#&lt;__main__.A object at 0x000001AEC9447198&gt;#Jake 迭代器 __iter__ 该方法会返回一个迭代器。 迭代器是具有next方法的对象。在调用next方法时，会返回迭代器的下一个值。 除了在迭代器和可迭代对象上进行迭代外，还能把他们转换为序列。 下面的例子是用list构造方法显示地将迭代器转化为列表。 12 生成器 参考 Python面试之理解__new__和__init__的区别]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python实现数据结构之堆]]></title>
    <url>%2F2019%2F03%2F10%2Fpython%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%A0%86%2F</url>
    <content type="text"><![CDATA[学习目标： 实现一个小顶堆、大顶堆、优先级队列 实现堆排序 利用优先级队列合并 K 个有序数组 求一组动态数据集合的最大 Top K （选做）第三天堆排序学习（复习）]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>LeetCode</tag>
        <tag>数据结构</tag>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python实现数据结构之图]]></title>
    <url>%2F2019%2F03%2F10%2Fpython%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[学习目标： 实现有向图、无向图、有权图、无权图的邻接矩阵和邻接表表示方法 实现图的深度优先搜索、广度优先搜索 实现 Dijkstra 算法、A* 算法 实现拓扑排序的 Kahn 算法、DFS 算法 对应的 LeetCode 练习题 200 Number of Islands（岛屿的个数） 英文版：https://leetcode.com/problems/number-of-islands/description/ 中文版：https://leetcode-cn.com/problems/number-of-islands/description/ Valid Sudoku（有效的数独） 英文版：https://leetcode.com/problems/valid-sudoku/ 中文版：https://leetcode-cn.com/problems/valid-sudoku/ 实现一个邻接表表示的有向带权图 每个顶点的所有邻接点和对应的边的权重用字典表示。 对于无权图，可以只将顶点的所有邻接点放入 list 中即可。 图的所有顶点名称及对应的顶点对象用字典表示。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364class Vertex:#顶点 def __init__(self,key): self.id = key self.connectedTo = &#123;&#125; #邻接点，及相应的权重 def addNeighbor(self, nbr, weight=0): self.connectedTo[nbr] = weight def __str__(self): return str(self.id) + ' connectedTo: '+str([x.id for x in self.connectedTo]) def getConnections(self): #多有邻接点 return self.connectedTo.keys() def getId(self): return self.id def getWeight(self,nbr): return self.connectedTo[nbr] class Graph: # 邻接表表示的有向带权图 def __init__(self): self.vertList = &#123;&#125; # 所有顶点 self.numVertices = 0 def addVertex(self, key): #添加顶点 self.numVertices += 1 newVertex = Vertex(key) self.vertList[key] = newVertex return newVertex def getVertex(self, n): if n in self.vertList: return self.vertList[n] else: return None def __contains__(self,n): return n in self.vertList def addEdge(self,f,t,cost=0): #添加边 if f not in self.vertList: self.addVertex(f) if t not in self.vertList: self.addVertex(t) self.vertList[f].addNeighbor(self.vertList[t], cost) def getVertices(self): return self.vertList.keys() def __iter__(self): return iter(self.vertList.values()) g = Graph()for i in range(6): g.addVertex(i)print(g.getVertex(3))print(g.vertList)print(3 in g)g.addEdge(0,1,5)g.addEdge(0,5,2)g.addEdge(1,2,4)g.addEdge(2,3,9)g.addEdge(3,4,7)g.addEdge(3,5,3)g.addEdge(4,0,1)g.addEdge(5,4,8)g.addEdge(5,2,1)print(g.getVertices())for v in g: for w in v.getConnections(): print('(%s,%s)'%(v.getId(), w.getId())) 输出： 123456789101112133 connectedTo: []&#123;0: &lt;__main__.Vertex object at 0x000001AEC9423B70&gt;, 1: &lt;__main__.Vertex object at 0x000001AEC903F748&gt;, 2: &lt;__main__.Vertex object at 0x000001AEC85F8CC0&gt;, 3: &lt;__main__.Vertex object at 0x000001AEC9415FD0&gt;, 4: &lt;__main__.Vertex object at 0x000001AEC9415EF0&gt;, 5: &lt;__main__.Vertex object at 0x000001AEC9415B70&gt;&#125;Truedict_keys([0, 1, 2, 3, 4, 5])(0,1)(0,5)(1,2)(2,3)(3,4)(3,5)(4,0)(5,4)(5,2) 图的遍历 遍历图最常用的有两种方式，就是你常听到的 BFS 和 DFS. BFS: Breadth First Search，广度优先搜索 DFS: Depdth First Search，深度优先搜索 BFS BFS 类似于树的层序遍历，从第一个节点开始，先访问离 A 最近的点，接着访问次近的点。 123456789101112131415161718192021222324252627282930313233343536373839404142from collections import dequeGRAPH = &#123; # 邻接表表示的无向无权图 'A': ['B', 'F'], 'B': ['C', 'I', 'G'], 'C': ['B', 'I', 'D'], 'D': ['C', 'I', 'G', 'H', 'E'], 'E': ['D', 'H', 'F'], 'F': ['A', 'G', 'E'], 'G': ['B', 'F', 'H', 'D'], 'H': ['G', 'D', 'E'], 'I': ['B', 'C', 'D'],&#125;class Queue(object): # 队列辅助 def __init__(self): self._deque = deque() def push(self, value): return self._deque.append(value) def pop(self): return self._deque.popleft() def __len__(self): return len(self._deque)def bfs(graph, start): search_queue = Queue() search_queue.push(start)# 起点先入队 searched = set() # 已经访问过的结点 while search_queue: # 队列不为空就继续 cur_node = search_queue.pop() # 出队 if cur_node not in searched: # 若是未访问的结点 yield cur_node # 读出 searched.add(cur_node) # 添加到记录中 for node in graph[cur_node]: # 所有邻接点 search_queue.push(node)# 起点的所有邻接点入队print([i for i in bfs(GRAPH, 'A')]) 输出 1[&apos;A&apos;, &apos;B&apos;, &apos;F&apos;, &apos;C&apos;, &apos;I&apos;, &apos;G&apos;, &apos;E&apos;, &apos;D&apos;, &apos;H&apos;] DFS 深度优先搜索(DFS)是每遇到一个节点，如果没有被访问过，就直接去访问它的邻居节点，不断加深。 12345678910111213141516171819202122232425GRAPH = &#123; #邻接表表示的无向无权图 'A': ['B', 'F'], 'B': ['C', 'I', 'G'], 'C': ['B', 'I', 'D'], 'D': ['C', 'I', 'G', 'H', 'E'], 'E': ['D', 'H', 'F'], 'F': ['A', 'G', 'E'], 'G': ['B', 'F', 'H', 'D'], 'H': ['G', 'D', 'E'], 'I': ['B', 'C', 'D'],&#125;DFS_SEARCHED = set()def dfs(graph, start): if start not in DFS_SEARCHED: # 若是未访问的结点 print(start) DFS_SEARCHED.add(start) for node in graph[start]: # 所有邻接点 if node not in DFS_SEARCHED:# 一旦是未访问的结点 dfs(graph, node) # 递归dfs(GRAPH, 'A') # A B C I D G F E H 参考 《Problem Solving with Algorithms and Data Structures using Python》 18_图与图的遍历 数据结构之图]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>LeetCode</tag>
        <tag>数据结构</tag>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python实现数据结构之二叉树]]></title>
    <url>%2F2019%2F03%2F09%2Fpython%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[二叉查找树（英语：Binary Search Tree），也称为二叉搜索树、有序二叉树（ordered binary tree）或排序二叉树（sorted binary tree）。 学习目标： - 实现一个二叉查找树，并且支持插入、删除、查找操作 - LeetCode 108. 将有序数组转换为二叉搜索树 - LeetCode 109. 有序链表转换二叉搜索树 - LeetCode 701. 二叉搜索树中的插入操作 - LeetCode 700. 二叉搜索树中的搜索 - LeetCode 450. 删除二叉搜索树中的结点 - 实现查找二叉查找树中某个结点的后继、前驱结点 - 实现二叉树前、中、后序以及按层遍历 - LeetCode 144. 二叉树的前序遍历 - LeetCode 94. 二叉树的中序遍历 - LeetCode 145. 二叉树的后序遍历 - LeetCode 102. 二叉树的层次遍历 - LeetCode 98. 验证二叉搜索树 - LeetCode 103. 二叉树的锯齿形层次遍历 - LeetCode 226. 翻转二叉树 - LeetCode 104. 二叉树的最大深度 - LeetCode 112. 路径总和 二叉查找树是指一棵空树或者具有下列性质的二叉树： 若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值； 若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值； 任意节点的左、右子树也分别为二叉查找树； 没有键值相等的节点。 二叉查找树相比于其他数据结构的优势在于查找、插入的时间复杂度较低，为 \(O(log n)\)。 每次插入的新的结点都是二叉查找树上新的叶子结点，在进行插入操作时，不必移动其它结点，只需改动某个结点的指针，由空变为非空即可。 将有序数组转换为二叉搜索树 LeetCode 108. Convert Sorted Array to Binary Search Tree 将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。 本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。 示例: 123456789给定有序数组: [-10,-3,0,5,9],一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树： 0 / \ -3 9 / / -10 5 方法：递归 由于要求二叉查找树是平衡的。所以可以选在数组的中间那个数当树根root。 然后这个数左边的数组为左子树，右边的数组为右子树，分别递归产生左右子树就可以了。 12345678910111213141516171819# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def sortedArrayToBST(self, nums: List[int]) -&gt; TreeNode: length = len(nums) if length == 0: return None if length == 1: return TreeNode(nums[0]) middle = (length-1)//2 root = TreeNode(nums[middle]) root.left = self.sortedArrayToBST(nums[:middle]) root.right = self.sortedArrayToBST(nums[middle+1:]) return root 有序链表转换二叉搜索树 LeetCode 109. Convert Sorted List to Binary Search Tree 给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。 本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。 示例: 123456789给定的有序链表： [-10, -3, 0, 5, 9],一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树： 0 / \ -3 9 / / -10 5 方法：链表转成数组 转成数组后，方法同上一题108的解法 123456789101112131415161718192021222324252627282930313233# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = None# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def sortedListToBST(self, head: ListNode) -&gt; TreeNode: nums = [] while head: nums.append(head.val) head = head.next def sortedArrayToBST(nums): length = len(nums) if length == 0: return None if length == 1: return TreeNode(nums[0]) middle = (length-1)//2 root = TreeNode(nums[middle]) root.left = sortedArrayToBST(nums[:middle]) root.right = sortedArrayToBST(nums[middle+1:]) return root return sortedArrayToBST(nums) 二叉搜索树中的插入操作 LeetCode 701. Insert into a Binary Search Tree 给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 保证原始二叉搜索树中不存在新值。 注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回任意有效的结果。 例如, 123456789给定二叉搜索树: 4 / \ 2 7 / \ 1 3和 插入的值: 5 你可以返回这个二叉搜索树: 12345 4 / \ 2 7 / \ /1 3 5 或者这个树也是有效的: 1234567 5 / \ 2 7 / \ 1 3 \ 4 方法 与根结点比较大小，递归左子树或右子树。 1234567891011121314151617# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def insertIntoBST(self, root: TreeNode, val: int) -&gt; TreeNode: if root: if val &lt; root.val: root.left = self.insertIntoBST(root.left, val) else: root.right = self.insertIntoBST(root.right, val) return root else: return TreeNode(val) 二叉搜索树中的搜索 LeetCode 700. Search in a Binary Search Tree 给定二叉搜索树（BST）的根节点和一个值。 你需要在BST中找到节点值等于给定值的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 NULL。 例如， 123456789给定二叉搜索树: 4 / \ 2 7 / \ 1 3和值: 2 你应该返回如下子树: 123 2 / \ 1 3 方法 与根结点比较大小，等于则返回，大于小于则 递归 左子树或右子树。 123456789101112131415161718192021222324252627282930313233343536373839404142# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution:# def sortedArrayToBST(self, nums: [int]) -&gt; TreeNode:# #层序树的列表转为树结构# l=len(nums)# nodeLst = []# for i in range(l):# nodeLst.append(TreeNode(nums[i]))# for i in range(l//2-1):# nodeLst[i].left = nodeLst[2*i+1]# nodeLst[i].right = nodeLst[2*i+2]# nodeLst[l//2-1].left = nodeLst[2*(l//2-1)+1]# if len(nums)%2 == 1:# nodeLst[l//2-2].left = nodeLst[2*(l//2-1)+1]# return nodeLst[0]## def BSTTraversal(self,root): #层序输出树的列表# a = []# L = []# L.append(root)# while L:# if L[0].left is not None:# L.append(L[0].left) # if L[0].right is not None:# L.append(L[0].right)# a.append(L.pop(0).val)# return a def searchBST(self, root: TreeNode, val: int) -&gt; TreeNode: if not root: return None if val == root.val: return root if val &lt; root.val: return self.searchBST(root.left, val) else: return self.searchBST(root.right, val) 删除二叉搜索树中的节点 LeetCode 450. Delete Node in a BST 给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。 一般来说，删除节点可分为两个步骤： 首先找到需要删除的节点； 如果找到了，删除它。 说明： 要求算法时间复杂度为 O(h)，h 为树的高度。 示例: 1234567891011121314151617181920212223242526root = [5,3,6,2,4,null,7]key = 3 5 / \ 3 6 / \ \2 4 7给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它。一个正确的答案是 [5,4,6,2,null,null,7], 如下图所示。 5 / \ 4 6 / \2 7另一个正确答案是 [5,2,6,null,4,null,7]。 5 / \ 2 6 \ \ 4 7 方法 递归遍历整个树 找到这个要删除的结点后，如果只有左孩子，或没有孩子，返回左孩子或空 如果有右孩子，找右子树的最小值，即待删结点的后继，交换两个值。 12345678910111213141516171819202122# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def deleteNode(self, root: TreeNode, key: int) -&gt; TreeNode: if not root: return None if root.val == key: # 找到这个结点 if not root.right: # 如果只有左孩子，或没有孩子 return root.left else: # 如果有右孩子 succ = root.right while succ.left:# 找右子树的最小值，即待删结点的后继 succ = succ.left succ.val, root.val = root.val, succ.val #交换两个值 root.left = self.deleteNode(root.left, key) # 递归遍历左子树 root.right = self.deleteNode(root.right, key) # 递归遍历右子树 return root 查找后继节点 查找二叉查找树中某个节点的前驱节点 思路 若一个节点有右子树，那么该节点的后继节点是其右子树中val值最小的节点（也就是右子树中所谓的leftMostNode） 若一个节点没有右子树，那么判断该节点和其父节点的关系 若该节点是其父节点的左边孩子，那么该节点的后继结点即为其父节点 若该节点是其父节点的右边孩子，那么需要沿着其父亲节点一直向树的顶端寻找，直到找到一个节点P，P节点是其父节点Q的左边孩子，那么Q就是该节点的后继节点 方法 写成递归形式， 当根节点值小于等于p节点值，说明p的后继节点一定在右子树中， 所以对右子节点递归调用此函数 如果根节点值大于p节点值，那么有可能根节点就是p的后继节点，或者左子树中的某个节点是p的后继节点， 所以先对左子节点递归调用此函数，如果返回空，说明根节点是后继节点，返回即可，如果不为空，则将那个节点返回 123456789101112131415161718192021222324252627282930313233343536373839404142434445# Definition for a binary tree node.class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = Noneclass Solution: def sortedArrayToBST(self, nums: [int]) -&gt; TreeNode: #层序树的列表转为树结构 l=len(nums) nodeLst = [] for i in range(l): nodeLst.append(TreeNode(nums[i])) for i in range(l//2-1): nodeLst[i].left = nodeLst[2*i+1] nodeLst[i].right = nodeLst[2*i+2] nodeLst[l//2-1].left = nodeLst[2*(l//2-1)+1] if len(nums)%2 == 1: nodeLst[l//2-2].left = nodeLst[2*(l//2-1)+1] return nodeLst[0] def searchSuccNode(self, root: TreeNode, key: int) -&gt; TreeNode: if not root: return None if root.val &lt;= key: # 后继在右子树中 return self.searchSuccNode(root.right, key) else: # 后继就是该结点，或者在该结点的左子树中。 left = self.searchSuccNode(root.left, key) if not left: return root else: return left if __name__ == '__main__': root = [4,2,7,1,3,5] p = 5 S = Solution() root = S.sortedArrayToBST(root) r= S.searchSuccNode(root,p) if not r: print(str(p) + '的后继不存在') else: print(str(p) + '的后继是' + str(r.val)) #输出：5的后继是7 查找前驱结点 查找二叉查找树中某个节点的前驱节点 思路 若一个节点有左子树，那么该节点的前驱节点是其左子树中val值最大的节点（也就是左子树中所谓的rightMostNode） 若一个节点没有左子树，那么判断该节点和其父节点的关系 若该节点是其父节点的右边孩子，那么该节点的前驱结点即为其父节点。 若该节点是其父节点的左边孩子，那么需要沿着其父亲节点一直向树的顶端寻找，直到找到一个节点P，P节点是其父节点Q的右边孩子，那么Q就是该节点的前驱节点 方法 方法和查找后继结点相同。只是左右子树比较相反。 1234567891011121314151617181920212223242526272829303132333435363738394041424344# Definition for a binary tree node.class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = Noneclass Solution: def sortedArrayToBST(self, nums: [int]) -&gt; TreeNode: #层序树的列表转为树结构 l=len(nums) nodeLst = [] for i in range(l): nodeLst.append(TreeNode(nums[i])) for i in range(l//2-1): nodeLst[i].left = nodeLst[2*i+1] nodeLst[i].right = nodeLst[2*i+2] nodeLst[l//2-1].left = nodeLst[2*(l//2-1)+1] if len(nums)%2 == 1: nodeLst[l//2-2].left = nodeLst[2*(l//2-1)+1] return nodeLst[0] def searchPredecessorNode(self, root: TreeNode, key: int) -&gt; TreeNode: if not root: return None if root.val &gt;= key: # 前驱在左子树中 return self.searchPredecessorNode(root.left, key) else: # 后继就是该结点，或者在该结点的左子树中。 right = self.searchPredecessorNode(root.right, key) if not right: return root else: return right if __name__ == '__main__': root = [4,2,7,1,3,5] p = 3 S = Solution() root = S.sortedArrayToBST(root) r= S.searchPredecessorNode(root,p) if not r: print(str(p) + '的前驱不存在') else: print(str(p) + '的前驱是' + str(r.val)) 二叉树的前序遍历 LeetCode 144. Binary Tree Preorder Traversal 给定一个二叉树，返回它的 前序 遍历。 示例: 12345678输入: [1,null,2,3] 1 \ 2 / 3 输出: [1,2,3] 方法一：用栈从上到下遍历 先右孩子入栈，再左孩子入栈。 12345678910111213141516171819# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def preorderTraversal(self, root: TreeNode) -&gt; List[int]: if not root: return [] stack = [root] # 用栈来辅助存储 res = [] while stack: node = stack.pop() res.append(node.val) if node.right: stack.append(node.right) if node.left: stack.append(node.left) return res 方法二：递归 12345678910class Solution: def preorderTraversal(self, root: TreeNode) -&gt; List[int]: res = [] def dfs(root, res): if root: res.append(root.val) dfs(root.left, res) dfs(root.right, res) return res return dfs(root,res) 方法三：用栈迭代 从根节点開始，一直找它的左子树，直到为空，再找右子树。 1234567891011121314class Solution: def preorderTraversal(self, root: TreeNode) -&gt; List[int]: if not root: return [] stack = [] # 用栈来辅助存储 res = [] cur = root while stack or cur: while cur: #从根节点開始，一直找它的左子树，直到cur为空 stack.append(cur) # 栈中存入根节点和左孩子 res.append(cur.val) cur = cur.left cur = stack.pop().right #找右子树 return res 二叉树的中序遍历 LeetCode 94. Binary Tree Inorder Traversal 给定一个二叉树，返回它的中序 遍历。 示例: 12345678输入: [1,null,2,3] 1 \ 2 / 3输出: [1,3,2] 方法一：递归 1234567891011121314151617# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def inorderTraversal(self, root: TreeNode) -&gt; List[int]: res = [] def inorder(root, res): if root: inorder(root.left, res) res.append(root.val) inorder(root.right, res) return res return inorder(root,res) 方法二：用栈迭代 123456789101112131415class Solution: def inorderTraversal(self, root: TreeNode) -&gt; List[int]: if not root: return [] stack = [] # 用栈来辅助存储 res = [] cur = root while stack or cur: while cur: #从根节点開始，一直找它的左子树，直到cur为空 stack.append(cur) # 栈中存入根节点和左孩子 cur = cur.left temp = stack.pop() # 出栈，则左孩子先出来，然后才是根结点 res.append(temp.val) cur = temp.right #找右子树 return res 二叉树的后序遍历 LeetCode 145. Binary Tree Postorder Traversal 给定一个二叉树，返回它的 后序 遍历。 示例: 12345678输入: [1,null,2,3] 1 \ 2 / 3 输出: [3,2,1] 方法一：递归 12345678910class Solution: def postorderTraversal(self, root: TreeNode) -&gt; List[int]: res = [] def postorder(root, res): if root: postorder(root.left, res) postorder(root.right, res) res.append(root.val) return res return postorder(root,res) 方法二：迭代 1234567891011121314class Solution: def postorderTraversal(self, root: TreeNode) -&gt; List[int]: if not root: return [] stack = [] # 用栈来辅助存储 res = [] cur = root while stack or cur: while cur: #从根节点開始，一直找它的左子树，直到cur为空 stack.append(cur) # 栈中存入根节点和右孩子 res.append(cur.val) cur = cur.right cur = stack.pop().left #找左子树 return res[::-1] 二叉树的层次遍历 LeetCode 102. Binary Tree Level Order Traversal 给定一个二叉树，返回其按层次遍历的节点值。 （即逐层地，从左到右访问所有节点）。 例如: 给定二叉树: [3,9,20,null,null,15,7], 12345 3 / \9 20 / \ 15 7 返回其层次遍历结果： 12345[ [3], [9,20], [15,7]] 方法一： 广度优先搜索（BFS） 1234567891011121314151617181920212223# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def levelOrder(self, root: TreeNode) -&gt; List[List[int]]: if not root: return [] res = [] currLevel = [root] while currLevel: res.append([node.val for node in currLevel]) nextLevel = [] for node in currLevel: if node.left: nextLevel.append(node.left) if node.right: nextLevel.append(node.right) currLevel = nextLevel return res 方法二：深度优先搜索（DFS） 12345678910111213class Solution: def levelOrder(self, root: TreeNode) -&gt; List[List[int]]: def dfs(root, depth, res): if not root: return res if len(res) &lt;= depth: res.append([]) res[depth].append(root.val) dfs(root.left, depth+1,res) dfs(root.right,depth+1,res) res = [] dfs(root,0,res) return res 二叉树的锯齿形层次遍历 LeetCode 103. Binary Tree Zigzag Level Order Traversal 给定一个二叉树，返回其节点值的锯齿形层次遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。 例如： 给定二叉树 [3,9,20,null,null,15,7], 12345 3 / \9 20 / \ 15 7 返回锯齿形层次遍历如下： 12345[ [3], [20,9], [15,7]] 方法 1234567891011121314151617181920212223# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def zigzagLevelOrder(self, root: TreeNode) -&gt; List[List[int]]: def dfs(root, depth, res): if not root: return res if len(res) &lt;= depth: res.append([]) if depth % 2 == 0: res[depth].append(root.val) else: res[depth].insert(0, root.val) dfs(root.left, depth+1,res) dfs(root.right,depth+1,res) res = [] dfs(root,0,res) return res 验证二叉搜索树 LeetCode 98. Validate Binary Search Tree 给定一个二叉树，判断其是否是一个有效的二叉搜索树。 假设一个二叉搜索树具有如下特征： 节点的左子树只包含小于当前节点的数。 节点的右子树只包含大于当前节点的数。 所有左子树和右子树自身必须也是二叉搜索树。 示例 1: 12345输入: 2 / \ 1 3输出: true 示例 2: 123456789输入: 5 / \ 1 4 / \ 3 6输出: false解释: 输入为: [5,1,4,null,null,3,6]。 根节点的值为 5 ，但是其右子节点值为 4 。 方法一：中序遍历 中序遍历按照 左孩子－根节点－右孩子 这个顺序遍历，如果每个子树都满足左孩子]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>LeetCode</tag>
        <tag>数据结构</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python实现数据结构之字符串]]></title>
    <url>%2F2019%2F03%2F08%2Fpython%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[学习目标： 实现一个字符集，只包含 a～z 这 26 个英文字母的 Trie 树 实现朴素的字符串匹配算法 LeetCode 344. 反转字符串 LeetCode 151. 翻转字符串里的单词 LeetCode 8. 字符串转换整数 (atoi) LeetCode 208. 实现 Trie (前缀树) 实现一个 Trie (前缀树)，包含 insert, search, 和 startsWith 这三个操作。 示例: 12345678Trie trie = new Trie();trie.insert(&quot;apple&quot;);trie.search(&quot;apple&quot;); // 返回 truetrie.search(&quot;app&quot;); // 返回 falsetrie.startsWith(&quot;app&quot;); // 返回 truetrie.insert(&quot;app&quot;); trie.search(&quot;app&quot;); // 返回 true 说明: 你可以假设所有的输入都是由小写字母 a-z 构成的。 保证所有输入均为非空字符串。 方法 trie，又称前缀树或字典树，是一种有序树，用于保存关联数组，其中的键通常是字符串。 一个节点的所有子孙都有相同的前缀，也就是这个节点对应的字符串，而根节点对应空字符串。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class TrieNode: def __init__(self): self.isEnd = False # 判断是否是词尾 self.children = dict() #子结点 class Trie: def __init__(self): """ Initialize your data structure here. """ self.root = TrieNode() def insert(self, word: str) -&gt; None: """ Inserts a word into the trie. """ currNode = self.root for i in word: if i not in currNode.children: currNode.children[i] = TrieNode() currNode = currNode.children[i] currNode.isEnd = True def search(self, word: str) -&gt; bool: """ Returns if the word is in the trie. """ currNode = self.root for i in word: if i not in currNode.children: return False currNode = currNode.children[i] return currNode.isEnd def startsWith(self, prefix: str) -&gt; bool: """ Returns if there is any word in the trie that starts with the given prefix. """ currNode = self.root for i in prefix: if i not in currNode.children: return False currNode = currNode.children[i] return True# Your Trie object will be instantiated and called as such:# obj = Trie()# obj.insert(word)# param_2 = obj.search(word)# param_3 = obj.startsWith(prefix) Trie树的优缺点 Trie树的核心思想是空间换时间，利用字符串的公共前缀来减少无谓的字符串比较以达到提高查询效率的目的。 优点 插入和查询的效率很高，都为O(m)O(m)，其中 mm 是待插入/查询的字符串的长度。 关于查询，会有人说 hash 表时间复杂度是O(1)O(1)不是更快？但是，哈希搜索的效率通常取决于 hash 函数的好坏，若一个坏的 hash 函数导致很多的冲突，效率并不一定比Trie树高。 Trie树中不同的关键字不会产生冲突。 Trie树只有在允许一个关键字关联多个值的情况下才有类似hash碰撞发生。 Trie树不用求 hash 值，对短字符串有更快的速度。通常，求hash值也是需要遍历字符串的。 Trie树可以对关键字按字典序排序。 缺点 当 hash 函数很好时，Trie树的查找效率会低于哈希搜索。 空间消耗比较大。 LeetCode 28. 实现strStr() Implement strStr() 实现 strStr() 函数。 给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回 -1。 示例 1: 12输入: haystack = &quot;hello&quot;, needle = &quot;ll&quot;输出: 2 示例 2: 12输入: haystack = &quot;aaaaa&quot;, needle = &quot;bba&quot;输出: -1 说明: 当 needle 是空字符串时我们返回 0 。这与C语言的 strstr() 以及 Java的 indexOf() 定义相符。 方法：内置find()函数 123class Solution: def strStr(self, haystack: str, needle: str) -&gt; int: return haystack.find(needle) 方法：朴素算法 字符串匹配算法主要是两类，最基本的暴力解法，也叫做朴素算法，另一种是KMP算法。 朴素算法是通过一个循环找到所有有效偏移，检查是否满足条件。 1234567class Solution: def strStr(self, haystack: str, needle: str) -&gt; int: M, N = len(haystack), len(needle) for i in range(M-N+1): if haystack[i:i+N] == needle: return i return -1 LeetCode 344. 反转字符串 反转字符串 编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。 不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。 你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。 示例 1： 12输入：[&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]输出：[&quot;o&quot;,&quot;l&quot;,&quot;l&quot;,&quot;e&quot;,&quot;h&quot;] 示例 2： 12输入：[&quot;H&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;h&quot;]输出：[&quot;h&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;H&quot;] 方法 依次交换前面和后面的字符直至中间字符，完成反转。 123456789class Solution: def reverseString(self, s: List[str]) -&gt; None: &quot;&quot;&quot; Do not return anything, modify s in-place instead. &quot;&quot;&quot; for i in range(len(s)//2): tmp = s[i] s[i] = s[len(s)-1-i] s[len(s)-1-i] = tmp LeetCode 151. 翻转字符串里的单词 Reverse Words in a String 给定一个字符串，逐个翻转字符串中的每个单词。 示例 1： 12输入: &quot;the sky is blue&quot;输出: &quot;blue is sky the&quot; 示例 2： 123输入: &quot; hello world! &quot;输出: &quot;world! hello&quot;解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。 示例 3： 123输入: &quot;a good example&quot;输出: &quot;example good a&quot;解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。 说明： 无空格字符构成一个单词。 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。 方法 12345class Solution: def reverseWords(self, s: str) -&gt; str: lst = s.split() lst.reverse() return " ".join(lst) LeetCode 8. 字符串转换整数 (atoi) 字符串转换整数 (atoi) 请你来实现一个 atoi 函数，使其能将字符串转换成整数。 首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。 当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。 该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。 注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。 在任何情况下，若函数不能进行有效的转换时，请返回 0。 说明：假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 \([−2^{31}, 2^{31} − 1]\)。如果数值超过这个范围，qing返回 INT_MAX\((2^{31} − 1)\) 或 INT_MIN \((−2^{31})\) 。 示例 1: 12输入: &quot;42&quot;输出: 42 示例 2: 1234输入: &quot; -42&quot;输出: -42解释: 第一个非空白字符为 &apos;-&apos;, 它是一个负号。 我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。 示例 3: 123输入: &quot;4193 with words&quot;输出: 4193解释: 转换截止于数字 &apos;3&apos; ，因为它的下一个字符不为数字。 示例 4: 1234输入: &quot;words and 987&quot;输出: 0解释: 第一个非空字符是 &apos;w&apos;, 但它不是数字或正、负号。 因此无法执行有效的转换。 示例 5: 1234输入: &quot;-91283472332&quot;输出: -2147483648解释: 数字 &quot;-91283472332&quot; 超过 32 位有符号整数范围。 因此返回 INT_MIN (−231) 。 方法一：按条件多次判断 按题目要求进行如下处理和判断： 1. strip()去掉首位空格字符 2. 如果字符串为空，返回0 3. 判断首字符是否为正负号 4. 遍历每个字符，若在0-9范围内，则加入数字中；否则break。 5. 乘上正负号之后，判断数字是否越界。 12345678910111213141516171819202122232425class Solution: def myAtoi(self, str): """ :type str: str :rtype: int """ str = str.strip() number, flag = 0, 1 if not str: return 0 if str[0] == '-' and len(str)&gt;1: str = str[1:] flag = -1 elif str[0] == '+' and len(str)&gt;1: str = str[1:] for c in str: if c &gt;= '0' and c &lt;= '9': number = 10*number + ord(c) - ord('0') else: break number = flag * number number = number if number &lt;= 2**31-1 else 2**31-1 number = number if number &gt;= -2**31 else -2**31 return number 方法二：正则匹配 用正则表达式来匹配 123456789101112131415161718192021222324252627282930class Solution: def myAtoi(self, str): """ :type str: str :rtype: int """ # 导入正则模块 import re # 字符串中查找全部符合条件的整数，返回的是列表，第一个参数是正则，第二个参数是字符串 ret = re.findall(r"^[-+]?\d+", str.strip()) # strip()字符串去空格 # 判断是否有匹配的值，没有的话返回0，例如"word values 987"，匹配不到，返回0 if ret: ret_str = ret[0] # 匹配的数字的字符串 ret_str2 = "" # 记录去符号的字符串，ret_str后面还要使用，所以定义一个新的变量记录 # 判断是否带有符号 + or - if ret_str[0] == "-" or ret_str[0] == "+": ret_str2 = ret_str[1:] else: ret_str2 = ret_str # str转int ret_int = int(ret_str2) # 判断第一个字符是否为负号 if ret_str[0] == "-": # 三目运算符，判断是否溢出 # 如果ret_int &lt;= 2**31则返回-ret_int，否则返回-2**31 return -ret_int if ret_int &lt;= 2**31 else -2**31 else: return ret_int if ret_int &lt; 2**31 else 2**31-1 else: return 0 比方法一的执行时间短 参考 Trie树（Prefix Tree）介绍]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>LeetCode</tag>
        <tag>数据结构</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python实现数据结构之哈希表]]></title>
    <url>%2F2019%2F03%2F07%2Fpython%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E5%93%88%E5%B8%8C%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[散列表（Hash table，也叫哈希表），是根据键（Key）而直接访问在内存存储位置的数据结构。 具体方法是： 选定一个整数的下标范围（通常以 0 或 1 开始)，建立一个包括相应元素位置范围的顺序表。 选定一个从实际关键码集合到上述下标范围的适当映射 h 在需要存入关键码为 key 的数据时，将其存入表中第 h(key) 个位置。 遇到以 key 为关键码检索数据时，直接去找表中第 h(key) 个位置的元素。 这个 h 称为散列函数， 也常被称为哈希（hash)函数或杂凑函数，它就是从可能的关键码集合到一个整数区间（下标区间）的映射。 学习目标： 实现一个基于链表法解决冲突问题的散列表 实现一个 LRU 缓存淘汰算法 LeetCode 1. 两数之和 LeetCode 202. Happy Number 实现一个基于链表法解决冲突问题的散列表 在存储数据的过程中，如果发生冲突，可以利用链表在已有数据的后面插入新数据来解决冲突。这种方法被称为“链地址法”。 在哈希表中，我们可以利用哈希函数快速访问到数组中的目标数据。如果发生哈希冲突，就使用链表进行存储。这样一来，不管数据量为多少，我们都能够灵活应对。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class HashTable: def __init__(self): self.size = 11 #容量自定，但必须是素数 self.hash_table = [[] for _ in range(self.size)] # 存放keys-values # list中的list是同一个位置的元素集合 def insert(self,key,value): hash_value =hash(key)%self.size #哈希函数 key_exists = False bucket = self.hash_table[hash_value] for i, kv in enumerate(bucket): k, v = kv if key == k: key_exists = True break if key_exists: bucket[i] = ((key,value)) else: bucket.append((key,value)) def search(self, key): hash_value = hash(key)%self.size #哈希函数 bucket = self.hash_table[hash_value] for i, kv in enumerate(bucket): k, v = kv if key == k: return v def delete(self, key): hash_value = hash(key)%self.size #哈希函数 key_exists = False bucket = self.hash_table[hash_value] for i, kv in enumerate(bucket): k, v = kv if key == k: key_exists = True break if key_exists: del bucket[i] return v else: return 0 if __name__ == '__main__': H=HashTable() H.insert(2,"lion") H.insert(10,"cat") H.insert(25,"dog") print(H.hash_table) # 输出 H.insert(10,"kitty") H.insert(21,"tiger") print(H.hash_table) # 输出 print("查找10的值为"+ H.search(10)) print("删除10，值为" + H.delete(10)) print(H.hash_table) # 输出 输出： 12345[[], [], [(2, &apos;lion&apos;)], [(25, &apos;dog&apos;)], [], [], [], [], [], [], [(10, &apos;cat&apos;)]][[], [], [(2, &apos;lion&apos;)], [(25, &apos;dog&apos;)], [], [], [], [], [], [], [(10, &apos;kitty&apos;), (21, &apos;tiger&apos;)]]查找10的值为kitty删除10，值为kitty[[], [], [(2, &apos;lion&apos;)], [(25, &apos;dog&apos;)], [], [], [], [], [], [], [(21, &apos;tiger&apos;)]] 如果数组的空间太小，使用哈希表的时候就容易发生冲突，线性查找的使用频率也会更高；反过来，如果数组的空间太大，就会出现很多空箱子，造成内存的浪费。因此，给数组设定合适的空间非常重要。 LeetCode 146. LRU缓存机制 LRU Cache 一个用hash表作为底层结构的数据库，当然少不了缓存淘汰算法。当缓存需要被清理时（比如空间占用已经接近临界值了），需要使用某种淘汰算法来决定清理掉哪些数据。 LRU：Least Recently Used，最近最少使用。判断最近被使用的时间，目前最远的数据优先被淘汰，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高”。 LRU 算法过程： 新数据插入到链表头部； 每当缓存命中（即缓存数据被访问），则将数据移到链表头部； 当链表满的时候，将链表尾部的数据丢弃。 这个缓存器主要有两个成员函数，get 和 put。 其中 get 函数是通过输入 key 来获得 value，如果成功获得后，这对 (key, value) 升至缓存器中最常用的位置（顶部），如果 key 不存在，则返回 -1 。 而 put 函数是插入一对新的 (key, value)，如果原缓存器中有该 key，则需要先删除掉原有的，将新的插入到缓存器的顶部。如果不存在，则直接插入到顶部。 若加入新的值后缓存器超过了容量，则需要删掉一个最不常用的值，也就是底部的值。 123456789101112131415161718192021222324252627282930class LRUCache: def __init__(self, capacity: int): self.cap = capacity # 容量 self._cache = [] #缓存 self._cacheMap = &#123;&#125; #缓存哈希表 def get(self, key: int) -&gt; int: if key not in self._cacheMap: return -1 self._cache.remove(key) self._cache.append(key) return self._cacheMap[key] def put(self, key: int, value: int) -&gt; None: if key in self._cacheMap: self._cacheMap[key] = value self._cache.remove(key) self._cache.append(key) else: if len(self._cache) == self.cap: x = self._cache.pop(0) del self._cacheMap[x] self._cache.append(key) self._cacheMap[key] = value# Your LRUCache object will be instantiated and called as such:# obj = LRUCache(capacity)# param_1 = obj.get(key)# obj.put(key,value) LeetCode 1. 两数之和 Two Sum ## 题目描述 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例: 给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9 所以返回 [0, 1] 方法：哈希表 利用python中的字典记录记录下每个元素出现的位置 12345678910111213141516class Solution(object): def twoSum(self, nums, target): """ :type nums: List[int] :type target: int :rtype: List[int] """ dic = dict() for index,value in enumerate(nums): sub = target - value if sub in dic: return [dic[sub], index] else: dic[value]=index LeetCode 202. Happy Number 202. 快乐数 编写一个算法来判断一个数是不是“快乐数”。 一个“快乐数”定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是无限循环但始终变不到 1。如果可以变为 1，那么这个数就是快乐数。 示例: 1234567输入: 19输出: true解释: 12 + 92 = 8282 + 22 = 6862 + 82 = 10012 + 02 + 02 = 1 方法一 按照“happy number”的定义，直接循环计算各位平方和，观察收敛到1 12345678910class Solution: def isHappy(self, n: int) -&gt; bool: mem = set() while n!=1: n = sum([int(x)*int(x) for x in list(str(n))]) if n in mem: return False else: mem.add(n) return True 方法二 先求出100以内的所有happy number， 按照“happy number”的定义，直接循环计算各位平方和，观察收敛到100之内后的数值是否在列表之内。 1234567class Solution: def isHappy(self, n: int) -&gt; bool: # 100以内的happyNumber happySet = set([1, 7, 10, 13, 19, 23, 28, 31, 32, 44, 49, 68, 70, 79, 82, 86, 91, 94, 97]) while n&gt;99: n = sum([int(x)*int(x) for x in list(str(n))]) return n in happySet 参考 缓存淘汰算法--LRU算法 看动画理解「链表」实现LRU缓存淘汰算法 《我的第一本算法书》 Hash Table implementation in Python [Data Structures &amp; Algorithms]]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>LeetCode</tag>
        <tag>数据结构</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二分查找算法]]></title>
    <url>%2F2019%2F03%2F06%2F%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[学习目标： 实现一个有序数组的二分查找算法 实现模糊二分查找算法 大于给定值的第一个元素 LeetCode 69. x 的平方根 LeetCode 35. 搜索插入位置 二分查找 查找和目标值 k 完全相等的数 12345678910111213141516171819def BinarySearch(lst,k): left = 0 right = len(lst)-1 while left &lt;= right: mid = (left+right)//2 if lst[mid] &lt; k: left = mid + 1 elif lst[mid] &gt; k: right = mid - 1 else: return mid return -1if __name__ == "__main__": lst = [1,2,3,34,56,57,78,87] print(BinarySearch(lst,2)) 模糊二分查找 可能是跟目标值相等的数在数组中并不唯一，而是有多个，那么这种情况下nums[mid] == target这条判断语句就没有必要存在。 大于给定值的第一个元素 查找数组中第一个比 target 大的数的下标。 123456789101112131415161718192021def searchInsert(nums, target): """ :type nums: List[int] :type target: int :rtype: int """ left = 0 right = len(nums)-1 while left &lt;= right: mid = (right+left)//2 if nums[mid] &gt; target: right = mid-1 else: left = mid+1 return right+1if __name__ == "__main__": lst =[1,2,3,3,3,5,5,10,8] print(searchInsert(lst,5)) 输出7 还可变形为查找最后一个不大于目标值的数。 我们已经找到了第一个大于目标值的数，那么再往前退一位，位置 - 1，就是最后一个不大于目标值的数。比如在数组[0, 1, 1, 1, 1, 5]中查找数字1，就会返回最后一个数字1的位置4。 if nums[mid] &gt; target: 中的'&gt;' 改为 '&gt;='，就能找到大于等于给定值的第一个元素。往前退一位，可变形为查找最后一个小于目标值的数。 LeetCode 69. x 的平方根 实现 int sqrt(int x) 函数。 计算并返回 x 的平方根，其中 x 是非负整数。 由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。 示例 1: 12输入: 4输出: 2 示例 2: 1234输入: 8输出: 2说明: 8 的平方根是 2.82842..., 由于返回类型是整数，小数部分将被舍去。 方法：二分查找 1234567891011121314class Solution: def mySqrt(self, x: int) -&gt; int: left = 0 right = x while left &lt;= right: mid = (left+right)//2 if mid * mid &lt; x: left = mid + 1 elif mid * mid &gt; x: right = mid -1 else: return mid return left -1 LeetCode 35. 搜索插入位置 Search Insert Position 题目描述 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。 你可以假设数组中无重复元素。 示例 1: 输入: [1,3,5,6], 5 输出: 2 示例 2: 输入: [1,3,5,6], 2 输出: 1 示例 3: 输入: [1,3,5,6], 7 输出: 4 方法：二分查找 1234567891011121314151617181920class Solution(object): def searchInsert(self, nums, target): """ :type nums: List[int] :type target: int :rtype: int """ left = 0 right = len(nums)-1 while left &lt;= right: mid = (right-left)/2 + left if nums[mid] == target: return mid elif nums[mid] &gt; target: right = mid-1 else: left = mid+1 return left LeetCode 34. 在排序数组中查找元素的第一个和最后一个位置 给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。 你的算法时间复杂度必须是 O(log n) 级别。 如果数组中不存在目标值，返回 [-1, -1]。 示例 1: 12输入: nums = [5,7,7,8,8,10], target = 8输出: [3,4] 示例 2: 12输入: nums = [5,7,7,8,8,10], target = 6输出: [-1,-1] 方法 12345678910111213141516171819class Solution: def searchRange(self, nums: List[int], target: int) -&gt; List[int]: if not nums: return [-1,-1] left = 0 right = len(nums)-1 while left &lt;= right: mid = (right+left)//2 if nums[mid] &gt; target: right = mid-1 else: left = mid+1 if nums[right] != target: return [-1,-1] l = right while l&gt;0 and nums[l-1] == target: l -= 1 return [l,right]]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>LeetCode</tag>
        <tag>数据结构</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python实现排序算法]]></title>
    <url>%2F2019%2F03%2F04%2Fpython%E5%AE%9E%E7%8E%B0%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[学习目标： 实现归并排序、快速排序、插入排序、冒泡排序、选择排序、堆排序 LeetCode 215. 数组中的第K个最大元素 插入排序 每次假设前面的元素都是已经排好序了的，然后将当前位置的元素插入到前面已排好序的序列中。 123456789101112def insert_sort(lst): for index in range(1, len(lst)): #开始时[0,1]已排序 x = lst[index] #待排序的元素 p = index # 从位置j往前开始比较 while p&gt;0 and lst[p-1] &gt; x: lst[p] = lst[p-1] p -= 1 lst[p] = xlst = [63,21,44,3,67,9,6,86,12]insert_sort(lst)print(lst) 空间复杂度是\(O(1)\) 平均时间复杂度\(O(n^2)\) 二分查找的插入排序 在插人排序中需要检索元素的插人位置， 而且是在排序的(部分)序列里检索。 这提示了另一可能方案： 采用二分查找。 1234567891011121314151617181920def insert_sort_binarysearch(lst): for index in range(1, len(lst)): x = lst[index] p = index low = 0 high = index-1 while high &gt;= low: mid = (high+low)//2 if lst[mid] &gt; x: high = mid-1 else: low = mid+1 while p &gt; low: lst[p] = lst[p-1] p -= 1 lst[p] = xlst = [63,21,44,3,67,9,6,86,12]insert_sort_binarysearch(lst)print(lst) 但这种做法不可能从根本上改变算法的性质： 虽然每次检索位置的代价降低了， 但找到位置后还需要顺序移动元素， 腾出空位将元素插人。 后一操作仍然可能需要线性时间。 选择排序 思路： 1. 以空序列作为排序工作的开始， 2. 遍历，每次从剩余未排序的元素中选取最小值， 将其放在已排序的\(i\)个元素的后面，作为序列的第\(i+ 1\)个元素， 使已排序序列增长。 3. 做到尚未排序的序列里只剩一个元素时（它必然为最大)，只需直接将其放在已排序的记录之后， 整个排序就完成了。 需要解决两个问题： 第一是如何选择元素； 第二是做出适当安排，尽可能利用现有序列的存储空间，避免另行安排存储。 - 最简单的选择方法是顺序扫描序列中的元素， 记住遇到的最小元素。 一次扫描完毕就找到了一个最小元素。反复扫描就能完成排序工作。 - 选出了一个元素，原来的序列中就出现了一个空位，可以把这些空位集中起来存放排好序的序列。 在排序过程中的任何时刻， 表的前段积累了一批递增的已经排好序的元素，而且它们都不大于任何一个未排序记录。 下一步从未排序段中选岀最小的元素， 将其存放在已排序元素段的后面(直接交换紧随已排序段的那个位置和最小值)。 这样在只剩一个元素时， 一定最大值， 工作即可结束。 123456789101112def select_sort(lst): for index in range(len(lst)-1): #不需要循环最后一个元素 k = index # 从index位置开始往后遍历比较找到最小元素 for j in range(index, len(lst)): if lst[j] &lt; lst[k]: k = j if index != k: # 确认不是同一个位置 lst[index],lst[k] = lst[k], lst[index] #交换元素 lst = [63,21,44,3,67,9,6,86,12]select_sort(lst)print(lst) 空间复杂度是\(O(1)\) 时间复杂度是\(O(n^2)\) 选择排序比较低效， 原因就在于其中的顺序比较： 每次选择一个元素， 都是从头开始做一遍完全的比较， 在整个排序过程中做了很多重复比较工作。 堆排序 如果在一个连续表里存储的数据是一个小顶堆（ 元素之间的关系满足堆序 )， 按优先队列的操作方式反复弹出堆顶元素， 能够得到一个递增序列。 1234567891011121314151617181920212223def heap_sort(elems): def siftdown(elems,e,begin,end):# 建立大根堆，排序 i, j = begin, begin*2+1 while j &lt; end: if j+1&lt;end and elems[j+1] &gt; elems[j]: j = j+1 #左右子树比较，选择较大的为j if e &gt; elems[j]: break #e比左右子树都大，那就不用下移比较了 elems[i] = elems[j] i, j = j, j*2+1 #下移 elems[i] = e end = len(elems) for i in range(end//2,-1,-1):#建立堆 siftdown(elems,elems[i],i,end) for i in range(end-1, 0, -1):#排序 e = elems[i] elems[i] = elems[0] siftdown(elems,e,0,i) l=[-1,26,5,77,1,61,11,59,15,48,19] heap_sort(l)print(l) 时间复杂度是\(O(nlogn)\) 冒泡排序 冒泡排序就是重复“从序列右边开始比较相邻两个数字的大小，再根据结果交换两个数字的位置”这一操作的算法。 每一轮操作（比较和交换）都会有一个最大值移到右端。 在这个过程中，数字会像泡泡一样，慢慢从左往右“浮”到序列的一端，所以这个算法才被称为“冒泡排序”。 通过一遍遍扫描，表的最后将积累起越来越多排好顺序的大元素。 每遍扫描，这段元素增加一个，经过 n-1 遍扫描，一定能完成排序。 此外，做一遍，扫描的范围可以缩短一项。 把这些考虑综合起来就得到了下面的算法： 12345678910def bubble_sort(lst): for i in range(len(lst)): for j in range(1,len(lst)-i): if lst[j-1] &gt; lst[j]: lst[j-1],lst[j] = lst[j], lst[j-1] l=[-1,26,5,77,1,61,11,59,15,48,19] bubble_sort(l)print(l) 改进 虽然有时起泡排序确实需要做满 n-1 遍，但那是特例，只有被排序表的最小元素恰好在最后时才会出现这种情况。 在其他情况下，扫描就不需要做那么多次，如果发现排序已经完成就可以及早结束。 如果在一次扫描中没遇到逆序，就说明排序工作已经完成， 可以提前结束了。 12345678910111213def bubble_sort(lst): for i in range(len(lst)): found = False for j in range(1,len(lst)-i): if lst[j-1] &gt; lst[j]: lst[j-1],lst[j] = lst[j], lst[j-1] found = True #有逆序 if not found:# 如果没有逆序 break #可以跳出循环结束了 l=[-1,26,5,77,1,61,11,59,15,48,19] bubble_sort(l)print(l) 归并排序 归并排序算法会把序列分成长度相同的两个子序列，当无法继续往下分时（也就是每个子序列中只有一个数据时），就对子序列进行归并。归并指的是把两个排好序的子序列合并成一个有序序列。该操作会一直重复执行，直到所有子序列都归并为一个整体为止。 归并排序中，分割序列所花费的时间不算在运行时间内（可以当作序列本来就是分割好的）。在合并两个已排好序的子序列时，只需重复比较首位数据的大小，然后移动较小的数据，因此只需花费和两个子序列的长度相应的运行时间。 也就是说，完成一行归并所需的运行时间取决于这一行的数据量。 无论哪一行都是n个数据，所以每行的运行时间都为 O(n)。 而将长度为 n 的序列对半分割直到只有一个数据为止时，可以分成\(log_2n\)行，因此，总 共有\(log_2n\)行。也就是说，总的运行时间为 O(nlogn) 123456789101112131415161718192021222324252627282930def mergesort(lst): if len(lst) &lt;= 1: return lst mid = len(lst)//2 # 将列表分成更小的两个列表 # 分别对左右两个列表进行处理，分别返回两个排序好的列表 left = mergesort(lst[:mid]) right = mergesort(lst[mid:]) # 对排序好的两个列表合并，产生一个新的排序好的列表 return merge(left, right)def merge(left, right): res = [] i = 0 j = 0 # 对两个列表中的元素 两两对比。 # 将最小的元素，放到res中 while i&lt;len(left) and j&lt;len(right): if left[i] &lt;= right[j]: res.append(left[i]) i += 1 else: res.append(right[j]) j += 1 res += left[i:] res += right[j:] return res l=[-1,26,5,77,1,61,11,59,15,48,19] res = mergesort(l)print(res) 快速排序 快速排序算法首先会在序列中随机选择一个基准值（pivot），然后将除了基准值以外的数分为“比基准值小的数”和“比基准值大的数”这两个类别，再将其排列成以下形式。 [ 比基准值小的数 ] 基准值 [ 比基准值大的数 ] 接着，对两个“[ ]”中的数据进行排序之后，整体的排序便完成了。对“[ ]”里面的数据进行排序时同样也会使用快速排序(递归)。 123456789101112131415161718192021222324def qsort_rec(lst, l, r): if l&gt;=r: return i = l j = r pivot = lst[i] while i&lt;j: # 找pivot的最终位置 while i&lt;j and lst[j]&gt;=pivot: j -= 1 # 用j向左扫描找小于pivot的记录 if i&lt;j: lst[i] = lst[j] i += 1 # 小记录移到左边 while i&lt;j and lst[i]&lt;pivot: i += 1 if i&lt;j: lst[j] = lst[i] j -= 1 lst[i] = pivot qsort_rec(lst, l, i-1) # 递归处理左半区间 qsort_rec(lst, i+1, r) # 递归处理左右半区间 l=[-1,26,5,77,1,61,11,59,15,48,19] qsort_rec(l,0,len(l)-1)print(l) 时间复杂度\(O(nlogn)\) 改进 1234567891011121314151617def quick_sort1(lst): def qsort(lst, begin,end): if begin &gt;= end: return pivot = lst[begin] i = begin for j in range(begin+1, end+1): if lst[j] &lt; pivot: i += 1 lst[i],lst[j] = lst[j],lst[i] lst[begin],lst[i] = lst[i], lst[begin] qsort(lst, begin, i-1) qsort(lst,i+1, end) qsort(lst,0,len(lst)-1)l=[-1,26,5,77,1,61,11,59,15,48,19] quick_sort1(l)print(l) LeetCode 215. 数组中的第K个最大元素 在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。 示例 1: 12输入: [3,2,1,5,6,4] 和 k = 2输出: 5 示例 2: 12输入: [3,2,3,1,2,4,5,5,6] 和 k = 4输出: 4 说明: 你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。 方法：快速排序中选择 1234567891011121314151617181920class Solution: def findKthLargest(self, nums: List[int], k: int) -&gt; int: def qsort(lst, begin,end): if begin &gt;= end: return pivot = lst[begin] i = begin for j in range(begin+1, end+1): if lst[j] &gt; pivot: i += 1 lst[i],lst[j] = lst[j],lst[i] lst[begin],lst[i] = lst[i], lst[begin] if i&gt;k-1: qsort(lst, begin, i-1) elif i&lt;k-1: qsort(lst,i+1, end) else: return qsort(nums,0,len(nums)-1) return nums[k-1] 方法改进 123456789101112131415import randomclass Solution: def findKthLargest(self, nums, k): pivot = random.choice(nums) nums1, nums2 = [], [] for num in nums: if num &gt; pivot: nums1.append(num) elif num &lt; pivot: nums2.append(num) if k &lt;= len(nums1): return self.findKthLargest(nums1, k) if k &gt; len(nums) - len(nums2): return self.findKthLargest(nums2, k - (len(nums) - len(nums2))) return pivot 参考 《数据结构(C++语言版)》 Python Data Structures - C2 Sort python归并排序--递归实现]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>LeetCode</tag>
        <tag>数据结构</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[递归(python)]]></title>
    <url>%2F2019%2F03%2F02%2F%E9%80%92%E5%BD%92(python)%2F</url>
    <content type="text"><![CDATA[在函数的定义中对这个函数自身的调用，就是递归。 递归结构中，递归的部分必须比原来的整体简单，才有可能到达某种终结点(出口)。而且必须存在非递归的基本结构构成的部分，否则会无限递归。 学习目标： 编程实现斐波那契数列求值 f(n)=f(n-1)+f(n-2) 编程实现求阶乘 n! 编程实现一组数据集合的全排列 LeetCode 70. 爬楼梯 以上问题都可以用递归来解决。 斐波那契数列求值 f(n)=f(n-1)+f(n-2) 斐波那契数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。 [0,1,1,2,3,5,8,13,...] 给定n,计算 f(N) 对应LeetCode习题：509. Fibonacci Number 方法 12345class Solution: def fib(self, N: int) -&gt; int: if N &lt;= 1: return N return self.fib(N-1) + self.fib(N-2) 动态规划方法参见：动态规划 求阶乘 n! 12345678def factorial(n): if n == 0 or n == 1: return 1 else: return (n*factorial(n-1))a = factorial(3)print(a) 输出：6 LeetCode 46. 全排列 Permutations 给定一个没有重复数字的序列，返回其所有可能的全排列。 示例 输入: [1,2,3] 输出: [ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]] 方法 每次选择一个数出来，然后把剩下的数，再选择一个出来，依次类推，选到头，就回溯到上一层。 1234567891011class Solution: def permute(self, nums: List[int]) -&gt; List[List[int]]: res = [] def dfs(nums = nums, path = []): if not nums: res.append(path) for i in range(len(nums)): dfs(nums[:i]+nums[i+1:], path+[nums[i]]) dfs() return res LeetCode 47. 全排列 II Permutations II 给定一个可包含重复数字的序列，返回所有不重复的全排列。 示例: 输入: [1,1,2] 输出: [ [1, 1, 2], [1, 2, 1], [2, 1, 1] ] 方法 相比上一题，多了排序和内部的重复判断。 1234567891011121314class Solution: def permuteUnique(self, nums: List[int]) -&gt; List[List[int]]: nums.sort() res = [] def dfs(nums = nums, path=[]): if not nums: res.append(path) for i in range(len(nums)): if i&gt;0 and nums[i] == nums[i-1]: continue dfs(nums[:i]+nums[i+1:], path+[nums[i]]) dfs() return res LeetCode 70. 爬楼梯 Climbing Stairs 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 注意：给定 n 是一个正整数。 示例 ： 123456输入： 3输出： 3解释： 有三种方法可以爬到楼顶。1. 1 阶 + 1 阶 + 1 阶2. 1 阶 + 2 阶3. 2 阶 + 1 阶 方法：递归 当有n个台阶时，可供选择的走法可以分两类：1，先跨一阶再跨完剩下n-1阶；2，先跨2阶再跨完剩下n-2阶。所以n阶的不同走法的数目是n-1阶和n-2阶的走法数的和。 这和斐波那契数列的规律相同，可以用这个思路。 123456789class Solution: def climbStairs(self, n): """ :type n: int :rtype: int """ if n&lt;=2: return n return self.climbStairs(n-1) + self.climbStairs(n-2) 这个方法运行正常，但是因为超出时间限制，未能通过。 方法：动态规划 动态规划来记录历史数据。 12345678910class Solution: def climbStairs(self, n): """ :type n: int :rtype: int """ prev, current = 0, 1 for i in range(n): prev, current = current, prev + current return current]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>LeetCode</tag>
        <tag>数据结构</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python实现数据结构中的队列]]></title>
    <url>%2F2019%2F03%2F01%2Fpython%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[队列中的数据呈线性排列。与栈类似，队列中可以操作数据的位置也有一定的限制。在栈中，数据的添加和删除都在同一端进行，而在队列中则分别是在两端进行的。队列也不能直接访问位于中间的数据，必须通过出队操作将目标数据变成首位后才能访问。 像队列这种最先进去的数据最先被取来，即“先进先出”的结构，我们称为 First In First Out，简称 FIFO。 “先来的数据先处理”是一种很常见的思路，所以队列的应用范围非常广泛。比如广度优先搜索算法，通常就会从搜索候补中选择最早的数据作为下一个顶点。此时，在候补顶点的管理上就可以使用队列。 学习目标： - 用数组实现一个顺序队列 - 用链表实现一个链式队列 - 实现一个循环队列 - LeetCode 641. 设计循环双端队列 - LeetCode 239. 滑动窗口最大值 用数组实现一个顺序队列 list表头入队，表尾出队。反过来也可以。 实现的基本操作有： - enqueue 入队，要把表中其余元素全部后移，再插入首元素，需要 \(O(n)\)时间 - dequeue 出队,\(O(1)\) 1234567891011121314class Queue: def __init__(self): self.items = [] def enqueue(self, item): # 入队 self.items.insert(0,item) def dequeue(self): # 出队 return self.items.pop() if __name__ == '__main__': q = Queue() q.enqueue(4) q.enqueue(5) q.enqueue(6) print(q.dequeue()) 输出： 14 用链表实现一个链式队列 等同于用带表尾指针的单链表。链尾入队，链首出队。 实现的基本操作有： - enqueue 入队 \(O(1)\) - dequeue 出队 \(O(1)\) - peek 查看队首元素 \(O(1)\) 123456789101112131415161718192021222324252627282930313233343536class Node: # 链表的结点 def __init__(self, x, next_=None): self.val = x self.next = next_class LQueue: # def __init__(self): # 空表 self._head = None self._rear = None # 尾结点 def enqueue(self, x): # 入队 if self._head is None: self._head = Node(x, self._head) self._rear = self._head else: self._rear.next = Node(x) self._rear = self._rear.next def dequeue(self): # 出队 if self._head is None: return x = self._head.val self._head = self._head.next return x def peek(self): # 查看最早入队的元素 if self._head is None: return return self._head.val if __name__ == '__main__': l = LQueue() l.enqueue(4) l.enqueue(5) print(l.peek()) l.enqueue(6) l.dequeue() print(l.peek()) 输出： 1245 实现一个循环队列 LeetCode 622 队头变量_head记录当前队列的第一个元素位置 1234567891011121314151617181920212223242526272829303132333435363738394041class QueueUnderflow(ValueError):# 空队列无法 dequeue的异常错误 passclass SQueue: def __init__(self, init_len=8): self._elems = [0]*init_len # 队列元素 self._head = 0 # 队列首元素位置的下标 self._num = 0 # 表中元素个数 self._len = init_len # 当前表的长度，表满了的话，要换一个存储表 def peek(self): if self._num == 0: # 队空状态 raise QueueUnderflow return self._elems[self._head] def dequeue(self): if self._num == 0: # 队空状态 raise QueueUnderflow e = self._elems[self._head] self._head = (self._head+1) % self._len self._num -= 1 return e def enqueue(self, e): if self._num == self._len: # 队满状态 self.__extend() # 扩大存储区 # 新元素的入队位置 self._elems[(self._head + self._num) % self._len]=e self._num += 1 def __extend(self): # 扩容 old_len = self._len self._len *= 2 new_elems = [0] * self._len for i in range(old_len): new_elems[i] = self._elems[(self._head + i)%old_len] self._elems, self._head = new_elems, 0 if __name__ == '__main__': l = SQueue() for i in range(10): l.enqueue(i+1) print(l.peek()) l.dequeue() print(l.peek()) LeetCode 641. 设计循环双端队列 Design Circular Deque 设计实现双端队列。 你的实现需要支持以下操作： MyCircularDeque(k)：构造函数,双端队列的大小为k。 insertFront()：将一个元素添加到双端队列头部。 如果操作成功返回 true。 insertLast()：将一个元素添加到双端队列尾部。如果操作成功返回 true。 deleteFront()：从双端队列头部删除一个元素。 如果操作成功返回 true。 deleteLast()：从双端队列尾部删除一个元素。如果操作成功返回 true。 getFront()：从双端队列头部获得一个元素。如果双端队列为空，返回 -1。 getRear()：获得双端队列的最后一个元素。 如果双端队列为空，返回 -1。 isEmpty()：检查双端队列是否为空。 isFull()：检查双端队列是否满了。 示例： 12345678910MyCircularDeque circularDeque = new MycircularDeque(3); // 设置容量大小为3circularDeque.insertLast(1); // 返回 truecircularDeque.insertLast(2); // 返回 truecircularDeque.insertFront(3); // 返回 truecircularDeque.insertFront(4); // 已经满了，返回 falsecircularDeque.getRear(); // 返回 2circularDeque.isFull(); // 返回 truecircularDeque.deleteLast(); // 返回 truecircularDeque.insertFront(4); // 返回 truecircularDeque.getFront(); // 返回 4 提示： 所有值的范围为 [1, 1000] 操作次数的范围为 [1, 1000] 请不要使用内置的双端队列库。 方法 和上一题思路相同，用一个list实现类似的环形列表。 双向链表可以从头尾插入元素，对应了list的insert和append方法。注意，无论是在头尾插入，要移动的指针都是rear。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495class MyCircularDeque: def __init__(self, k: int): """ Initialize your data structure here. Set the size of the deque to be k. """ self._elems = [0]*k # 队列元素 self._head = 0 # 队列首元素位置的下标 self._num = 0 # 表中元素个数 self._len = k # 表的长度 def insertFront(self, value: int) -&gt; bool: """ Adds an item at the front of Deque. Return true if the operation is successful. """ if self._num == self._len: # 队满状态 return False # 新元素的入队位置 self._head = (self._head + self._len - 1) % self._len self._elems[self._head]= value self._num += 1 return True def insertLast(self, value: int) -&gt; bool: """ Adds an item at the rear of Deque. Return true if the operation is successful. """ if self._num == self._len: # 队满状态 return False # 新元素的入队位置 self._elems[(self._head + self._num) % self._len]= value self._num += 1 return True def deleteFront(self) -&gt; bool: """ Deletes an item from the front of Deque. Return true if the operation is successful. """ if self._num == 0: # 队空状态 return False # e = self._elems[self._head] self._head = (self._head+1) % self._len self._num -= 1 return True def deleteLast(self) -&gt; bool: """ Deletes an item from the rear of Deque. Return true if the operation is successful. """ if self._num == 0: # 队空状态 return False # e = self._elems[(self._head + self._num-1) % self._len] self._num -= 1 return True def getFront(self) -&gt; int: """ Get the front item from the deque. """ if self._num == 0: # 队空状态 return -1 return self._elems[self._head] def getRear(self) -&gt; int: """ Get the last item from the deque. """ if self._num == 0: # 队空状态 return -1 return self._elems[(self._head + self._num-1) % self._len] def isEmpty(self) -&gt; bool: """ Checks whether the circular deque is empty or not. """ return self._num == 0 def isFull(self) -&gt; bool: """ Checks whether the circular deque is full or not. """ return self._len == self._num# Your MyCircularDeque object will be instantiated and called as such:# obj = MyCircularDeque(k)# param_1 = obj.insertFront(value)# param_2 = obj.insertLast(value)# param_3 = obj.deleteFront()# param_4 = obj.deleteLast()# param_5 = obj.getFront()# param_6 = obj.getRear()# param_7 = obj.isEmpty()# param_8 = obj.isFull() LeetCode 239. 滑动窗口最大值 Sliding Window Maximum 方法：deque（双端队列） 遍历数组nums，使用双端队列deque维护滑动窗口内有可能成为最大值元素的数组下标。 当下标i从队尾入队时，顺次弹出队列尾值&lt;=nums[i]的数组下标。 当前下标为i，则滑动窗口的有效下标范围为[i - (k - 1), i] ,所以当队头元素dq[0] == i-k，就要从队头出队。 12345678910111213class Solution: def maxSlidingWindow(self, nums: List[int], k: int) -&gt; List[int]: dq = collections.deque() # 队列 res = [] for i in range(len(nums)): while dq and nums[dq[-1]] &lt;= nums[i]:#(循环)当dq队尾值小于新元素nums[i] dq.pop() #队尾值出队(直到dq中的值都大于新元素nums[i]) dq.append(i) #新元素入队 if dq[0] == i-k: # 窗口滑出，队头元素不在窗口区域内 dq.popleft() # 队头值出队 if i &gt;= k-1: # i遍历到一个窗口大小之后，每轮都能执行此行。 res.append(nums[dq[0]]) #窗口最大元素 return res 参考 《我的第一本算法书》 [LeetCode]Sliding Window Maximum]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>LeetCode</tag>
        <tag>数据结构</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python实现数据结构中的栈]]></title>
    <url>%2F2019%2F03%2F01%2Fpython%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E6%A0%88%2F</url>
    <content type="text"><![CDATA[栈是一种数据呈线性排列的、后入先出（LIFO，last-in-first-out）的数据结构。不过在这种结构中，我们只能访问最新添加的数据。添加移除新项总发生在同一端。这一端通常称为“顶部”。与顶部对应的端称为“底部”。 栈的底部很重要，因为在栈中靠近底部的项是存储时间最长的。最近添加的项是最先会被移除的。 对栈的两种主要操作是将一个元素压入栈和将一个元素弹出栈。入栈使用push()方法，出栈使用pop()方法。 在栈的应用上，比如深度优先搜索算法，通常会选择最新的数据作为候补顶点。在候补顶点的管理上就可以使用栈。 学习目标： - 用数组实现一个顺序栈 - 用链表实现一个链式栈 - 编程模拟实现一个浏览器的前进、后退功能 用数组实现一个顺序栈 假定数组的结尾作为栈顶，后端插入和删除是 O(1) 操作。 栈有如下基本操作： - Stack() 创建一个空的新栈。 返回一个空栈。 - push(item)将一个新项添加到栈的顶部。它需要 item 做参数并不返回任何内容。 - pop() 从栈中删除顶部项。它返回 item 。栈被修改。 - top() 从栈返回顶部项，但不会删除它。不修改栈。 - isEmpty() 测试栈是否为空。返回布尔值。 - size() 返回栈中的 item 数量。返回一个整数。 1234567891011121314151617181920212223242526class SStack: def __init__(self): self.items = [] def isEmpty(self): return self.items == [] # return not self.items def push(self,item): self.items.append(item) def pop(self): return self.items.pop() def top(self): if self.items: return self.items[-1] else: return None def size(self): return len(self.items) if __name__ == "__main__": s = SStack() s.push('a') print(s.top()) s.push('b') s.push('c') print(s.pop()) 输出： 12ac 数组实现的缺点： - 需要完整的大块存储空间 - 扩大存储的操作代价高 而用链表实现就没有以上的问题。 # 用链表实现一个链式栈 对于链接表，将表头作为栈顶，在前端插入和删除都是 O(1) 操作。 123456789101112131415161718192021222324252627282930class Node: # 链表的结点 def __init__(self, x, next_=None): self.val = x self.next = next_class LStack: #栈的链接表实现 def __init__(self): self._top = None def isEmpty(self): return self._top is None def push(self,item): self._top = Node(item, self._top) def pop(self): p = self._top self._top = p.next return p.val def top(self): if self._top: return self._top.val else: return None if __name__ == "__main__": s = LStack() s.push('a') print(s.top()) s.push('b') s.push('c') print(s.pop()) 输出： 12ac 编程模拟实现一个浏览器的前进、后退功能 每个 web 浏览器都有一个返回按钮。当你浏览网页时，这些网页被放置在一个栈中（实际是网页的网址）。你现在查看的网页在顶部，你第一个查看的网页在底部。如果按‘返回’按钮，将按相反的顺序浏览刚才的页面。 123456789101112131415161718192021222324252627282930313233343536class Page: # 一个网页 def __init__(self, url, prev_=None, next_=None): self.val = url self.next = next_ self.prev = prev_class History: def __init__(self): self._cur = Page(None) def loadPage(self, newPage): #加载新的页面 p = Page(newPage,self._cur,None) self._cur.next = p self._cur = self._cur.next return self._cur.val def back(self): #返回上一页面 if self._cur.prev is None: return self._cur = self._cur.prev return self._cur.val def forward(self): #前进页面 if self._cur.next is None: return self._cur = self._cur.next return self._cur.val if __name__ == '__main__': h = History() print('加载页面'+ h.loadPage('a')) print('加载页面'+ h.loadPage('b')) print('返回到'+ h.back()) print('加载页面'+ h.loadPage('c')) print('返回到'+ h.back()) print('前进到'+ h.forward()) 输出： 123456加载页面a加载页面b返回到a加载页面c返回到a前进到c LeetCode 20. 有效的括号 Valid Parentheses 给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 注意空字符串可被认为是有效字符串。 示例 1: 输入: &quot;()&quot; 输出: true 示例 2: 输入: &quot;([)]&quot; 输出: false 示例 3: 输入: &quot;{[]}&quot; 输出: true 方法 先建立一个map 遍历字符串，对输入的字符串入栈操作（如果入栈的元素是key的话） 依次比较，直到出现不匹配或者栈里所有元素都比较结束(栈空)。 还要注意这样的问题：如果最后多余了’key‘，比如()(，所以最后还要判断一下len(stack)==0 1234567891011121314151617181920212223class Solution: def isValid(self, s): """ :type s: str :rtype: bool """ stack = list() match = &#123;'&#123;':'&#125;', '[':']', '(':')'&#125; for i in s: if i in match: stack.append(i) else: if len(stack) == 0: return False if match[stack[-1]] != i: return False stack.pop() if len(stack) != 0: return False return True LeetCode 32. 最长有效的括号 Longest Valid Parentheses 给定一个只包含 '(' 和 ')' 的字符串，找出最长的包含有效括号的子串的长度。 示例 1: 123输入: &quot;(()&quot;输出: 2解释: 最长有效括号子串为 &quot;()&quot; 示例 2: 123输入: &quot;)()())&quot;输出: 4解释: 最长有效括号子串为 &quot;()()&quot; 方法 用一个栈来存储左括号的索引. 遇到正确匹配的括号则弹出匹配的索引，所以栈中存储的是未匹配上的左括号。 新匹配上的括号位置减去前一段未匹配到的括号的索引的差，是当前有效子串的大小。 123456789101112131415161718192021class Solution: def longestValidParentheses(self, s: str) -&gt; int: maxlen = 0 # 最长的字串长度 last = -1 # 上一段有效子串的结尾位置 stack = [] # 栈里存放左括号的位置序号 for i in range(len(s)): if s[i] == '(': stack.append(i) # 存入左括号的位置序号 else:# 右括号 if stack == []: # 栈空 last = i # 配对失败，一段有效子串结尾 else: stack.pop() #取出配对左括号 if stack == []: # 配对完，栈空 #当前位置i减去上一段结尾last，是这一段有效子串的长度 maxlen = max(maxlen, i-last) else: # stack剩余的左括号未必能配对成功，先比较当前的有效子串 maxlen= max(maxlen, i - stack[-1]) return maxlen LeetCode 150. 逆波兰表达式求值 Evaluate Reverse Polish Notatio 根据逆波兰表示法，求表达式的值。 有效的运算符包括 +, -, *, / 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。 说明： 整数除法只保留整数部分。 给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。 示例 1： 123输入: [&quot;2&quot;, &quot;1&quot;, &quot;+&quot;, &quot;3&quot;, &quot;*&quot;]输出: 9解释: ((2 + 1) * 3) = 9 示例 2： 123输入: [&quot;4&quot;, &quot;13&quot;, &quot;5&quot;, &quot;/&quot;, &quot;+&quot;]输出: 6解释: (4 + (13 / 5)) = 6 方法 逆波兰式（Reverse Polish notation，RPN，或逆波兰记法），也叫后缀表达式（将运算符写在操作数之后） python 有个函数eval()，可以给它一个运算表达式，直接给你求值。中缀表达式转正常表达式很简单了，直接用栈就行。 但需要注意的是，python中的’/’负数除法和c语言不太一样。在python中，(-1)/2=-1，而在c语言中，(-1)/2=0。也就是c语言中，除法是向零取整，即舍弃小数点后的数。而在python中，是向下取整的。而这道题的oj是默认的c语言中的语法，所以需要在遇到’/’的时候注意一下。 可采用的方式是使用operator.truediv(int(a), int(b))变成和c相同的方式。 1234567891011121314151617class Solution: def evalRPN(self, tokens: List[str]) -&gt; int: stack = [] operators = ['+', '-','*','/'] for token in tokens: if token not in operators: stack.append(token) else: b = stack.pop() a = stack.pop() if token == '/': res = int(operator.truediv(int(a), int(b))) else: res = eval(a+token+b) stack.append(str(res)) return int(stack.pop()) 参考 problem-solving-with-algorithms-and-data-structure-using-python How does the Back button in a web browser work? 【LeetCode】150. Evaluate Reverse Polish Notation 解题报告（Python）]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>LeetCode</tag>
        <tag>数据结构</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python实现数据结构中的数组]]></title>
    <url>%2F2019%2F02%2F28%2Fpython%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[在数组中，访问数据十分简单，而添加和删除数据比较耗工夫。 由于数组中的数据是存储在连续空间内的，所以每个数据的内存地址（在内存上的位置）都可以通过数组下标算出，我们也就可以借此直接访问目标数据（这叫作“随机访问”），需要的运行时间仅为恒定的 O(1)。 向数组中添加新数据时，必须把目标位置后面的数据一个个移开。所以，如果在数组头部添加数据，就需要O(n)的时间。删除操作同理。 学习目标： - 实现一个支持动态扩容的数组 - 实现一个大小固定的有序数组，支持动态增删改操作 支持动态扩容的数组 类似于Python的简化版list 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import ctypes class DynamicArray: def __init__(self): """ Create an empty array.""" self._n = 0 #count actual elements self._capacity = 1 #default array capacity self._A = self._make_array(self._capacity) #low-level array def __len__(self): """Return number of elements stored in the array.""" return self._n def __getitem__(self,k): """Return element at index k.""" if not 0 &lt;= k &lt; self._n: raise IndexError('invalid index') return self._A[k] #retrieve from array def append(self, obj): """Add object to end of the array.""" if self._n == self._capacity: # not enough room self._resize(2*self._capacity) #so double capacity self._A[self._n] = obj self._n += 1 def _resize(self, c): # nonpublic utitity """Resize internal array to capacity c.""" B = self._make_array(c) # new (bigger) array for k in range(self._n): # for each existing value B[k] = self._A[k] self._A = B self._capacity = c def _make_array(self, c): # nonpublic utitity """Return new array with capacity c.""" return (c * ctypes.py_object)() # see ctypes documentation if __name__ == '__main__': da = DynamicArray() da.append(6) da.append(2) for o in da: print(o) 输出： 1262 大小固定的有序数组，支持动态增删改操作 123456789101112131415161718192021222324252627282930313233343536373839404142class NewArray: """ A dynamic array class akin to a simplified Python list.""" def __init__(self,capacity=10): """ Create an empty array.""" self._n = 0 #数组大小 self._A = [None] * capacity def __getitem__(self,k): """Return element at index k.""" if not 0 &lt;= k &lt; self._n: raise IndexError('invalid index') return self._A[k] #retrieve from array def insert(self,k,v): if k &gt;= len(self._A): raise IndexError('Index out of range!') for i in range(self._n, k-1, -1): self._A[i+1] = self._A[i] self._A[k] = v self._n += 1 def delete(self,k): v = self._A[k] for i in range(k+1,self._n): self._A[i-1] = self._A[i] self._n -= 1 return v def __setitem__(self,k,v): self._A[k] = v if __name__ == '__main__': A = NewArray() for i in range(5): A.insert(i, i) # 增 print(A[2]) A.delete(0) # 删 print(A[2]) A[0] = 10 # 改 print(A[0]) # 查 输出： 1232310 Leetcode习题 88. 合并两个有序数组 Merge Sorted Array 给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。 说明: - 初始化 nums1 和 nums2 的元素数量分别为 m 和 n。 - 你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。 示例: 输入: nums1 = [1,2,3,0,0,0], m = 3 nums2 = [2,5,6], n = 3 输出: [1,2,2,3,5,6] 方法：遍历比较，大的放最后 从后往前遍历两个数组，然后把对应的元素放在数组1对应的位置， 注意：最后我们只需判断数组2有没有遍历完即可，因为数组1没有遍历完的话，它已经是按顺序放在前面的了 12345678910111213141516171819class Solution(object): def merge(self, nums1, m, nums2, n): """ :type nums1: List[int] :type m: int :type nums2: List[int] :type n: int :rtype: void Do not return anything, modify nums1 in-place instead. """ while m&gt;0 and n&gt;0: if nums1[m-1] &gt; nums2[n-1]: nums1[m+n-1] = nums1[m-1] m -= 1 else: nums1[m+n-1] = nums2[n-1] n -= 1 if n&gt;0: nums1[:n] = nums2[:n] 1. 两数之和 Two Sum 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例: 给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9 所以返回 [0, 1] 方法：哈希表 利用python中的字典记录记录下每个元素出现的位置 12345678910111213141516class Solution(object): def twoSum(self, nums, target): """ :type nums: List[int] :type target: int :rtype: List[int] """ dic = dict() for index,value in enumerate(nums): sub = target - value if sub in dic: return [dic[sub], index] else: dic[value]=index 参考 mplementation of Dynamic Array in Python 任务1-数组与链表]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>LeetCode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python实现数据结构中的链表]]></title>
    <url>%2F2019%2F02%2F28%2Fpython%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[链表是数据结构之一，其中的数据呈线性排列。在链表中，数据的添加和删除都较为方便， 就是访问比较耗费时间。 链表在前一结点里用链接的方式显示地记录与下一结点的关系。不同于数组，链表的元素的物理地址可以任意。 学习目标： - 实现单链表、循环链表、双向链表，支持增删操作。 实现单链表 只需要掌握这个表的首结点，从它出发可以找到这个表里的下一结点，以至于找到表里的所有数据元素。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061class Node: # 链表的结点 def __init__(self, x, next_=None): self.val = x self.next = next_class SingleLinkList: # 单链表 def __init__(self): # 空表 self.head = None #增 def insertAsFirst(self, x): #x在首位插入 node = Node(x) node.next = self.head self.head = node def insertAsLast(self, x): #x在尾部插入 if not self.head: self.head = Node(x) return cur = self.head while cur.next != None: cur = cur.next node = Node(x) cur.next = node #删 def remove(self, p):#删除在位置p处的结点，返回其数值 k = self.head for i in range(p-1): k = k.next x = k.next.val k.next = k.next.next return x def remove_last(self): #删除表尾的结点 p = self.head if p.next is None: x = p.val self.head = None return x while p.next.next is not None: # 直到 p.next 是最后结点 p = p.next x = p.next.val p.next = None return x def show(self): cur = self.head while cur != None: # cur是一个有效的节点 print(cur.val, end=' --&gt; ') cur = cur.next print() if __name__ == '__main__': l = SingleLinkList() for i in range(10): l.insertAsLast(i) l.show() l.remove_last() l.show() 输出： 10 --&gt; 1 --&gt; 2 --&gt; 3 --&gt; 4 --&gt; 5 --&gt; 6 --&gt; 7 --&gt; 8 --&gt; 9 --&gt; 双向链表 增加了反向的链接，结点操作更加方便。但是每个结点都需要增加一个链接域，增加的空间开销与结点数成正比，O(n) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465class DLNode: # 链表的结点 def __init__(self, x, prev=None, next_=None): self.val = x self.next = next_ self.prev = prevclass DoubleLinkList: # 双链表 def __init__(self): # 空表 self.head = None #增 def insertAsFirst(self, x): #x在首位插入 if not self.head: self.head = DLNode(x) else: node = DLNode(x,None,self.head) self.head.prev = node self.head = node # node 作为新的头结点 def insertAsLast(self, x): #x在尾部插入 if not self.head: self.head = DLNode(x) else: cur = self.head while cur.next != None: # 移动到链表尾部 cur = cur.next node = DLNode(x) cur.next = node node.prev = cur #删 def remove(self, p):#删除在位置p处的结点，返回其数值 k = self.head for i in range(p-1): k = k.next x = k.next.val k.next = k.next.next k.next.prev = k return x def show(self): cur = self.head while cur != None: # cur是一个有效的节点 print(cur.val, end=' -- ') cur = cur.next print() def show_reverse(self): cur = self.head while cur.next != None: cur = cur.next while cur != None: print(cur.val, end=' -- ') cur = cur.prev print() if __name__ == '__main__': l = DoubleLinkList() for i in range(10): l.insertAsLast(i) l.show() l.remove(2) l.show() l.show_reverse() 输出： 1230 -- 1 -- 2 -- 3 -- 4 -- 5 -- 6 -- 7 -- 8 -- 9 -- 0 -- 1 -- 3 -- 4 -- 5 -- 6 -- 7 -- 8 -- 9 -- 9 -- 8 -- 7 -- 6 -- 5 -- 4 -- 3 -- 1 -- 0 -- Leetcode习题 206. 反转链表 Reverse Linked List 反转一个单链表。 示例: 输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL 输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL ### 方法：两个指针，头插法 - 用两个指针，p指针记录的是每次的队头元素，q指针指向下一个要插入队头的元素。 - head帮忙指向下轮要头插的元素，待本轮指针翻转完之后要把该元素赋给q 12345678910111213141516class Solution(object): def reverseList(self, head): """ :type head: ListNode :rtype: ListNode """ if not head: return None p = head # p是指向每次的队头元素 q = head.next # q是指下一个要插入队头的元素 while q: head.next = q.next # 保留后一个要插入的元素地址 q.next = p # 指针反转，next为队头元素 p = q #q插入，作为新的队头 q = head.next # 重新指定下一个要插入队头的元素 return p]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>LeetCode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用python刷LeetCode数组题(简单级)(二)]]></title>
    <url>%2F2019%2F02%2F26%2F%E7%94%A8python%E5%88%B7LeetCode%E6%95%B0%E7%BB%84%E9%A2%98(%E7%AE%80%E5%8D%95)(%E4%BA%8C)%2F</url>
    <content type="text"><![CDATA[169. 求众数 Majority Element ## 题目描述 给定一个大小为 n 的数组，找到其中的众数。众数是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。 你可以假设数组是非空的，并且给定的数组总是存在众数。 示例 1: 输入: [3,2,3] 输出: 3 方法： 遍历 最多的元素出现的次数大于数组长度的一半，在最极端的情况下，最后的count都会大于0 12345678910111213141516171819class Solution(object): def majorityElement(self, nums): """ :type nums: List[int] :rtype: int """ count = 1 res = nums[0] for i in range(1, len(nums)): if nums[i] == res: count += 1 else: count -= 1 if count == 0: res = nums[i] count = 1 return res 189. 旋转数组 Rotate Array ## 题目描述 给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。 示例 1: 输入: [1,2,3,4,5,6,7] 和 k = 3 输出: [5,6,7,1,2,3,4] 解释: 向右旋转 1 步: [7,1,2,3,4,5,6] 向右旋转 2 步: [6,7,1,2,3,4,5] 向右旋转 3 步: [5,6,7,1,2,3,4] 方法：直接拼接数组 123456789class Solution(object): def rotate(self, nums, k): """ :type nums: List[int] :type k: int :rtype: None Do not return anything, modify nums in-place instead. """ n = len(nums) nums[:] = nums[n-k:] + nums[:n-k] 217. 存在重复元素 Contains Duplicate ## 题目描述 给定一个整数数组，判断是否存在重复元素。 如果任何值在数组中出现至少两次，函数返回 true。如果数组中每个元素都不相同，则返回 false。 示例 1: 输入: [1,2,3,1] 输出: true 示例 2: 输入: [1,2,3,4] 输出: false 方法：set() 1234567class Solution(object): def containsDuplicate(self, nums): """ :type nums: List[int] :rtype: bool """ return len(nums) != len(set(nums)) 219. 存在重复元素 II Contains Duplicate II ## 题目描述 给定一个整数数组和一个整数 k，判断数组中是否存在两个不同的索引 i 和 j，使得 nums [i] = nums [j]，并且 i 和 j 的差的绝对值最大为 k。 示例 1: 输入: nums = [1,0,1,1], k = 1 输出: true 示例 2: 输入: nums = [1,2,3,1,2,3], k = 2 输出: false 方法 用dict保存数组元素出现的位置，两种情况下更新 1234567891011121314class Solution(object): def containsNearbyDuplicate(self, nums, k): """ :type nums: List[int] :type k: int :rtype: bool """ dic = dict() for index,value in enumerate(nums): if value in dic and index - dic[value] &lt;= k: return True dic[value] = index return False 268. 缺失数字 Missing Number ## 题目描述 给定一个包含 0, 1, 2, ..., n 中 n 个数的序列，找出 0 .. n 中没有出现在序列中的那个数。 示例 1: 输入: [3,0,1] 输出: 2 示例 2: 输入: [9,6,4,2,3,5,7,0,1] 输出: 8 方法：数学公式 123456789class Solution(object): def missingNumber(self, nums): """ :type nums: List[int] :rtype: int """ n = len(nums) return n* (n+1)/2 - sum(nums)]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>LeetCode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用python刷LeetCode数组题(简单级)(一)]]></title>
    <url>%2F2019%2F02%2F22%2F%E7%94%A8python%E5%88%B7LeetCode%E6%95%B0%E7%BB%84%E9%A2%98(%E7%AE%80%E5%8D%95%E7%BA%A7)(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[1. 两数之和 Two Sum 题目描述 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例: 123给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 方法：字典 利用python中的字典记录记录下每个元素出现的位置 12345678910111213141516class Solution(object): def twoSum(self, nums, target): """ :type nums: List[int] :type target: int :rtype: List[int] """ dic = dict() for index,value in enumerate(nums): sub = target - value if sub in dic: return [dic[sub], index] else: dic[value]=index 26. 删除排序数组中的重复项 Remove Duplicates from Sorted Array 题目描述 给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 示例 1: 给定数组 nums = [1,1,2], 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 你不需要考虑数组中超出新长度后面的元素。 示例 2: 给定 nums = [0,0,1,1,1,2,2,3,3,4], 函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。 你不需要考虑数组中超出新长度后面的元素。 说明: 为什么返回数值是整数，但输出的答案是数组呢? 请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 你可以想象内部操作如下: 12345678// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝int len = removeDuplicates(nums);// 在函数里修改输入数组对于调用者是可见的。// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。for (int i = 0; i &lt; len; i++) &#123; print(nums[i]);&#125; 方法：遍历一次 123456789101112131415161718class Solution(object): def removeDuplicates(self, nums): """ :type nums: List[int] :rtype: int """ if not nums: return 0 index = 0 for i in range(1,len(nums)): if nums[i] != nums[index]: index += 1 nums[index] = nums[i] return index+1 27. 移除元素 Remove Element 题目描述 给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。 示例 1: 给定 nums = [3,2,2,3], val = 3, 函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。 你不需要考虑数组中超出新长度后面的元素。 示例 2: 给定 nums = [0,1,2,2,3,0,4,2], val = 2, 函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。 注意这五个元素可为任意顺序。 你不需要考虑数组中超出新长度后面的元素。 方法：遍历一次 12345678910111213class Solution(object): def removeElement(self, nums, val): """ :type nums: List[int] :type val: int :rtype: int """ index = 0 for i in range(0,len(nums)): if nums[i]!=val: nums[index] = nums[i] index += 1 return index 35. 搜索插入位置 Search Insert Position ## 题目描述 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。 你可以假设数组中无重复元素。 示例 1: 输入: [1,3,5,6], 5 输出: 2 示例 2: 输入: [1,3,5,6], 2 输出: 1 示例 3: 输入: [1,3,5,6], 7 输出: 4 方法一：顺序查找 123456789101112class Solution(object): def searchInsert(self, nums, target): """ :type nums: List[int] :type target: int :rtype: int """ if target &gt; nums[-1]: return len(nums) for index, value in enumerate(nums): if value &gt;= target: return index 方法二：二分查找 1234567891011121314151617181920class Solution(object): def searchInsert(self, nums, target): """ :type nums: List[int] :type target: int :rtype: int """ left = 0 right = len(nums)-1 while left &lt;= right: mid = (right-left)/2 + left if nums[mid] == target: return mid elif nums[mid] &gt; target: right = mid-1 else: left = mid+1 return left 理论上应该比前一个方法快，实际测评结果较慢。 # 53. 最大子序和 Maximum Subarray 题目描述 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 示例: 输入: [-2,1,-3,4,-1,2,1,-5,4], 输出: 6 解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。 方法：Kadane's algorithm 用两个指针：max_so_far 指针记录此前所有碰到的最大和，max_ending_here 指针记录循环到当前元素的最大和。 当循环到元素i时， 如果 max_ending_here &lt; 0 的话，说明此前的和是负的，需要舍弃，所以将 max_ending_here 的值变为 i。 反之，表明当前的和还是正值， 将 max_ending_here 的值变为 i + max_ending_here,可以继续向前探索。 max_so_far 和 max_ending_here 比较，取较大值。 12345678910111213141516class Solution(object): def maxSubArray(self, nums): """ :type nums: List[int] :rtype: int """ max_so_far = max_ending_here = nums[0] for i in range(1,len(nums)): if max_ending_here &lt; 0: max_ending_here = nums[i] else: max_ending_here += nums[i] if max_ending_here &gt; max_so_far: max_so_far = max_ending_here return max_so_far 66. 加一 Plus One 题目描述 给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。 最高位数字存放在数组的首位， 数组中每个元素只存储一个数字。 你可以假设除了整数 0 之外，这个整数不会以零开头。 示例 1: 123输入: [1,2,3]输出: [1,2,4]解释: 输入数组表示数字 123。 示例 2: 123输入: [4,3,2,1]输出: [4,3,2,2]解释: 输入数组表示数字 4321。 方法一：反过来遍历 从最后一位，找一个记录当前进位的变量，然后遍历一遍数组 123456789101112131415class Solution: def plusOne(self, digits): """ :type digits: List[int] :rtype: List[int] """ for i in reversed(range(len(digits))): if digits[i] == 9: digits[i] = 0 else: digits[i] += 1 return digits digits[0] = 1 digits.append(0) return digits 方法二：转数字→字符串→int 12345678910class Solution: def plusOne(self, digits): """ :type digits: List[int] :rtype: List[int] """ sum = 0 for i in digits: sum = sum*10+i return [int(i) for i in str(sum+1)] 88. 合并两个有序数组 Merge Sorted Array ## 题目描述 给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。 说明: - 初始化 nums1 和 nums2 的元素数量分别为 m 和 n。 - 你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。 示例: 输入: nums1 = [1,2,3,0,0,0], m = 3 nums2 = [2,5,6], n = 3 输出: [1,2,2,3,5,6] 方法：遍历比较，大的放最后 从后往前遍历两个数组，然后把对应的元素放在数组1对应的位置， 注意：最后我们只需判断数组2有没有遍历完即可，因为数组1没有遍历完的话，它已经是按顺序放在前面的了 12345678910111213141516171819class Solution(object): def merge(self, nums1, m, nums2, n): """ :type nums1: List[int] :type m: int :type nums2: List[int] :type n: int :rtype: void Do not return anything, modify nums1 in-place instead. """ while m&gt;0 and n&gt;0: if nums1[m-1] &gt; nums2[n-1]: nums1[m+n-1] = nums1[m-1] m -= 1 else: nums1[m+n-1] = nums2[n-1] n -= 1 if n&gt;0: nums1[:n] = nums2[:n] 118. 杨辉三角 Pascal's Triangle ## 题目描述 给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。 在杨辉三角中，每个数是它左上方和右上方的数的和。 示例: 输入: 5 输出: 1234567[ [1], [1,1], [1,2,1], [1,3,3,1], [1,4,6,4,1]] 方法 每一行前补0，后补0，相加求和即为下一行的数。 1 3 3 1 0 + 0 1 3 3 1 = 1 4 6 4 1 12345678910111213class Solution(object): def generate(self, numRows): """ :type numRows: int :rtype: List[List[int]] """ if numRows == 0: return [] res = [[1]] for i in range(1, numRows): res.append(map(lambda x,y:x+y, res[-1]+[0], [0]+res[-1])) return res 119. 杨辉三角 II Pascal's Triangle II 题目描述 给定一个非负索引 k，其中 k ≤ 33，返回杨辉三角的第 k 行。 在杨辉三角中，每个数是它左上方和右上方的数的和。 示例: 输入: 3 输出: [1,3,3,1] 方法 思路同上一题 12345678910class Solution(object): def getRow(self, rowIndex): """ :type rowIndex: int :rtype: List[int] """ res = [1] for i in range(1, rowIndex+1): res = list(map(lambda x,y:x+y, res+[0], [0]+res)) return res 121. 买卖股票的最佳时机 Best Time to Buy and Sell Stock ## 题目描述 给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。 注意你不能在买入股票前卖出股票。 示例 1: 输入: [7,1,5,3,6,4] 输出: 5 解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。 示例 2: 输入: [7,6,4,3,1] 输出: 0 解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 方法一：遍历 根据题意，我们只需要找出数组中最大的差值即可，即 max(prices[j] – prices[i]) ，i &lt; j 。 如何得到最大的差值，只需要一次遍历即可，在遍历的用一个变量记录遍历到当前时的最小值即可。时间复杂度为 O(n). 12345678910111213141516171819class Solution(object): def maxProfit(self, prices): """ :type prices: List[int] :rtype: int """ if prices is None or len(prices)&lt;2: return 0 buy = prices[0] # 买入 profit = 0 # 利润 for i in range(1,len(prices)): if prices[i] &lt; buy: buy = prices[i] else: if prices[i] - buy &gt; profit: profit = prices[i] - buy return profit 方法二：Kadane's algorithm 方法同上面的53题-求数组中和最大的连续子数组序列。 如何转化为求数组中的和最大的连续子序列？相邻两个数作差即可，这样的话子序列的和就是我们在子序列开始卖出股票，在子序列最后买回股票所能得到的收益。 12345678910111213class Solution(object): def maxProfit(self, prices): """ :type prices: List[int] :rtype: int """ max_so_far = max_ending_here = 0 for i in range(1, len(prices)): max_ending_here = max(0, max_ending_here + prices[i] - prices[i-1]) max_so_far = max(max_so_far, max_ending_here) return max_so_far 测试结果比前一个方法慢 122. 买卖股票的最佳时机 II Best Time to Buy and Sell Stock II ## 题目描述 给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 示例 1: 输入: [7,1,5,3,6,4] 输出: 7 解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。 示例 2: 输入: [1,2,3,4,5] 输出: 4 解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。 因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。 示例 3: 输入: [7,6,4,3,1] 输出: 0 解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 方法：遍历 如果后面的股价比前面的大，我们就买卖 1234567class Solution(object): def maxProfit(self, prices): """ :type prices: List[int] :rtype: int """ return sum(max(prices[i+1]-prices[i], 0) for i in range(len(prices)-1)) 167. 两数之和 II - 输入有序数组 题目描述 给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。 函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。 说明: 返回的下标值（index1 和 index2）不是从零开始的。 你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。 示例: 输入: numbers = [2, 7, 11, 15], target = 9 输出: [1,2] 解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。 方法 思路同第1题 123456789101112131415class Solution(object): def twoSum(self, numbers, target): """ :type numbers: List[int] :type target: int :rtype: List[int] """ dic = dict() for index, value in enumerate(numbers): sub = target - value if sub in dic: return (dic[sub]+1, index+1) else: dic[value] = index 参考 3个月用python刷完leetcode600题!-数组简单题（一） Largest Sum Contiguous Subarray]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>LeetCode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用python刷LeetCode链表题(简单级)]]></title>
    <url>%2F2019%2F02%2F20%2F%E7%94%A8python%E5%88%B7LeetCode%E4%B8%AD%E9%93%BE%E8%A1%A8%E9%A2%98(%E7%AE%80%E5%8D%95%E7%BA%A7)%2F</url>
    <content type="text"><![CDATA[练习题目： 合并两个有序链表 删除排序链表中的重复元素 环形链表 相交链表 移除链表元素 反转链表 回文链表 删除链表中的节点 21. 合并两个有序链表 Merge Two Sorted Lists 题目描述 将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 示例： 输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4 输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 方法 同时遍历两个链表，每次选取两个链表中较小值的节点，依次连接起来，就能得到最终的链表。 注意： 1. 返回值要返回head.next 2. 无需判断循环后哪个不为空，or返回第一个为真的值 12345678910111213141516171819202122232425# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def mergeTwoLists(self, l1, l2): """ :type l1: ListNode :type l2: ListNode :rtype: ListNode """ head = cur = ListNode(0) while l1 and l2: if l1.val &lt; l2.val: cur.next = l1 l1 = l1.next else: cur.next = l2 l2 = l2.next cur = cur.next cur.next = l1 or l2 return head.next 83. 删除排序链表中的重复元素 Remove Duplicates from Sorted List 题目描述 给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。 示例 1: 输入: 1-&gt;1-&gt;2 输出: 1-&gt;2 示例 2: 输入: 1-&gt;1-&gt;2-&gt;3-&gt;3 输出: 1-&gt;2-&gt;3 方法一：两个指针 用两个指针来完成，分别记录要删除的链表元素和上一个元素。 123456789101112131415161718192021222324# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def deleteDuplicates(self, head): """ :type head: ListNode :rtype: ListNode """ if not head: return head p = head q = head.next while q: if p.val == q.val: p.next = q.next q = q.next else: p = p.next q = q.next return head 方法二： 一个指针 12345678910111213class Solution: def deleteDuplicates(self, head): """ :type head: ListNode :rtype: ListNode """ cur = head while cur: while cur.next and cur.val == cur.next.val: cur.next = cur.next.next cur = cur.next return head 141. 环形链表 Linked List Cycle 题目描述 给定一个链表，判断链表中是否有环。 方法：快慢双指针 通过使用具有不同速度的快、慢两个指针遍历链表，空间复杂度可以被降低至 O(1)。慢指针每次移动一步，而快指针每次移动两步。 如果列表中不存在环，最终快指针将会最先到达尾部，此时我们可以返回 false。 考虑一个环形链表，把慢指针和快指针想象成两个在环形赛道上跑步的运动员（分别称之为walker与runner）。而runner最终一定会追上walker。这是为什么呢？考虑下面这种情况（记作情况 A） - 假如runner只落后walker一步，在下一次迭代中，它们就会分别跑了一步或两步并相遇。 其他情况又会怎样呢？例如，我们没有考虑快跑者在慢跑者之后两步或三步的情况。但其实不难想到，因为在下一次或者下下次迭代后，又会变成上面提到的情况 A。 1234567891011121314151617class Solution(object): def hasCycle(self, head): """ :type head: ListNode :rtype: bool """ if not head: return False walker = head runner = head.next try: while walker != runner: walker = walker.next runner = runner.next.next return True except: return False 略微改变语法形式，思路没有区别： 1234567891011121314151617class Solution(object): def hasCycle(self, head): """ :type head: ListNode :rtype: bool """ if not head or not head.next : return False walker = head runner = head.next while walker != runner: # 改成判断快指针先到达尾部 if not runner or not runner.next: return False walker = walker.next runner = runner.next.next return True 更简洁的写法 12345678910111213class Solution(object): def hasCycle(self, head): """ :type head: ListNode :rtype: bool """ fast = slow = head while slow and fast and fast.next: slow = slow.next fast = fast.next.next if slow is fast: return True return False 160. 相交链表 Intersection of Two Linked Lists 题目描述 编写一个程序，找到两个单链表相交的起始节点。 如下面的两个链表： avatar 在节点 c1 开始相交。 注意： 如果两个链表没有交点，返回 null. 在返回结果后，两个链表仍须保持原有的结构。 可假定整个链表结构中没有循环。 程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。 方法：两指针 判断链表是否有交集，可以设置两个指针，一个指针从第一个链表开始遍历，遍历完第一个链表再遍历第二个链表，另一个指针从第二个链表开始遍历，遍历完第二个链表再遍历第一个链表. 不管两个链表在交集前的长度如何，遍历两个链表长度总和相同。 如果有交集的话，两个指针肯定会同时遍历到最后的交集部分。 1234567891011121314class Solution(object): def getIntersectionNode(self, headA, headB): """ :type head1, head1: ListNode :rtype: ListNode """ if not headA or not headB: return None pa = headA pb = headB while pa is not pb: pa = headB if pa == None else pa.next pb = headA if pb == None else pb.next return pa 203. 移除链表元素 题目描述 删除链表中等于给定值 val 的所有节点。 示例: 输入: 1-&gt;2-&gt;6-&gt;3-&gt;4-&gt;5-&gt;6, val = 6 输出: 1-&gt;2-&gt;3-&gt;4-&gt;5 方法：dummy node 有了第83题的思路，我们这里可以用一个指针来进行链表的遍历， 但是这里需要注意的是，头节点也需要进行判断，如果头节点的值等于val的话，我们不能返回头节点，所以这里很巧妙的重新生成了一个无关的头节点dummy node。 123456789101112131415class Solution(object): def removeElements(self, head, val): """ :type head: ListNode :type val: int :rtype: ListNode """ dummy = ListNode(-1) dummy.next = head cur = dummy while cur: while cur.next and cur.next.val == val: cur.next = cur.next.next cur = cur.next return dummy.next 206. 反转链表 Reverse Linked List 题目描述 反转一个单链表。 示例: 输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL 输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL 方法：两个指针，头插法 用两个指针，p指针记录的是每次的队头元素，q指针指向下一个要插入队头的元素。 head帮忙指向下轮要头插的元素，待本轮指针翻转完之后要把该元素赋给q 12345678910111213141516class Solution(object): def reverseList(self, head): """ :type head: ListNode :rtype: ListNode """ if not head: return None p = head # p是指向每次的队头元素 q = head.next # q是指下一个要插入队头的元素 while q: head.next = q.next # 保留后一个要插入的元素地址 q.next = p # 指针反转，next为队头元素 p = q #q插入，作为新的队头 q = head.next # 重新指定下一个要插入队头的元素 return p 较简洁的写法 123456class Solution: def reverseList(self, head: ListNode) -&gt; ListNode: cur, prev = head, None while cur: cur.next, prev, cur = prev, cur, cur.next return prev 234. 回文链表 Palindrome Linked List 题目描述 请判断一个链表是否为回文链表。 示例 1: 输入: 1-&gt;2 输出: false 示例 2: 输入: 1-&gt;2-&gt;2-&gt;1 输出: true 方法：两个指针 两个指针，一个指针从前往后走，一个指针从后往前走，判断元素值是否相同，这里要分几个步骤来进行求解： 1、找到链表长度的一半，用追赶法，一个指针一次走两步，一个指针一次走一步 2、将后一半数组反转 3、比较两边元素是否相同，判断链表是否是回文链表 123456789101112131415161718192021222324class Solution(object): def isPalindrome(self, head): """ :type head: ListNode :rtype: bool """ slow = fast = head while fast and fast.next: slow = slow.next fast = fast.next.next node = None #反转后一半链表 while slow: nxt = slow.next slow.next = node node = slow # node是反转后的第一个元素 slow = nxt while node and head: if node.val != head.val: return False node = node.next head = head.next return True 237. 删除链表中的节点 Delete Node in a Linked List 题目描述 输入：要求被删除的（非末尾）节点 函数功能：删除某个链表中的这个节点。无返回。 示例 1: 输入: head = [4,5,1,9], node = 5 输出: [4,1,9] 解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9. 示例 2: 输入: head = [4,5,1,9], node = 1 输出: [4,5,9] 解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9. 说明: 链表至少包含两个节点。 链表中所有节点的值都是唯一的。 给定的节点为非末尾节点并且一定是链表中的一个有效节点。 不要从你的函数中返回任何结果。 方法:替换值 关键是理解题意，不给你整个链表，只给你一个节点，如何把这个节点删除。 其实我们没必要真的把这个节点删除，而是把这个节点对应的val值删除即可， 所以我们可以偷天换日，把下一个节点的值赋给这个节点，再把下一个节点删除。 12345678class Solution(object): def deleteNode(self, node): """ :type node: ListNode :rtype: void Do not return anything, modify node in-place instead. """ node.val = node.next.val node.next = node.next.next 参考 3个月用python刷完leetcode600题!-linked_list简单题 21. Merge Two Sorted Lists [easy] (Python)]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>LeetCode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[week3-贪心算法]]></title>
    <url>%2F2018%2F10%2F24%2Fweek3-Greedy%20Algorithms%2F</url>
    <content type="text"><![CDATA[概述 贪心算法是指，在对问题求解时，每一步选择中总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的是在某种意义上的局部最优解。 实现过程 从问题的某一初始解出发；while 能朝给定总目标前进一步 do，求出可行解的一个解元素； 最后，由所有解元素组合成问题的一个可行解。 创建数学模型来描述问题。 把求解的问题分成若干个子问题。 对每一子问题求解，得到子问题的局部最优解。 把子问题的解局部最优解合成原来解问题的一个解。 注意： - 贪心算法与动态规划的不同在于它对每个子问题的解决方案都做出选择，不能回退。动态规划则会保存以前的运算结果，并根据以前的结果对当前进行选择，有回退功能。 - 贪心法可以解决一些最优化问题，如：求图中的最小生成树、求哈夫曼编码…… - 对于大部分的问题，贪心法通常都不能找出最佳解（不过也有例外），因为他们一般没有测试所有可能的解。贪心法容易过早做决定，因而没法达到最佳解。例如，所有对图着色问题。 学习目标 Practice implementing greedy solutions Build greedy algorithms Create a program for changing money optimally Create a program for maximizing the value of a loot Create a program for maximizing the number of prize places in a competition Apply greedy strategy to solve various computational problems. This will usually require you to design an algorithm that repeatedly makes the most profitable move to construct a solution. You will then need to show that the moves of your algorithm are safe, meaning that they are consistent with at least one optimal solution. Design and implement an eficient greedy algorithm for the following problems: changing money with a minimum number of coins; maximizing the total value of a loot; maximizing revenue in online ad placement; minimizing work while collecting signatures; maximizing the number of prize places in a competition; finally, maximizing your salary! 兑换零钱(Money Change) Task. 根据输入值，找到需要兑换 1, 5, 10面额硬币的最少个数. Input Format. 输入一个整数\(m\). Constraints. \(1 ≤ n ≤ 10^3\). Output Format. Output the minimum number of coins with denominations 1, 5, 10 that changes \(m\). Sample 1. 1234Input:28Output:6 28 = 10 + 10 + 5 + 1 + 1 + 1. 方法一 12345678910111213def get_change(m): coins = [10, 5, 1] n = 0 for a in coins: while m &gt;= a: n += 1 m -= a if m == 0: break return nprint(get_change(2))print(get_change(28))print(get_change(999)) 2 6 104 方法二 123456789101112def get_changeC(m): coins = [10, 5, 1] n = 0 for a in coins: # Update the the number of coins 'held' in the amount. n += m // a # Put remainder to the residuary amount. m %= a return nprint(get_changeC(2))print(get_changeC(28))print(get_changeC(999)) 2 6 104 背包问题(Maximum Value of the Loot ) Task. A thief finds much more loot than his bag can fit. Help him to find the most valuable combination of items assuming that any fraction of a loot item can be put into his bag. Input Format. 输入包可承受的重量(capacity)\(W\)，\(n\)件掠夺品的重量weights和价值values分别是\(w_i,v_i\) Constraints. \(1 ≤ n ≤ 10^3, 0 ≤W≤ 2·10^6, 0 ≤v_i≤ 2·10^6, 0 ≤ w_i ≤ 2·10^6\) 所有数字都是整数. Output Format. Output the maximal value of fractions of items that fit into the knapsack. Sample 1. 1234Input:50, [20,50,30], [60,100,120]Output:180.0000 选了第1件和第3件东西。 方法一 12345678910111213141516171819202122232425def get_optimal_value(capacity, weights, values): value = 0 n = len(weights) # A = [None] * n pers = [None] * n for i in range(n): pers[i] = values[i] / weights[i] for _ in range(n): if capacity == 0: return value m = pers.index(max(pers)) a = min(weights[m], capacity) value += a*pers[m] weights[m] -= a if weights[m] == 0: pers[m] = 0 # A[m] += a capacity -= a return valueprint("&#123;:.10f&#125;".format(get_optimal_value(10, [30], [500])))print("&#123;:.10f&#125;".format(get_optimal_value(50, [20,50,30], [60,100,120]))) 166.6666666667 180.0000000000 方法二 Optimization 首先按降序将 \(\frac{v}{w}\) 排序 1234567891011121314151617181920212223def get_optimal_value(capacity, weights, values): value = 0 weight_value_pairs = sorted(list(zip(weights, values)), key = lambda x:x[1]/x[0], reverse=True) for (w, v) in weight_value_pairs: # If the item fit into the knapsack, put it and recalculate space left. if capacity - w &gt;= 0: value += v capacity -= w else: # Otherwise calculate weight of unit of the item and fill # the knapsack's left space. value += (v / w) * capacity capacity = 0 if not capacity: break return valueprint("&#123;:.10f&#125;".format(get_optimal_value(10, [30], [500])))print("&#123;:.10f&#125;".format(get_optimal_value(50, [20,50,30], [60,100,120]))) 166.6666666667 180.0000000000 广告点击最大收益 （Maximum Advertisement Revenue） Task. You have \(n\) ads to place on a popular Internet page. For each ad, you know how much is the advertiser willing to pay for one click on this ad. You have set up \(n\) slots on your page and estimated the expected number of clicks per day for each slot. Now, your goal is to distribute the ads among the slots to maximize the total revenue. Input Format. 给定两组序列\(a_1,a_2,...,a_n\)(\(a_i\) 是第 \(i\) 条广告的点击利润)，\(b_1,b_2,...,b_n\)(\(b_i\) 是第 \(i\) 个位置的平均每天点击数)，把它们对应分成\(n\)组\((a_i,b_j)\)使他们乘积的总和最大。 Constraints. \(1 ≤ n ≤ 10^3, -10^5 ≤a_i,b_i≤ 10^5\) Output Format. 输出 \(\sum^n_{i=1}a_ic_i\) 的最大值。\(c_1,c_2,...,c_n\)是\(b_1,b_2,...,b_n\)的重排列 Sample 1. 1234Input:[1,3,-5], [-2,4,1]Output:23 \(23 = 3 · 4 + 1 · 1 + (−5) · (−2).\) 先排好序，最大的在前，最大的两个乘积，随后循环,这样得到的乘积和最大。 1234567891011def max_dot_product(a, b): a = sorted(a, reverse=True) b = sorted(b, reverse=True) res = 0 for i in range(len(a)): res += a[i] * b[i] return resprint(max_dot_product([23], [39]))print(max_dot_product([1,3,-5], [-2,4,1])) 897 23 找房客签字的最佳时间点 Collecting Signatures Task. You are responsible for collecting signatures from all tenants of a certain building. For each tenant, you know a period of time when he or she is at home. You would like to collect all signatures by visiting the building as few times as possible.Your goal is to mark as few points on a line as possible so that each segment contains at least one marked point.找最少的标记时间点数\(m\)，使每个时间段内都有标记时间点。 Input Format. \(n\)段时间 \(\{[a_0,b_0],[a_1,b_1],...,[a_{n-1},b_{n-1}]\}\) Constraints. \(1 ≤ n ≤ 100, -0≤a_i ≤b_i≤ 10^9\) Output Format. 标记的位置点 Sample 1. 1234Input:[(4,7), (1,3), (2,5), (5,6)]Output:3 6 1234567891011121314151617181920212223242526272829def optimal_points(segments): # 按结束时间先后排序 segments.sort(key = lambda x:x[1]) points = [] for s in segments: points.append(s[0]) points.append(s[1]) result = [] n = len(segments) c = 1 i = 1 result.append(points[c]) # 加入第一个结束时间点为标记点 while i &lt; n: if points[i*2] &gt; points[c]: # 如果下一段起始时间点晚于标记点 c = i*2+1 # 则把这段的结束时间点加入标记点 result.append(points[c]) i += 1 return resultpoints1 = optimal_points([(1,3), (2,5), (3,6)])#print(len(points1))for p in points1: print(p, end=' ')print("\n") points2 = optimal_points([(4,7), (1,3), (2,5), (5,6)])#print(len(points2))for p in points2: print(p, end=' ') 3 3 6 分不同数量的奖品 Task. 你在给孩子们组织一场有趣的竞赛。你有\(n\) 个糖果作为奖品.你想把这些奖品给比赛前 \(k\) 名的孩子。名次越高，获奖糖果应该越多。为了使尽可能多孩子开心，你要找最多的获奖名额\(k\). Input Format. 整数 \(n\) Constraints. $1 ≤ n ≤ 10^9 $ Output Format. 获奖名额 \(k\) 和 分别获得的糖果数 (每个名次的获奖糖果数不应相同.) Sample 1. 12345Input:7Output:31 2 4 1234567891011121314151617181920212223242526272829303132def optimal_summands(n): summands = [1] #被加数 n -= 1 # 剩余糖果数 while n: last_element = summands[-1] # Save move: check whether the incremented last element can be used as # the next summand. if (last_element + 1) * 2 &lt;= n: # 如果最后一个数比n的一半还小 n -= last_element + 1 summands.append(last_element + 1) # 添加获奖名额及获奖数 else: if last_element &gt;= n: # 如果最后一个数大于n n += summands.pop() summands.append(n) # 添加获奖名额及获奖数 n = 0 return summandssummands = optimal_summands(2)print(len(summands))for x in summands: print(x, end=' ')print("\n")summands = optimal_summands(6)print(len(summands))for x in summands: print(x, end=' ')print("\n")summands = optimal_summands(7)print(len(summands))for x in summands: print(x, end=' ')print("\n") 1 2 3 1 2 3 3 1 2 4 这里设置&lt;=n 而不是&lt;n 是要考虑要奖品数为2的情况，必须把之前的1退回去。 最大薪水 Maximum Salary Task. As the last question of a successful interview, your boss gives you a few pieces of paper with numbers on it and asks you to compose a largest number from these numbers. The resulting number is going to be your salary, so you are very much interested in maximizing this number. How can you do this?不同的数拼成一个最大数(这些数未必只是一位数。(比如23和3，应该拼成323最大) Input Format. \(n\)个数 \(a_0,a_1,...,a_n\) Constraints. \(1 ≤ n ≤ 100, 1≤a_i ≤ 10^3\) Output Format. 可组成的最大数 Sample 1. 1234Input:[21,2]Output:221 12345678910111213141516171819202122232425import sysdef isGreaterOrEqual(digit,maxDigit): d = int(str(digit)+str(maxDigit)) m = int(str(maxDigit)+str(digit)) return (d &gt;= m)def largest_number(a): res = "" r=[] while a != []: maxDigit = 0 for digit in a: if isGreaterOrEqual(digit,maxDigit): maxDigit = digit r.append(maxDigit) a.remove(maxDigit) for rr in r: res += str(rr) return resprint(largest_number([21,2]))print(largest_number([23,39,92]))print(largest_number([9,4,6,1,9])) 221 923923 99641 参考： - Coursera：algorithmic toolbox(week3)]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>Algorithm - 背包问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[week2-Algorithm Warmup]]></title>
    <url>%2F2018%2F09%2F28%2Fweek2-algorithm_warmup%2F</url>
    <content type="text"><![CDATA[Estimate the running time of an algorithm Practice implementing efficient solutions Practice solving programming challenges Implement programs that are several orders of magnitude faster than straightforward programs Fibonacci Numbers 斐波那契数列 Task. Given an integer \(n\), find the last digit of the nth Fibonacci number \(F_n\). Input Format. The input consists of a single integer \(n\). Constraints. $0 ≤ n ≤ 45 $. Output Format. Output \(F_n\). Sample 1. 1234Input:10Output:55 \(F_{10} = 55\) 0 1 1 2 3 5 8 13 Naive Algorithm 递归 123456789def calc_fib(n): if (n &lt;= 1): return n return calc_fib(n - 1) + calc_fib(n - 2)print(calc_fib(6))print(calc_fib(20))print(calc_fib(34)) 8 6765 5702887 时间复杂度：\(O(2^n)\) Fast Algorithm 动态规划 - 递归 + 记忆化 -&gt; 递推 - 递推公式：A[i] = A[i-1] + A[i-2] 1234567891011def calc_fibFast(n): A = [None]* (n+1) A[0] = 0 A[1] = 1 for i in range(2, n+1): A[i] = A[i-1] + A[i-2] return A[n]print(calc_fibFast(6))print(calc_fibFast(20))print(calc_fibFast(34)) 8 6765 5702887 时间复杂度：\(O(n)\) 123456789101112131415def calc_fibFast(n): if n &lt;= 1: return n previous = 0 current = 1 for _ in range(n - 1): previous, current = current, previous + current return currentprint(calc_fibFast(6))print(calc_fibFast(20))print(calc_fibFast(34)) 8 6765 5702887 Last Digit of a Large Fibonacci Number 求斐波那契数的个位数 Task. Given an integer \(n\), fnd the last digit of the nth Fibonacci number \(F_n\) mod \(m\) (that is, \(F_n\) mod 10). Input Format. The input consists of a single integer \(n\). Constraints. $0 ≤ n ≤ 10^{7} $. Output Format. Output the last digit of \(F_n\). Sample 1. 1234Input:3Output:2 \(F_3 = 2\). ## Naive Algorithm 1234567891011121314151617def get_fibonacci_last_digit_naive(n): if n &lt;= 1: return n previous = 0 current = 1 for _ in range(n - 1): previous, current = current, previous + current return current % 10print(get_fibonacci_last_digit_naive(6))print(get_fibonacci_last_digit_naive(20))print(get_fibonacci_last_digit_naive(34))print(get_fibonacci_last_digit_naive(331)) 8 5 7 9 Fast Algorithm 每次只保留斐波那契数的个位数 1234567891011121314151617def get_fibonacci_last_digit_Fast(n): if n &lt;= 1: return n previous = 0 current = 1 for _ in range(n - 1): previous, current = current, (previous + current) % 10 return currentprint(get_fibonacci_last_digit_Fast(6))print(get_fibonacci_last_digit_Fast(20))print(get_fibonacci_last_digit_Fast(34))print(get_fibonacci_last_digit_Fast(331)) 8 5 7 9 Greatest Common Divisor 最大公约数 Task. Given two integers \(a\) and \(b\), find their greatest common divisor. Input Format. The two integers \(a\) and \(b\) are given in the same line separated by space.. Constraints. \(1 ≤ a, b ≤ 2·10^{9}\). Output Format. Output GCD(a, b). Sample 1. 1234Input:18 35Output:1 18 and 35 do not have common non-trivial divisors. ## Naive Algorithm 同时能整除a和b的最大的数 1234567891011def gcd_naive(a, b): current_gcd = 1 for d in range(2, min(a, b) + 1): if a % d == 0 and b % d == 0: if d &gt; current_gcd: current_gcd = d return current_gcdprint(gcd_naive(12, 4))print(gcd_naive(18, 35))print(gcd_naive(28851538, 1183019)) 4 1 17657 Fast Algorithm 辗转相除法， 又名欧几里德算法（Euclidean algorithm） 123456789def gcd_Euclid(a, b): if b == 0: return a r = a % b return gcd_Euclid(b, r) print(gcd_Euclid(12, 4))print(gcd_Euclid(18, 35))print(gcd_Euclid(28851538, 1183019)) 4 1 17657 Least Common Multiple 最小公倍数 Task. Given two integers \(a\) and \(b\), fnd their least common multiple. Input Format. The two integers \(a\) and \(b\) are given in the same line separated by space.. Constraints. \(1 ≤ a, b ≤ 2·10^{9}\). Output Format. Output the least common multiple of \(a\) and \(b\). Sample 1. 1234Input:6 8Output:24 Among all the positive integers that are divisible by both 6 and 8 (e.g., 48, 480, 24), 24 is the smallest one. ## Naive Algorithm 同时是a和b的倍数的最小值 123456789def lcm_naive(a, b): for l in range(1, a*b + 1): if l % a == 0 and l % b == 0: return l return a*bprint(lcm_naive(6, 8))print(lcm_naive(28851538, 1183019)) 24 1933053046 Fast Algorithm 性质：两个数的乘积等于这两个数的最大公约数与最小公倍数的积。用辗转相除法求出最大公约数，再求最小公倍数。 1234567891011def gcd_Euclid(a, b): if b == 0: return a r = a % b return gcd_Euclid(b, r)def lcm_fast(a, b): return a*b // gcd_Euclid(a, b)print(lcm_fast(6, 8))print(lcm_fast(28851538, 1183019)) 24 1933053046 Fibonacci Number modulo m 斐波那契数取余 \(i\) 0 \(F_i\) 0 \(F_i\) mod 2 0 \(F_i\) mod 3 0 可以看出序列是有周期性的。模3以01120221循环，模2以011循环。此类循环都是以01开始，称为皮萨诺周期(pisano period) \(F_(2015)\) mod 3 只需要找到2015被8除的余数. Since 2015 = 251 · 8 + 7, we conclude that \(F_(2015)\) mod 3 = \(F_7\) mod 3 = 1. Task. Given two integers \(m\) and \(n\), output \(F_n\) mod \(m\) (that is, the remainder of \(F_n\) when divided by \(m\)). Input Format. The input consists of two integers \(m\) and \(n\) given on the same line (separated by a space). Constraints. \(1 ≤ n ≤ 10^{18},2 ≤ m ≤ 10^{3}\). Output Format. Output \(F_n\) mod \(m\). Sample 1. 1234Input:239 1000Output:161 \(F_239 mod 1000 = 39 679 027 332 006 820 581 608 740 953 902 289 877 834 488 152 161 (mod 1 000) = 161\). ## Naive Algorithm 123456789101112def get_fibonacci_huge_naive(n, m): if n &lt;= 1: return n previous = 0 current = 1 for _ in range(n - 1): previous, current = current, previous + current return current % mprint(get_fibonacci_huge_naive(239, 1000)) 161 Fast Algorithm 计算Fibonacci数直到m平方，因为pisano period不可能大于这个数。 因为最后一个数的后面是下一周期的0和1，那假设最后两个数分别是x和y，则(x+y)%m=0, (y+0)%m=1，所以 y=1, x=m-1为判别式。 1234567891011121314def get_fibonacci_huge_fast(n, m): A = [None]* (m**2) A[0] = 0 A[1] = 1 for i in range(2, m**2): A[i] = (A[i-1] + A[i-2]) % m if A[i] == 1 and A[i-1] == m-1: period = i+1 break t = n % period return A[t] % mprint(get_fibonacci_huge_fast(239, 1000))print(get_fibonacci_huge_fast(2816213588, 239)) 161 151 Last Digit of the Sum of Fibonacci Numbers 求斐波那契数之和的个位数 Task. Given an integer \(n\), fnd the last digit of the sum \(F_0 + F_1 + · · · + F_n\). Input Format. The input consists of a single integer \(n\). Constraints. \(0 ≤ n ≤ 10^{18}\). Output Format. Output the last digit of \(F_0 + F_1 + · · · + F_n\). Sample 1. 1234Input:3Output:4 \(F_0 + F_1 + F_2 + F_3 = 0 + 1 + 1 + 2= 4\). ## Naive Algorithm 12345678910111213141516def fibonacci_sum_naive(n): if n &lt;= 1: return n previous = 0 current = 1 sum = 1 for _ in range(n - 1): previous, current = current, previous + current sum += current return sum % 10print(fibonacci_sum_naive(3))print(fibonacci_sum_naive(100))print(fibonacci_sum_naive(240)) 4 5 0 Fast Algorithm 斐波那契数列的递归定义形式如下： \[a_n= \begin{cases} a_{n-1}+a_{n-2},\\ 1,&amp; {n\leq 1} \end{cases} \] 斐波那契数列求和公式： \[S_n= 2a_n+a_{n-1}-1\] 123456789101112131415def fibonacci_sum_fast(n): if n &lt;= 1: return n previous = 0 current = 1 for _ in range(n - 1): previous, current = current, (previous + current) return (2*current + previous - 1) % 10print(fibonacci_sum_fast(3))print(fibonacci_sum_fast(100))print(fibonacci_sum_fast(240))print(fibonacci_sum_fast(999999)) 4 5 0 0 More Fast Algorithm 去掉循环,用pisano period方法 123456789101112131415161718192021def fibonacci_sum_more_fast(n): if n &lt;= 1: return n A = [None]* (100) A[0] = 0 A[1] = 1 for i in range(2, 100): A[i] = (A[i-1] + A[i-2]) % 10 if A[i] == 1 and A[i-1] == 9: period = i+1 break t = n % period if t == 0: t = period-1 return (2*A[t] + A[t-1] - 1) % 10print(fibonacci_sum_more_fast(0))print(fibonacci_sum_more_fast(3))print(fibonacci_sum_more_fast(100))print(fibonacci_sum_more_fast(240))print(fibonacci_sum_more_fast(999999))print(fibonacci_sum_more_fast(832564823476)) 0 4 5 0 0 3 考虑到余数t==0的情况，A[t-1]值会出问题，因为是新一周期循环，值为0，所以，可以令t=period-1 Last Digit of the Sum of Fibonacci Numbers Again 求斐波那契数之部分和的个位数 Task. Given two non-negative integers \(m\) and \(n\), where \(m≤n\), fnd the last digit of the sum \(F_m + F_{m+1} + · · · + F_n\). Input Format. The input consists of two non-negative integers \(m\) and \(n\) separated by a space. Constraints. \(0 ≤m≤ n ≤ 10^{18}\). Output Format. Output the last digit of \(F_m + F_{m+1} + · · · + F_n\). Sample 1. 1234Input:3 7Output:1 \(F_3 + F_4 + F_5 + F_6 + F_7 = 2 + 3 + 5 + 8 + 13 = 31\). ## Naive Algorithm 12345678910111213141516171819def fibonacci_partial_sum_naive(from_, to): sum = 0 current = 0 next = 1 for i in range(to + 1): if i &gt;= from_: sum += current current, next = next, current + next return sum % 10print(fibonacci_partial_sum_naive(0, 1))print(fibonacci_partial_sum_naive(1, 2))print(fibonacci_partial_sum_naive(3, 7))print(fibonacci_partial_sum_naive(5, 7))print(fibonacci_partial_sum_naive(10, 10))print(fibonacci_partial_sum_naive(10, 200)) 1 2 1 6 5 2 Fast Algorithm 123456789101112131415161718192021222324252627def fibonacci_partial_sum_fast(from_, to): if to == 0: return 0 A = [None]* (100) A[0] = 0 A[1] = 1 for i in range(2, 100): A[i] = (A[i-1] + A[i-2])%10 if A[i] == 1 and A[i-1] == 9: period = i+1 break t = to % period f = (from_ - 1) % period if from_ == (0 or 1): return (2*A[t] + A[t-1] - 1) % 10 return (2*(A[t]-A[f]) + A[t-1] - A[f-1]) % 10print(fibonacci_partial_sum_fast(0, 1))print(fibonacci_partial_sum_fast(1, 2))print(fibonacci_partial_sum_fast(3, 7))print(fibonacci_partial_sum_fast(5, 7))print(fibonacci_partial_sum_fast(10, 10))print(fibonacci_partial_sum_fast(10, 200)) 1 2 1 6 5 2 12345678910A = [None]* (100)A[0] = 0A[1] = 1for i in range(2, to-1): A[i] = (A[i-1] + A[i-2]) % 10 if A[i] == 1 and A[i-1] == 9: period = i+1 breakt = (to-1) % periodreturn (2*(A[t]-A[] + A[t-1] - 1) % 10 Last Digit of the Sum of Squares of Fibonacci Numbers 求斐波那契数平方之和的个位数 Task. Compute the last digit of \(F_0^2 + F_1^2 + · · · + F_n^2\). Input Format. Integer n. Constraints. \(0 ≤ n ≤ 10^{18}\). Output Format. The last digit of \(F_0^2 + F_1^2 + · · · + F_n^2\). Sample 1. 1234Input:7Output:3 \(F_0^2 + F_1^2 + · · · + F_7^2 = 0 + 1 + 1 + 4 + 9 + 25 + 64 + 169 = 273\). Naive Algorithm 1234567891011121314151617def fibonacci_sum_squares_naive(n): if n &lt;= 1: return n previous = 0 current = 1 sum = 1 for _ in range(n - 1): previous, current = current, previous + current sum += current * current return sum % 10print(fibonacci_sum_squares_naive(7))print(fibonacci_sum_squares_naive(73))print(fibonacci_sum_squares_naive(211))print(fibonacci_sum_squares_naive(239)) 3 1 1 0 Fast Algorithm 斐波那契数列各项相加的平方和为： \[\sum_{n}a_n^2=a_1^2+a_2^2+\ldots + a_n^2=a_{n}a_{n+1}\] 12345678910111213141516171819202122def fibonacci_sum_squares_fast(n): if n &lt;= 1: return n A = [None]* (100) A[0] = 0 A[1] = 1 for i in range(2, 100): A[i] = (A[i-1] + A[i-2])%10 if A[i] == 1 and A[i-1] == 9: period = i+1 A[i+1] = (A[i-1] + A[i])%10 break t = n % period return (A[t] * A[t+1]) % 10print(fibonacci_sum_squares_fast(0))print(fibonacci_sum_squares_fast(7))print(fibonacci_sum_squares_fast(73))print(fibonacci_sum_squares_fast(211))print(fibonacci_sum_squares_fast(239))print(fibonacci_sum_squares_fast(832564823476)) 0 3 1 1 0 9 break 前面加了一行 A[i+1] = (A[i-1] + A[i])%10 的原因是，当余数为边界值period-1时，还要计算A[t+1] 参考： - Coursera：algorithmic toolbox(week2)]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>Algorithm - Fibonacci</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maximum Pairwise Product Problem]]></title>
    <url>%2F2018%2F09%2F25%2FMaximum_Pairwise%2F</url>
    <content type="text"><![CDATA[问题：两数最大乘积 Find the maximum product of two distinct numbers in a sequence of non-negative integers. Input: A sequence of non-negative integers. Output: The maximum value that can be obtained by multiplying two different elements from the sequence. Constraints: $ 2 ≤ n ≤ 2 · 10^5; 0 ≤ a_1,...,a_n ≤ 2 · 10^5 $. Sample: 1234Input:1 2 3Output:6 这个问题其实就是要找到列表中最大的两个数。 Naive Algorithm 1234567891011def max_pairwise_productNaive(A): n = len(A) max_product = 0 for i in range(n): for j in range(n): if i != j: if max_product &lt; A[i] * A[j]: max_product = A[i] * A[j] return max_productmax_pairwise_productNaive([9,2,4,5,6,7]) 63 代码可以优化为如下形式： 123456789def max_pairwise_productNaive(A): n = len(A) max_product = 0 for i in range(n): for j in range(i+1, n): max_product = max(max_product, A[i]*A[j]) return max_productmax_pairwise_productNaive([9,2,4,5,6,7]) 63 这样的代码在数值很大时会超过运行时间限制。 Fast Algorithm 第一次循环找到最大值，第二次循环找到除此之外的最大值。经过 2n 次比较,运行时间 O(n) 123456789101112131415161718def max_pairwise_productFast(A): n = len(A) j = 0 for i in range(1, n): if A[i] &gt; A[j]: j = i if j == 0: h = 1 else: h = 0 for i in range(1, n): if i!=j and A[i] &gt; A[h]: h = i return A[j]*A[h]max_pairwise_productFast([9,2,4,5,6,7]) 63 压力测试 是一种test和debug的方法。 12345678910111213141516import random def StressTest(N, M): while True: n = random.randint(2, N) A=[random.randint(0,M) for i in range(n)] print(A) result_1 = max_pairwise_productNaive(A) result_2 = max_pairwise_productFast(A) if result_1 == result_2: print("OK") else: print("Wrong answer:",result_1,result_2) returnStressTest(10,100000) 找出列表中最大的两个数 1234567891011121314151617def max_pairwise(A): n = len(A) max1 = A[0] max2 = A[1] if A[0] &lt; A[1]: max1, max2 = max2, max1 for i in range(2,n): if A[i] &gt;= max1: max2 = max1 max1 = A[i] elif(A[i] &lt; max1 and A[i] &gt; max2): max2 = A[i] return max1, max2max_pairwise([20,9,2,4,5,11,6,7,4,9,10]) (20, 11) 更简洁的写法 但运行时间较长，为 O(nlogn) 123456def max_pairwise_productSort(A): n = len(A) A.sort() return A[n-1] * A[n-2]max_pairwise_productSort([9,2,4,5,6,7]) 63 参考 Coursera_algorithmic-toolbox_week1]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>python -   Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[贝尔曼方程(The Bellman Equation)]]></title>
    <url>%2F2018%2F09%2F10%2FThe%20Bellman%20Equation%2F</url>
    <content type="text"><![CDATA[基本原理 Logistic回归是统计学习中的经典分类方法。其实仅在线性回归的基础上，套用了一个逻辑函数。本文主要详述逻辑回归模型的基础。 马尔可夫决策过程 Markov Decision Processes (MDPs) 参考 Reinforcement Learning: an introduction” by Sutton and Barto (freely downloadable)]]></content>
      <categories>
        <category>强化学习</category>
      </categories>
      <tags>
        <tag>强化学习</tag>
        <tag>原理</tag>
        <tag>Reinforcement Learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LogisticRegression的sklearn参数说明]]></title>
    <url>%2F2018%2F08%2F24%2FLogisticRegression%E7%9A%84sklearn%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E%2F</url>
    <content type="text"><![CDATA[class sklearn.linear_model.LogisticRegression(penalty=’l2’, dual=False, tol=0.0001, C=1.0, fit_intercept=True, intercept_scaling=1, class_weight=None, random_state=None, solver=’liblinear’, max_iter=100, multi_class=’ovr’, verbose=0, warm_start=False, n_jobs=1) 在scikit-learn中，主要是基于LogisticRegression模型来解决Logistic回归算法，其中，有两种不同的代价函数(cost function)： L1: \[ \min _ { w,c }\|w\| _ 1+C\sum _ { i=1 }^n log ( exp ( -y_ i(X _ { i }^ \mathrm { T }w+c))+1)\] L2： \[ \min _{ w, c } \frac { 1 }{ 2 }w^ \mathrm { T }w +C \sum _{ i=1 }^nlog(exp(-y _i (X _{i}^ \mathrm { T }w+c))+1)\] 每个式子中前一项是正则化项（Regularizer）（包含w的范数），后一项是损失函数（loss function），参数 C 控制了两者在最终的损失函数中所占的比重。 求解w参数的方法根据L1/L2代价函数的不同，也存在不同的求解拟合参数的方法： Case Solver L2 penalty “saga”, “liblinear” , “lbfgs”, “sag”, “newton-cg” L1 penalty “saga”, “liblinear” Multinomial loss “saga”, “lbfgs”, “sag”, “newton-cg” Very Large dataset (n_samples) “saga”, “sag” penalty：惩罚项，str类型，可选参数为l1和l2，默认为l2。 用于指定惩罚项中使用的规范。加上约束，使得模型更不会过拟合(overfit)，可以获得泛化能力更强的结果 newton-cg、sag和lbfgs求解算法只支持L2规范。 L1规范假设的是模型的参数满足拉普拉斯分布，L2假设的模型参数满足高斯分布， dual：对偶或原始方法，bool类型，默认为False。 对偶方法只用在求解线性多核(liblinear)的L2惩罚项上。 当样本数量&gt;样本特征的时候，dual通常设置为False。 tol：停止求解的标准，float类型，默认为1e-4。 就是求解到多少的时候，停止，认为已经求出最优解。 c：正则化系数λ的倒数，float类型，默认为1.0。必须是正浮点型数。 像SVM一样，越小的数值表示越强的正则化。 fit_intercept：是否存在截距或偏差，bool类型，默认为True。 intercept_scaling： float类型，默认为1。 仅在正则化项为&quot;liblinear&quot;，且fit_intercept设置为True时有用。 class_weight：用于标示分类模型中各种类型的权重. 默认为None，也就是不考虑权重。可以输入一个字典或者'balanced'字符串。 可以{class_label:weight}形式自己输入各个类型的权重。举个例子，比如对于0,1的二元模型，我们可以定义class_weight={0:0.9,1:0.1}，这样类型0的权重为90%，而类型1的权重为10%。 也可以选择balanced，那么类库会根据训练样本量来计算权重。某种类型样本量越多，则权重越低，样本量越少，则权重越高。类权重计算方法如下：n_samples/(n_classes *np.bincount(y))。 n_samples为样本数，n_classes为类别数量，np.bincount(y)会输出每个类的样本数，例如 y=[1,0,0,1,1], 则 np.bincount(y)=[2,3]。 那么class_weight有什么作用呢？ 在分类模型中，我们经常会遇到两类问题： 第一种是误分类的代价很高。比如对合法用户和非法用户进行分类，将非法用户分类为合法用户的代价很高，我们宁愿将合法用户分类为非法用户，这时可以人工再甄别，但是却不愿将非法用户分类为合法用户。这时，我们可以适当提高非法用户的权重。 第二种是样本是高度失衡的。比如我们有合法用户和非法用户的二元样本数据10000条，里面合法用户有9995条，非法用户只有5条，如果我们不考虑权重，则我们可以将所有的测试集都预测为合法用户，这样预测准确率理论上有99.95%，但是却没有任何意义。这时，我们可以选择balanced，让类库自动提高非法用户样本的权重。提高了某种分类的权重，相比不考虑权重，会有更多的样本分类划分到高权重的类别，从而可以解决上面两类问题。 random_state：随机数种子，int类型，可选参数，默认为None。 仅在正则化优化算法为 sag, liblinear 时有用。 solver：优化方法选择。默认为liblinear。 有五个可选参数，即newton-cg, lbfgs, liblinear, sag, saga。 liblinear：使用了开源的liblinear库实现，内部使用了坐标轴下降法来迭代优化损失函数。 lbfgs：L-BFGS算法，拟牛顿法的一种，利用损失函数二阶导数矩阵即海森矩阵来迭代优化损失函数。 newton-cg：也是牛顿法家族的一种，利用损失函数二阶导数矩阵即海森矩阵来迭代优化损失函数。 sag：即随机平均梯度下降(Stochastic Average Gradient descent)，是梯度下降法的变种，和普通梯度下降法的区别是每次迭代仅仅用一部分的样本来计算梯度，适合于样本数据多的时候。 saga：线性收敛的随机优化算法的的变重。 总结： liblinear适用于小数据集，而sag和saga适用于大数据集因为速度更快。 对于多分类问题，只有newton-cg,sag,saga和lbfgs能够处理多项损失，而liblinear受限于一对剩余(OvR)。意思就是用liblinear的时候，如果是多分类问题，得先把一种类别作为一个类别，剩余的所有类别作为另外一个类别。一次类推，遍历所有类别，进行分类。 newton-cg, sag 和 lbfgs 这三种优化算法时都需要损失函数的一阶或者二阶连续导数，因此不能用于没有连续导数的L1正则化，只能用于L2正则化。而 liblinear 和 saga 通吃L1正则化和L2正则化。 同时，sag每次仅仅使用了部分样本进行梯度迭代，所以当样本量少的时候不要选择它，而如果样本量非常大，比如大于10万，sag是第一选择。但是sag不能用于L1正则化，所以当你有大量的样本，又需要L1正则化的话就要自己做取舍了。要么通过对样本采样来降低样本量，要么回到L2正则化。 逻辑回归有二元逻辑回归和多元逻辑回归。对于多元逻辑回归常见的有one-vs-rest(OvR)和many-vs-many(MvM)两种。而MvM一般比OvR分类相对准确一些。而liblinear只支持OvR，不支持MvM，这样如果我们需要相对精确的多元逻辑回归时，就不能选择liblinear了。也意味着如果我们需要相对精确的多元逻辑回归不能使用L1正则化了。 max_iter：算法收敛最大迭代次数，int类型，默认为10。 仅在正则化优化算法为newton-cg, sag 和lbfgs才有用。 multi_class：分类方式选择参数，str类型，可选参数为ovr和multinomial，默认为ovr。 如果是二元逻辑回归，ovr和multinomial并没有任何区别，区别主要在多元逻辑回归上。 ovr即前面提到的one-vs-rest(OvR)。OvR的思想是无论你是多少元逻辑回归，我们都可以看做二元逻辑回归。具体做法是，对于第K类的分类决策，我们把所有第K类的样本作为正例，除了第K类样本以外的所有样本都作为负例，然后在上面做二元逻辑回归，得到第K类的分类模型。其他类的分类模型获得以此类推。 而multinomial即前面提到的many-vs-many(MvM)。MvM相对复杂，这里举MvM的特例one-vs-one(OvO)作讲解。如果模型有T类，我们每次在所有的T类样本里面选择两类样本出来，不妨记为T1类和T2类，把所有的输出为T1和T2的样本放在一起，把T1作为正例，T2作为负例，进行二元逻辑回归，得到模型参数。我们一共需要T(T-1)/2次分类。 可以看出OvR相对简单，但分类效果相对略差（这里指大多数样本分布情况，某些样本分布下OvR可能更好）。而MvM分类相对精确，但是分类速度没有OvR快。 如果选择了ovr，则4种损失函数的优化方法liblinear，newton-cg,lbfgs和sag都可以选择。但是如果选择了multinomial,则只能选择 newton-cg, lbfgs 和 sag 了。 verbose:日志冗长度，int类型。默认为0。就是不输出训练过程。 1的时候偶尔输出结果，大于1，对于每个子模型都输出。 warm_start：热启动参数，bool类型。默认为False。 如果为True，则下一次训练是以追加树的形式进行（重新使用上一次的调用作为初始化）。 n_jobs：并行数。int类型，默认为1。 1的时候，用CPU的一个内核运行程序， 2的时候，用CPU的2个内核运行程序。 为-1的时候，用所有CPU的内核运行程序。 参考 sklearn.linear_model.LogisticRegression-scikit-learn 0.19.2 documentation Logistic回归(Logistic Regression)算法笔记(二)-scikit learn LogisticRegression - 参数说明]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>逻辑回归</tag>
        <tag>sklearn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python3 zip(), lambda, map()]]></title>
    <url>%2F2018%2F08%2F19%2Fpython3%20zip()%2C%20lambda%2C%20map()%2F</url>
    <content type="text"><![CDATA[zip() 函数 函数用于将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的对象，这样做的好处是节约了不少的内存。简单来说，就是将序列合并打包。 我们可以使用list()转换来输出列表。 如果各个迭代器的元素个数不一致，则返回列表长度与最短的对象相同，利用 * 号操作符，可以将元组解压为列表。 语法 : zip(*iterables) 参数说明： iterables -- 一个或多个迭代器,可以内置的迭代器（比如list, string, dict）也可以是用户自定义的迭代器(有__iter__方法的对象). 例1 基本用法 123456789101112numberList = [1, 2, 3]strList = ['one', 'two', 'three']result = zip() # 没有传入可迭代量resultList = list(result) # 转为列表print(resultList)result = zip(numberList, strList) # 传入两个可迭代量resultSet = set(result) # 转为集合print(resultSet) [] {(1, &#39;one&#39;), (3, &#39;three&#39;), (2, &#39;two&#39;)} 12a1, a2 = zip(*zip(a,b)) # 与 zip 相反，*zip 可理解为解压，返回二维矩阵式list(a1),list(a2) ([1, 2, 3], [4, 5, 6]) 例2 传入个数不同的可迭代量 1234567891011numbersList = [1, 2, 3]strList = ['one', 'two']numbersTuple = ('ONE', 'TWO', 'THREE', 'FOUR')result = zip(numbersList, numbersTuple) # 元素个数与最短的列表一致，3个resultSet = set(result)print(resultSet)result = zip(numbersList, strList, numbersTuple)# 2个元素resultSet = set(result)print(resultSet) {(2, &#39;TWO&#39;), (1, &#39;ONE&#39;), (3, &#39;THREE&#39;)} {(2, &#39;two&#39;, &#39;TWO&#39;), (1, &#39;one&#39;, &#39;ONE&#39;)} 例3 用*和zip()来解压列表 1234x = [1,2,3]y = [4,5,6]unzipped_x, unzipped_y = zip(*zip(x,y))print(unzipped_x, unzipped_y) (1, 2, 3) (4, 5, 6) 12345zipper_list = [(1, 'a'), (2, 'b'), (3, 'c')] l_a, l_b = zip(*zipper_list)print(l_a, l_b)print(list(l_a), list(l_b)) (1, 2, 3) (&#39;a&#39;, &#39;b&#39;, &#39;c&#39;) [1, 2, 3] [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;] lambda匿名函数 lambda表达式是一行函数。 它们在其他语言中也被称为匿名函数。如果你不想在程序中对一个函数使用两次，你也许会想用lambda表达式，它们和普通的函数完全一样。 语法 lambda 参数:操作(参数) 例1 基本用法 12add = lambda x, y: x + yprint(add(3, 5)) 8 例2 列表排序 12345a = [(1, 2), (4, 1), (9, 10), (13, -3)]a.sort(key=lambda x: x[1])print(a) # Output: [(13, -3), (4, 1), (1, 2), (9, 10)] [(13, -3), (4, 1), (1, 2), (9, 10)] 例3 在lambda中嵌套逻辑 可以使用if/else三元表达式，或者对等的但需要些技巧的and/or组合。正如我们前面所了解到的，如下语句： 1234if a: belse: c 能够由以下的概括等效的表达式来模拟： b if a else c ((a and b) or c) 因为这样类似的表达式能够放在lambda中，所以它们能够在lambda函数中来实现选择逻辑。 12lower = (lambda x, y: x if x &lt; y else y)lower('bb', 'aa') &#39;aa&#39; 例4 在lambda中执行循环 嵌入map调用或列表解析表达式这样的工具来实现。 123456import sysshowall = lambda x: list(map(sys.stdout.write, x)) # mapshowall(['spam\n', 'toast\n', 'eggs\n'])showall = lambda x: [sys.stdout.write(line) for line in x] # 列表解析showall(['music ', 'song ', 'sing']) spam toast eggs music song sing [None, None, None] map()函数 map() 将一个序列中的每一个迭代元素应用于给定函数， 并返回一个包含所有函数调用结果的一个列表. 语法 : map(fun, iter) 参数 : fun : 给定函数; iter : 可迭代序列(list, tuple 等等) 。 例1 基本用法 123456def addition(n): return n + nnumbers = (1, 2, 3, 4)result = map(addition, numbers)print(list(result)) [2, 4, 6, 8] 例2 在map()中使用lambda函数 123numbers = (1, 2, 3, 4)result = list(map(lambda x: x + x, numbers))print(result) [2, 4, 6, 8] 例3 传入多个迭代序列 12345numbers1 = [1, 2, 3]numbers2 = [4, 5, 6] result = list(map(lambda x, y: x + y, numbers1, numbers2))print(result) [5, 7, 9] 例4 列表中每个字符串分别序列化 1234l = ['sat', 'bat', 'cat', 'mat']test = list(map(list, l))print(test) [[&#39;s&#39;, &#39;a&#39;, &#39;t&#39;], [&#39;b&#39;, &#39;a&#39;, &#39;t&#39;], [&#39;c&#39;, &#39;a&#39;, &#39;t&#39;], [&#39;m&#39;, &#39;a&#39;, &#39;t&#39;]] 参考 Python zip() - programiz Python3 zip() 函数 | 菜鸟教程 lambda表达式 - python进阶 Python3之lambda匿名函数详解-Professor哥-51CTO博客 Python map() function - GeeksforGeeks]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>基础学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo常用命令]]></title>
    <url>%2F2018%2F06%2F21%2Fhexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[hexo init &lt;folder&gt; 创建并初始化一个站点文件夹 hexo new 'article title' 新增一篇文章 hexo clean 用于主题切换等涉及到站点整体布局效果改变时清除hexo原有缓存 文章编辑完后 开启本地服务器，测试静态页面的效果： hexo server 或 hexo s 为文章自动生成静态页面的文件：hexo generate 或 hexo g 将本地页面部署到GitHub Pages上：hexo deploy 或 hexo d (合并替换前两项)生成静态页面的文件并直接部署：hexo generate -d 或hexo deploy -g]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动词て形]]></title>
    <url>%2F2018%2F06%2F20%2F%E5%8A%A8%E8%AF%8D%E3%81%A6%E5%BD%A2%2F</url>
    <content type="text"><![CDATA[一类动词 词尾 替换 基本形 て形 (あうお段)+る って 売る (うる) うって う って 買う (かう) かって つ って 待つ (まつ) まって く いて 書く (かく) かいて ぐ いで 急ぐ (いそぐ) いそいで む んで 読む (よむ) よんで ぶ んで 飛ぶ (とぶ) とんで ぬ んで 死ぬ (しぬ) しんで す して 話す (はなす) はなして 只有“行(い)く”是例外，て形为“行(い)って”。 二类动词 词尾 替换 基本形 て形 (いえ段)+る て 見る (みる) みて 三类动词 词尾 替换 基本形 て形 する して する して くる きて 来る (くる) きて 用法 1. 请求对方做某事 动词て形 + ください - 黒板（こくばん）を 見て ください。 请看黑板。 - 早（はや）く 来て ください。 请快点儿来。 - ちょっと 待って ください。 请等一下。]]></content>
      <categories>
        <category>日语学习</category>
      </categories>
      <tags>
        <tag>动词</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模型选择]]></title>
    <url>%2F2018%2F04%2F16%2F%E6%A8%A1%E5%9E%8B%E9%80%89%E6%8B%A9%2F</url>
    <content type="text"><![CDATA[评估回归模型 这里将都使用波士顿房价的数据集，用10折交叉验证来分离数据，通过均方误差来评估模型性能。 在scikit-learn中用cross_val_score()函数来测试模型，选用负均方误差（neg_mean_squared_error）作为score，得分是负数，这里的neg_mean_squared_error是一种奖励函数，优化的目标是使其最大化。 ## 线性算法 ### 线性回归 12345678910111213141516import pandas as pdfrom sklearn.model_selection import KFoldfrom sklearn.model_selection import cross_val_scorefrom sklearn.linear_model import LinearRegression#导入数据data = pd.read_csv('housing.csv')#划分数据X = data.values[:,0:13]Y = data.values[:,13]seed = 7kfold = KFold(n_splits=10, random_state = seed)model = LinearRegression()scoring = 'neg_mean_squared_error'result = cross_val_score(model, X, Y, cv=kfold, scoring=scoring)print('Linear Regression: %.3f' %result.mean()) 执行结果如下： 1Linear Regression: -34.705 岭回归(Ridge Regression) 岭回归是加入L2正则的最小二乘，Sklearn库提供了函数Ridge(alpha)，alpha是超参数，是正则化项的系数，用来弱化变量参数共线性，限制变量权重（参数）过大，alpha越大，越不容易过拟合。 12345678910111213141516import pandas as pdfrom sklearn.model_selection import KFoldfrom sklearn.model_selection import cross_val_scorefrom sklearn.linear_model import Ridge#导入数据data = pd.read_csv('housing.csv')#划分数据X = data.values[:,0:13]Y = data.values[:,13]seed = 7kfold = KFold(n_splits=10, random_state = seed)model = Ridge()scoring = 'neg_mean_squared_error'result = cross_val_score(model, X, Y, cv=kfold, scoring=scoring)print('Ridge Regression: %.3f' %result.mean()) 执行结果如下： 1Ridge Regression: -34.078 LASSO回归 12345678910111213141516import pandas as pdfrom sklearn.model_selection import KFoldfrom sklearn.model_selection import cross_val_scorefrom sklearn.linear_model import Lasso#导入数据data = pd.read_csv('housing.csv')#划分数据X = data.values[:,0:13]Y = data.values[:,13]seed = 7kfold = KFold(n_splits=10, random_state = seed)model = Lasso()scoring = 'neg_mean_squared_error'result = cross_val_score(model, X, Y, cv=kfold, scoring=scoring)print('Lasso Regression: %.3f' %result.mean()) 执行结果如下： 1Lasso Regression: -34.464 弹性网络(Elastic Net)回归 1234567891011121314151617import pandas as pdfrom sklearn.model_selection import KFoldfrom sklearn.model_selection import cross_val_scorefrom sklearn.linear_model import ElasticNet#导入数据data = pd.read_csv('housing.csv')#划分数据X = data.values[:,0:13]Y = data.values[:,13]seed = 7kfold = KFold(n_splits=10, random_state = seed)scoring = 'neg_mean_squared_error'model = ElasticNet()result = cross_val_score(model, X, Y, cv=kfold, scoring=scoring)print('ElasticNet Regression: %.3f' % result.mean()) 执行结果如下： 1ElasticNet Regression: -31.165 非线性算法 这里介绍在scikit-learn中的三种非线性的机器学习的回归算法。 - K近邻（KNN） - 决策树（CART） - 支持向量机（SVM） 这三个算法在分类算法中同样存在，代码类似于上面的算法，这里就写在一起。 1234567891011121314151617181920212223242526import pandas as pdfrom sklearn.model_selection import KFoldfrom sklearn.model_selection import cross_val_scorefrom sklearn.neighbors import KNeighborsRegressorfrom sklearn.tree import DecisionTreeRegressorfrom sklearn.svm import SVR#导入数据data = pd.read_csv('housing.csv')#划分数据X = data.values[:,0:13]Y = data.values[:,13]seed = 7kfold = KFold(n_splits=10, random_state = seed)scoring = 'neg_mean_squared_error'models = &#123;&#125;models['KNN'] = KNeighborsRegressor()models['DecisionTree'] = DecisionTreeRegressor()models['SVM'] = SVR()results = []for name in models: result = cross_val_score(models[name], X, Y, cv=kfold, scoring=scoring) results.append(result) print('%s: %.3f' % (name, result.mean())) 执行结果如下： 123KNN: -107.287DecisionTree: -44.421SVM: -91.048 评估分类模型 这里会介绍6种分类算法： 线性算法： - 逻辑回归 - 线性判别（LDA） 非线性算法： - K近邻（KNN） - 贝叶斯分类器 - 决策树 - 支持向量机（SVM） 12345678910111213141516171819202122232425262728293031323334353637383940414243import pandas as pdfrom matplotlib import pyplotfrom sklearn.model_selection import KFoldfrom sklearn.model_selection import cross_val_scorefrom sklearn.linear_model import LogisticRegressionfrom sklearn.discriminant_analysis import LinearDiscriminantAnalysisfrom sklearn.neighbors import KNeighborsClassifierfrom sklearn.tree import DecisionTreeClassifierfrom sklearn.svm import SVCfrom sklearn.naive_bayes import GaussianNB#导入数据data = pd.read_csv('pima_data.csv')#划分数据X = data.values[:,0:8]Y = data.values[:,8]seed = 7kfold = KFold(n_splits=10, random_state = seed)models = &#123;&#125;models['LR'] = LogisticRegression()models['LDA'] = LinearDiscriminantAnalysis()models['KNN'] = KNeighborsClassifier()models['CART'] = DecisionTreeClassifier()models['SVM'] = SVC()models['NB'] = GaussianNB()results = []for name in models: result = cross_val_score(models[name], X, Y, cv=kfold) results.append(result) print('%s: %.3f(%.3f)' % (name, result.mean(), result.std()))# 图表显示fig = pyplot.figure()fig.suptitle('Algorithm Comparison')ax = fig.add_subplot(111)pyplot.boxplot(results)ax.set_xticklabels(models.keys())pyplot.show() 执行结果如下： 123456LR: 0.770(0.048)LDA: 0.773(0.052)KNN: 0.727(0.062)CART: 0.690(0.062)SVM: 0.651(0.072)NB: 0.755(0.043) alt text 参考： 1.《机器学习之python》]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>sklearn</tag>
        <tag>机器学习</tag>
        <tag>模型选择</tag>
        <tag>交叉验证法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Conda常用命令]]></title>
    <url>%2F2018%2F02%2F14%2FConda%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[Conda 环境 123456789101112131415161718192021222324252627282930313233343536# 创建一个名为python34的环境，指定Python版本是3.4 conda create --name python34 python=3.4# 激活某个环境activate python34 # for Windowssource activate python34 # for Linux &amp; Macdeactivate python34 # for Windowssource deactivate python34 # for Linux &amp; Mac# 删除一个已有的环境conda remove --name python34 --all# 创建制定python版本的环境conda create --name your_env_name python=2.7conda create --name your_env_name python=3conda create --name your_env_name python=3.5# 创建包含某些包的环境conda create --name your_env_name numpy scipy# 创建指定python版本下包含某些包的环境conda create --name your_env_name python=3.5 numpy scipy# 列举当前所有环境conda info --envsconda env list# 进入某个环境activate your_env_name# 退出当前环境deactivate # 复制某个环境conda create --name new_env_name --clone old_env_name Conda包管理 123456789101112131415161718192021# 安装xxxxconda install xxxx# 查看当前环境下已安装的包conda list# 查看某个指定环境的已安装包conda list -n python34# 查找package信息conda search numpy# 安装package# 如果不用-n指定环境名称，则被安装在当前活跃环境 也可以通过-c指定通过某个channel安装conda install -n python34 numpy # 加一个-c表示从http://anaconda.org下载资源包conda install -c spyder-ide spyder=3.0.0# 更新所有库conda update --all cheat-sheet下载]]></content>
      <categories>
        <category>cheatsheet</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>basic</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Logistic回归]]></title>
    <url>%2F2018%2F01%2F23%2Flogistic%E5%9B%9E%E5%BD%92%2F</url>
    <content type="text"><![CDATA[基本原理 Logistic回归是统计学习中的经典分类方法。其实仅在线性回归的基础上，套用了一个逻辑函数。本文主要详述逻辑回归模型的基础。 假设有输入向量 \(x=(x_1;x_2;...;x_n)\)， 由线性回归模型产生的预测值 \[z=w ^ \mathrm{ T }x+b\tag{1}\] 是实值，需要转换为 0/1 值才能进行分类。因此找一个单调可微函数来替代，将\(z\) 的值映射到 (0,1) 之间，这里采用logistic函数： \[y=\frac{1}{1+e^{-z}}\tag{2}\] 从图中可以看出，对数几率函数是一种“Sigmoid函数”，当 \(z=0\) 时，函数值为0.5。随着 \(z\) 的增大，对应的值将逼近于1；而随着 \(z\) 的减小，输出值将逼近于0。如果横坐标刻度足够大，函数将看起来很像一个阶跃函数，其输出值在 \(z=0\) 附近变化很陡。 将式(1)代入得到 \[y=\frac{1}{1+e^{-(w ^ \mathrm{ T }x+b)}}\tag{3}\] 上式就是logistic回归模型的分类函数。最后， \(y\) 是一个范围在0~1之间的数值。结果大于0.5的数据被归入1类，小于0.5的即被归入0类。所以，Logistic回归也可以被看成是一种概率估计。 (3)式可变化为对数几率形式： \[\ln \frac{y}{1-y}=w ^ \mathrm{ T }x+b\tag{4}\] 由此看出，真实标记 \(y\) 的对数几率是输入 \(x\) 的线性函数。 将 \(y\) 视为类后验概率估计 \(p(y=1|x)\) ，则上式可重写为 \[\ln \frac{p(y=1|x)}{p(y=0|x)}=w ^ \mathrm{ T }x+b\tag{5}\] 显然有 \[p(y=1|x)=\frac{e^{w ^ \mathrm{ T }x+b}}{1+e^{w ^ \mathrm{ T }x+b}}\tag{6}\] \[p(y=0|x)=\frac{1}{1+e^{w ^ \mathrm{ T }x+b}}\tag{7}\] 此时线性函数的值越接近正无穷，概率值就越接近1；线性函数的值越接近负无穷，概率值就越接近0。由此得以分类。 接下来可通过“极大似然法”来估计 \(w\) 和 \(b\) 。 # 用优化方法来估计参数 优化方法有很多，这里主要了解梯度下降，牛顿法和BFGS 参考 浅析Logistic Regression]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>原理</tag>
        <tag>机器学习</tag>
        <tag>Logistic回归</tag>
      </tags>
  </entry>
</search>
