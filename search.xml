<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>XGBoost算法梳理</title>
      <link href="/2019/04/09/XGBoost%E7%AE%97%E6%B3%95%E6%A2%B3%E7%90%86/"/>
      <url>/2019/04/09/XGBoost%E7%AE%97%E6%B3%95%E6%A2%B3%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p><strong>学习任务：</strong> - 算法原理 - 损失函数 - 分裂结点算法 - 正则化 - 对缺失值处理 - 优缺点 - 应用场景 - sklearn参数</p><p>2014年，陈天奇博士提出了XGBoost算法，它可认为是在GBDT算法基础上的进一步优化。首先，XGBoost算法在基学习器损失函数中引入了正则项，控制减少训练过程当中的过拟合；其次，XGBoost算法不仅使用一阶导数计算伪残差，还计算二阶导数可近似快速剪枝的构建新的基学习器；此外，XGBoost算法还做了很多工程上的优化，例如支持并行计算、提高计算效率、处理稀疏训练数据等等。</p><p>总的来说，XGBoost算法源起于Boosting集成学习方法，在演化过程中又融入了Bagging集成学习方法的优势，通过Gradient Boosting框架自定义损失函数提高了算法解决通用问题的能力，同时引入更多可控参数即可针对问题场景进行优化，最后通过工程实现方面细节优化，在保证算法结果稳定的同时还可高效处理大规模数据，可扩展支持不同编程语言。这些因素共同使它成为了工业界的主流机器学习算法之一。</p><p>XGBoost是一种提升树模型，所以它是将许多树模型集成在一起，形成一个很强的分类器。而所用到的树模型则是CART回归树模型。讲解其原理前，先讲解一下CART回归树。</p><h1 id="cart回归树">CART回归树</h1><p>CART回归树是假设树为二叉树，通过不断将特征进行分裂。</p><p>比如当前树结点是基于第 <span class="math inline">\(j\)</span> 个特征值进行分裂的，设该特征值小于 <span class="math inline">\(s\)</span> 的样本划分为左子树，大于s的样本划分为右子树。</p><p><span class="math display">\[R_{1}(j, s)=\left\{x | x^{(j)} \leq s\right\} \text { and } R_{2}(j, s)=\left\{x | x^{(j)}&gt;s\right\}\]</span></p><p>而CART回归树实质上就是在该特征维度对样本空间进行划分，而这种空间划分的优化是一种NP难问题，因此，在决策树模型中是使用启发式方法解决。典型CART回归树产生的目标函数为：</p><p><span class="math display">\[\sum_{x_{i} \in R_{m}}\left(y_{i}-f\left(x_{i}\right)\right)^{2}\]</span></p><p>因此，当我们为了求解最优的切分特征j和最优的切分点s，就转化为求解这么一个目标函数：</p><p><span class="math display">\[\min _{j, s}\left[\min _{c_{1}} \sum_{x_{i} \in R_{1}(j, s)}\left(y_{i}-c_{1}\right)^{2}+\min _{c_{2}} \sum_{x_{i} \in R_{2}(j, s)}\left(y_{i}-c_{2}\right)^{2}\right]\]</span></p><p>所以我们只要遍历所有特征的的所有切分点，就能找到最优的切分特征和切分点。最终得到一棵回归树。 # XGBoost算法思想 该算法思想就是不断地添加树，不断地进行特征分裂来生长一棵树，每次添加一个树，其实是学习一个新函数，去拟合上次预测的残差。当我们训练完成得到k棵树，我们要预测一个样本的分数，其实就是根据这个样本的特征，在每棵树中会落到对应的一个叶子节点，每个叶子节点就对应一个分数，最后只需要将每棵树对应的分数加起来就是该样本的预测值。</p><p><span class="math display">\[\hat{y}=\phi\left(x_{i}\right)=\sum_{k=1}^{K} f_{k}\left(x_{i}\right)\]</span></p><p><span class="math display">\[where\ F=\left\{f(x)=w_{q(x)}\right\}\left(q : R^{m} \rightarrow T, w \in R^{T}\right)\]</span></p><p>注：w_q(x)为叶子节点q的分数，f(x)为其中一棵回归树</p><h1 id="xgboost参数">xgboost参数</h1><p>官方参数介绍看这里： Parameters (official guide)</p><h2 id="general-parameters常规参数">General Parameters（常规参数）</h2><ol style="list-style-type: decimal"><li>booster [default=gbtree]：选择基分类器，gbtree: tree-based models/gblinear: linear models</li><li>silent [default=0]:设置成1则没有运行信息输出，最好是设置为0.</li><li>nthread [default to maximum number of threads available if not set]：线程数</li></ol><h2 id="booster-parameters模型参数">Booster Parameters（模型参数）</h2><p>1.eta [default=0.3]:shrinkage参数，用于更新叶子节点权重时，乘以该系数，避免步长过大。参数值越大，越可能无法收敛。把学习率 eta 设置的小一些，小学习率可以使得后面的学习更加仔细。</p><p>2.min_child_weight [default=1]:这个参数默认是 1，是每个叶子里面 h 的和至少是多少，对正负样本不均衡时的 0-1 分类而言，假设 h 在 0.01 附近，min_child_weight 为 1 意味着叶子节点中最少需要包含 100 个样本。这个参数非常影响结果，控制叶子节点中二阶导的和的最小值，该参数值越小，越容易 overfitting。</p><p>3.max_depth [default=6]: 每颗树的最大深度，树高越深，越容易过拟合。</p><p>4.max_leaf_nodes:最大叶结点数，与max_depth作用有点重合。</p><p>5.gamma [default=0]：后剪枝时，用于控制是否后剪枝的参数。</p><p>6.max_delta_step [default=0]：这个参数在更新步骤中起作用，如果取0表示没有约束，如果取正值则使得更新步骤更加保守。可以防止做太大的更新步子，使更新更加平缓。</p><p>7.subsample [default=1]：样本随机采样，较低的值使得算法更加保守，防止过拟合，但是太小的值也会造成欠拟合。</p><p>8.colsample_bytree [default=1]：列采样，对每棵树的生成用的特征进行列采样.一般设置为： 0.5-1</p><p>9.lambda [default=1]：控制模型复杂度的权重值的L2正则化项参数，参数越大，模型越不容易过拟合。</p><p>10.alpha [default=0]:控制模型复杂程度的权重值的 L1 正则项参数，参数值越大，模型越不容易过拟合。</p><p>11.scale_pos_weight [default=1]：如果取值大于0的话，在类别样本不平衡的情况下有助于快速收敛。</p><h2 id="learning-task-parameters学习任务参数">Learning Task Parameters（学习任务参数）</h2><p>1.objective [default=reg:linear]：定义最小化损失函数类型，常用参数： binary:logistic –logistic regression for binary classification, returns predicted probability (not class) multi:softmax –multiclass classification using the softmax objective, returns predicted class (not probabilities) you also need to set an additional num_class (number of classes) parameter defining the number of unique classes multi:softprob –same as softmax, but returns predicted probability of each data point belonging to each class.</p><p>2.eval_metric [ default according to objective ]： The metric to be used for validation data. The default values are rmse for regression and error for classification. Typical values are: rmse – root mean square error mae – mean absolute error logloss – negative log-likelihood error – Binary classification error rate (0.5 threshold) merror – Multiclass classification error rate mlogloss – Multiclass logloss auc: Area under the curve</p><p>3.seed [default=0]： The random number seed. 随机种子，用于产生可复现的结果 Can be used for generating reproducible results and also for parameter tuning.</p><p>注意: python sklearn style参数名会有所变化 eta –&gt; learning_rate lambda –&gt; reg_lambda alpha –&gt; reg_alpha</p><h1 id="参考">参考</h1><ul><li><a href="https://blog.csdn.net/wzmsltw/article/details/50994481" target="_blank" rel="noopener">XGBoost-Python完全调参指南-参数解释篇</a></li><li><a href="https://www.analyticsvidhya.com/blog/2016/03/complete-guide-parameter-tuning-xgboost-with-codes-python/" target="_blank" rel="noopener">Complete Guide to Parameter Tuning in XGBoost (with codes in Python)</a></li><li><a href="http://blog.csdn.net/zc02051126/article/details/46711047" target="_blank" rel="noopener">XGBoost：参数解释</a></li><li><a href="https://blog.csdn.net/sb19931201/article/details/52557382" target="_blank" rel="noopener">xgboost入门与实战（原理篇）</a></li><li><a href="https://zdkswd.github.io/2019/02/25/XGBoost/" target="_blank" rel="noopener">XGBoost</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sklearn </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用python刷LeetCode链表题(中等级)</title>
      <link href="/2019/04/05/%E7%94%A8python%E5%88%B7LeetCode%E9%93%BE%E8%A1%A8%E9%A2%98(%E4%B8%AD%E7%AD%89%E7%BA%A7)/"/>
      <url>/2019/04/05/%E7%94%A8python%E5%88%B7LeetCode%E9%93%BE%E8%A1%A8%E9%A2%98(%E4%B8%AD%E7%AD%89%E7%BA%A7)/</url>
      
        <content type="html"><![CDATA[<ul><li><ol start="24" style="list-style-type: decimal"><li>两两交换链表中的节点</li></ol></li></ul><a id="more"></a><h1 id="leetcode-24.-两两交换链表中的节点">LeetCode 24. 两两交换链表中的节点</h1><p><a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/" target="_blank" rel="noopener">Swap Nodes in Pairs</a></p><h2 id="题目描述">题目描述</h2><p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</p><p>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p><p>示例: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3.</span><br></pre></td></tr></table></figure></p><h2 id="方法">方法</h2><p>a, b, pre 三个变量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">swapPairs</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        pre, pre.next = self, head</span><br><span class="line">        <span class="keyword">while</span> pre.next <span class="keyword">and</span> pre.next.next: <span class="comment">#考虑奇数和偶数</span></span><br><span class="line">            a = pre.next </span><br><span class="line">            b = a.next <span class="comment"># a,b是要调换的相邻元素</span></span><br><span class="line">            pre.next, b.next, a.next =b, a, b.next <span class="comment"># next连线重置</span></span><br><span class="line">            pre = a</span><br><span class="line">        <span class="keyword">return</span> self.next</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划</title>
      <link href="/2019/04/05/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
      <url>/2019/04/05/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<ol style="list-style-type: decimal"><li>递归 + 记忆化 ——&gt; 递推（动态规划）</li><li>状态的定义：数组 opt[n], dp[n], fib[n]</li><li>状态转移方程：opt[n] = best_of(opt[n-1], opt[n-2], ...) 从前面的n-1个值得到最优的第n个值</li><li>最优子结构</li></ol><p><strong>学习内容：</strong></p><ul><li>LeetCode 509. 斐波那契数列</li><li>LeetCode 70. 爬楼梯</li><li>0-1 背包问题</li><li>最小路径和（详细可看 Minimum Path Sum）</li><li>编程实现莱文斯坦最短编辑距离</li><li>编程实现查找两个字符串的最长公共子序列</li><li>编程实现一个数据序列的最长递增子序列</li></ul><a id="more"></a><h1 id="斐波那契数列求值">斐波那契数列求值</h1><p><a href="https://leetcode-cn.com/problems/fibonacci-number/" target="_blank" rel="noopener">LeetCode 509. Fibonacci Number</a> f(n)=f(n-1)+f(n-2)</p><p>斐波那契数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。</p><p>[0,1,1,2,3,5,8,13,...] 给定<code>n</code>,计算 <code>f(N)</code></p><h2 id="方法动态规划">方法：动态规划</h2><ul><li>递归 + 记忆化 -&gt; 递推</li><li>递推公式：A[i] = A[i-1] + A[i-2]</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(self, N: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> (N &lt;= <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">return</span> N</span><br><span class="line">        A = [<span class="keyword">None</span>]*(N+<span class="number">1</span>)</span><br><span class="line">        A[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        A[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, N+<span class="number">1</span>):</span><br><span class="line">            A[i] = A[i<span class="number">-1</span>] + A[i<span class="number">-2</span>]</span><br><span class="line">        <span class="keyword">return</span> A[N]</span><br></pre></td></tr></table></figure><p>更简洁的写法： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(self, N: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> (N &lt;= <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">return</span> N</span><br><span class="line">        previous = <span class="number">0</span></span><br><span class="line">        current = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(N<span class="number">-1</span>):</span><br><span class="line">            previous, current = current, previous + current         </span><br><span class="line">        <span class="keyword">return</span> current</span><br></pre></td></tr></table></figure></p><h1 id="leetcode-70.-爬楼梯">LeetCode 70. 爬楼梯</h1><p><a href="https://leetcode-cn.com/problems/climbing-stairs/" target="_blank" rel="noopener">Climbing Stairs</a></p><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p><p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p>注意：给定 n 是一个正整数。</p><p><strong>示例 ：</strong> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入： 3</span><br><span class="line">输出： 3</span><br><span class="line">解释： 有三种方法可以爬到楼顶。</span><br><span class="line">1.  1 阶 + 1 阶 + 1 阶</span><br><span class="line">2.  1 阶 + 2 阶</span><br><span class="line">3.  2 阶 + 1 阶</span><br></pre></td></tr></table></figure></p><h2 id="方法动态规划-1">方法：动态规划</h2><p>当有n个台阶时，可供选择的走法可以分两类：1，先跨一阶再跨完剩下n-1阶；2，先跨2阶再跨完剩下n-2阶。所以n阶的不同走法的数目是n-1阶和n-2阶的走法数的和。 这和斐波那契数列的规律相同，可以用这个思路。</p><p>动态规划来记录历史数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        prev, current = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            prev, current = current, prev + current</span><br><span class="line">        <span class="keyword">return</span> current</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>随机森林(Random Forest)算法梳理</title>
      <link href="/2019/04/04/%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/"/>
      <url>/2019/04/04/%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/</url>
      
        <content type="html"><![CDATA[<p><strong>学习任务：</strong></p><ul><li>集成学习<ol style="list-style-type: decimal"><li>什么是集成学习？</li><li>集成学习的种类有哪些？</li><li>集成学习的基本步骤：个体学习器的选择、训练、结合</li></ol></li><li>bagging算法</li><li>随机森林思想</li><li>随机森林的推广</li><li>sklearn参数</li></ul><a id="more"></a><h1 id="集成学习">集成学习</h1><p>集成学习（ensemble learning）是机器学习中的一种思想，而不是指某一具体算法，它通过构建并结合多个学习器来完成学习任务。</p><p>集成学习通过将多个学习器进行结合，常可获得比单一学习器显著优越的泛化性能。</p><h2 id="集成学习的种类">集成学习的种类</h2><p>根据个体学习器的生成方式，目前的集成学习方法大致可分为两大类：</p><ul><li>个体学习器问存在强依赖关系、必须串行生成的序列化方法，代表是 Boosting；</li><li>个体学习器间不存在强依赖关系、可同时生成的并行化方法，代表是 Bagging 和&quot;随机森林&quot; (Random Forest)。</li></ul><p>Boosting 的基本思路是将基分类器层层叠加， 每一层在训练的时候， 对前一层基分类器中分错的样本， 给予更高的权重。 测试时， 根据各层分类器的结果的加权得到最终结果。（降低偏差）</p><p>Bagging 方法更像是一个集体决策的过程， 每个个体都进行单独学习， 学习的内容可以相同， 也可以不同， 也可以部分重叠。 但由于个体之间存在差异性， 最终做出的判断不会完全一致。 在最终做决策时， 每个个体单独作出判断， 再通过投票的方式做出最后的集体决策。 （降低方差）</p><h2 id="集成学习的基本步骤">集成学习的基本步骤</h2><p>集成学习一般可分为以下3个步骤。</p><ol style="list-style-type: decimal"><li>找到误差互相独立的个体学习器。<ul><li>这里可以选取ID3决策树作为基分类器。 事实上， 任何分类模型都可以作为基分类器， 但树形模型由于结构简单且较易产生随机性所以比较常用。</li></ul></li><li>训练个体学习器。<ul><li><p>在集成学习中需有效地生成多样性大的个体学习器。与简单地直接用初始数据训练出个体学习器相比，如何增强多样性呢?一般思路是在学习过程中引入随机性，常见做法主要是对数据样本、 输入属性、输出表示 、 算法参数进行扰动。</p><ul><li>数据样本扰动：通常是基于采样法， 例如在 Bagging中使用自助采样(即有放回的采样)，在 AdaBoost 中使用序列采样.</li><li>输入属性扰动：从初始属性集中抽取出若干个属性子集，再基于每个属性子集训练一个基学习器。比如随机子空间 (random subspace)算法。</li><li>输出表示扰动：可对训练样本的类标记稍作变动，如&quot;翻转法&quot; (Flipping Output)随机改变一些训练样本的标记;也可对输出表示进行转化，如&quot;输出调制法&quot; (Output Smearing) 将分类输出转化为回归输出后构建个体学习器;</li><li>算法参数扰动：基学习算法一般都有参数需进行设置，例如神经网络的隐层神经元数、初始连接权值等。通过随机设置不同的参数，往往可产生差别较大的个体学习器.</li></ul></li></ul></li><li>合并个体学习器的结果。<ul><li>常见的结合策略：平均法(averaging)，投票法(voting)，学习法(比如 stacking)<ul><li>averaging 常用于数值型输出。有简单平均法、加权平均法等。</li><li>voting 是用投票的方式， 将获得最多选票的结果作为最终的结果。常用于分类任务。</li><li>stacking 是用串行的方式， 把前一个基分类器的结果输出到下一个分类器， 将所有基分类器的输出结果相加（或者用更复杂的算法融合） 作为最终的输出。</li></ul></li></ul></li></ol><h1 id="bagging算法">Bagging算法</h1><h2 id="采样训练">采样，训练</h2><p>在Bootstrap(有放回抽样)的基础上可以构造出Bagging（Bootstrap Aggregating）算法。这种方法对训练样本集进行多次Bootstrap抽样，用每次抽样形成的数据集训练一个弱学习器模型，得到多个独立的弱学习器（对于分类问题，称为弱分类器），最后用它们的组合进行预测。</p><h2 id="结合策略">结合策略</h2><p>在对预测输出进行结合时， Bagging 通常对分类任务使用简单投票法，对回归任务使用简单平均法.</p><p>若分类预测时出现两个类收到同样票数的情形，则最简单的做法是随机选择一个，也可进一步考察学习器投票的置信度来确定最终胜者.</p><h2 id="算法特点">算法特点</h2><ul><li>假定基学习器的计算复杂度为 O(m) ， 则 Bagging 的复杂度大致为<span class="math inline">\(T(O(m) + O (s))\)</span> ，考虑到采样与投票/平均过程的复杂度 <span class="math inline">\(O(s)\)</span> 很小，而<span class="math inline">\(T\)</span>通常是一个不太大的常数，因此，训练一个 Bagging 集成与直接使用基学习算法训练一个学习器的复杂度同阶，这说明 Bagging 是一个很高效的集成学习算法.</li><li>因为Boostrap采样过程，每个基学习器只使用了初始训练集中约 63.2% 的样本，那么剩下约 36.8% 的样本可用作验证集来对泛化性能进行&quot;包外估计&quot; (out-oιbag estimate)</li><li>从偏差方差分解的角度看， Bagging 主要关注降低方差，因此它在不剪枝 决策树、神经网络等易受样本扰动的学习器上效用更为明显.</li></ul><h1 id="随机森林思想">随机森林思想</h1><p>随机森林(Random Forest，简称RF)是 Bagging 的一个扩展变体. RF 在以决策树为基学习器构建 Bagging 集成的基础上，进一步在决策树的训练过程中引入了随机属性选择. (数据样本扰动 + 输入属性扰动)</p><ul><li>传统决策树在选择划分属性时是在当前结点的属性集合(假定有 d 个属性)中选择一个最优属性;</li><li>而在RF 中，对基决策树的每个结点，先从该结点的属性集合中随机选择一个包含 k 个属性的子集，然后再从这个子集中选择一个最优属性用于划分.</li></ul><p>这里的参数 k 控制了随机性的引入程度：</p><ul><li>若令 <span class="math inline">\(k = d\)</span> ， 则基决策树的构建与传统决策树相同;</li><li>若令 <span class="math inline">\(k = 1\)</span> ， 则是随机选择一个属性用于划分 ;</li><li>一般情况下，推荐值 <span class="math inline">\(k = log_{2}d\)</span></li></ul><h2 id="特点">特点</h2><ul><li>随机森林简单、容易实现、计算开销小，令人惊奇的是，它在很多现实任务中展现出强大的性能。</li><li>随机森林的训练效率常优于 Bagging。<ul><li>因为在个体决策树的构建过程中，Bagging使用的是 &quot;确定型&quot; 决策树，在选择划分属性时要对结点的所有属性进行考察，而随机森林使用的&quot;随机型&quot;决策树则只需考察一个属性子集。</li></ul></li><li>由于可以随机选择决策树节点划分特征，这样在样本特征维度很高的时候，仍然能高效的训练模型。</li><li>在训练后，可以给出各个特征对于输出的重要性。</li></ul><p>缺点</p><ul><li>在某些噪音比较大的样本集上，RF模型容易陷入过拟合。</li></ul><h1 id="随机森林的推广">随机森林的推广</h1><p>基于RF，有很多变种算法，应用也很广泛，不光可以用于分类回归，还可以用于特征转换，异常点检测等。</p><h1 id="sklearn参数">sklearn参数</h1><p>RF的分类器是RandomForestClassifier，回归器是RandomForestRegressor。RF需要调的参数包括两部分，第一部分是Bagging框架的参数，第二部分是CART决策树的参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">sklearn</span>.<span class="title">ensemble</span>.<span class="title">RandomForestClassifier</span><span class="params">(</span></span></span><br><span class="line"><span class="class"><span class="params">        n_estimators=’warn’, criterion=’gini’, </span></span></span><br><span class="line"><span class="class"><span class="params">        max_depth=None, min_samples_split=<span class="number">2</span>, </span></span></span><br><span class="line"><span class="class"><span class="params">        min_samples_leaf=<span class="number">1</span>, </span></span></span><br><span class="line"><span class="class"><span class="params">        min_weight_fraction_leaf=<span class="number">0.0</span>, </span></span></span><br><span class="line"><span class="class"><span class="params">        max_features=’auto’, max_leaf_nodes=None, </span></span></span><br><span class="line"><span class="class"><span class="params">        min_impurity_decrease=<span class="number">0.0</span>, </span></span></span><br><span class="line"><span class="class"><span class="params">        min_impurity_split=None, bootstrap=True, </span></span></span><br><span class="line"><span class="class"><span class="params">        oob_score=False, n_jobs=None, </span></span></span><br><span class="line"><span class="class"><span class="params">        random_state=None, verbose=<span class="number">0</span>, </span></span></span><br><span class="line"><span class="class"><span class="params">        warm_start=False, class_weight=None)</span></span></span><br></pre></td></tr></table></figure><h2 id="bagging框架的参数解释">Bagging框架的参数解释</h2><ul><li><p><strong>n_estimators</strong>：弱学习器的最大迭代次数，或者说最大的弱学习器的个数。 一般来说n_estimators太小，容易过拟合，太大又容易欠拟合，一般选择一个适中的数值。默认是100.实际调参的过程中，我们常常将n_estimators和下面介绍的参数learning_rate一起考虑。</p></li><li><p><strong>oob_score</strong>：即是否采用袋外样本来评估模型的好坏。默认设置False。个人推荐设置为True，因为袋外分数反应了一个模型拟合后的泛化能力。</p></li><li><strong>criterion</strong>：即CART决策树做划分时对特征的评价标准。分类模型和回归模型的损失函数不一样。<ul><li>分类RF对应的CART分类树默认是基尼系数，另一个可选择的标准是信息增益。</li><li>回归RF对应的CART回归树默认是均方差mse，另一个可以选择的标准时绝对值mae。</li><li>一般来说选择默认的标准就已经很好了。</li></ul></li></ul><p>RF重要的框架参数比较少，主要关注的是n_estimators，即RF最大的决策树个数。</p><h2 id="rf决策树参数">RF决策树参数</h2><p>RF的决策树参数，它要调参的参数基本和GBDT相同，如下:</p><ul><li><strong>max_features</strong>:RF划分时考虑的最大特征，可以使用很多种类型的值.<ul><li>默认是&quot;auto&quot;，意味着划分时最多考虑 <span class="math inline">\(\sqrt{N}\)</span> 个特征；</li><li>如果是&quot;log2&quot;意味着划分时最多考虑 <span class="math inline">\(log_{2}N\)</span> 个特征；</li><li>如果是&quot;sqrt&quot;或者&quot;auto&quot;意味着划分时最多可考虑 <span class="math inline">\(\sqrt{N}\)</span> 个特征。</li><li>如果是整数，代表考虑的特征绝对数。</li><li>如果是浮点数，代表考虑特征百分比，即考虑（百分比xN）取整后的特征数。</li><li>其中N为样本总特征数。</li><li>一般我们默认的&quot;auto&quot;就可以了，如果特征数非常多，我们可以灵活使用刚才描述的其他取值来控制划分时考虑的最大特征数，以控制决策树的生成时间。</li></ul></li><li><strong>max_depth</strong>: 决策树最大深度。默认可以不输入，如果不输入的话，决策树在建立子树的时候不会限制子树的深度。<ul><li>一般来说，数据少或者特征少的时候可以不管这个值。</li><li>如果模型样本量多，特征也多的情况下，推荐限制这个最大深度，具体的取值取决于数据的分布。常用的可以取值10-100之间。</li></ul></li><li><strong>min_samples_split</strong>: 内部节点再划分所需最小样本数。这个值限制了子树继续划分的条件，如果某节点的样本数少于min_samples_split，则不会继续再尝试选择最优特征来进行划分。<ul><li>默认是2.如果样本量不大，不需要管这个值。如果样本量数量级非常大，则推荐增大这个值。</li></ul></li><li><strong>min_samples_leaf</strong>: 叶子节点最少样本数。这个值限制了叶子节点最少的样本数，如果某叶子节点数目小于样本数，则会和兄弟节点一起被剪枝。<ul><li>默认是1,可以输入最少的样本数的整数，或者最少样本数占样本总数的百分比。如果样本量不大，不需要管这个值。如果样本量数量级非常大，则推荐增大这个值。</li></ul></li><li><strong>min_weight_fraction_leaf</strong>：叶子节点最小的样本权重和。这个值限制了叶子节点所有样本权重和的最小值，如果小于这个值，则会和兄弟节点一起被剪枝。<ul><li>默认是0，就是不考虑权重问题。一般来说，如果我们有较多样本有缺失值，或者分类树样本的分布类别偏差很大，就会引入样本权重，这时我们就要注意这个值了。</li></ul></li><li><strong>max_leaf_nodes</strong>: 最大叶子节点数。通过限制最大叶子节点数，可以防止过拟合，默认是&quot;None”，即不限制最大的叶子节点数。如果加了限制，算法会建立在最大叶子节点数内最优的决策树。如果特征不多，可以不考虑这个值，但是如果特征很多的话，可以加以限制，具体的值可以通过交叉验证得到。</li><li><strong>min_impurity_split</strong>: 节点划分最小不纯度。这个值限制了决策树的增长，如果某节点的不纯度(基于基尼系数，均方差)小于这个阈值，则该节点不再生成子节点。即为叶子节点 。一般不推荐改动默认值1e-7。</li></ul><p>上面决策树参数中最重要的包括最大特征数 <strong>max_features</strong>， 最大深度 <strong>max_depth</strong>， 内部节点再划分所需最小样本数<strong>min_samples_split</strong> 和叶子节点最少样本数 <strong>min_samples_leaf</strong>。</p><h1 id="参考">参考</h1><ul><li>《机器学习》周志华</li><li>《百面机器学习》诸葛越</li><li><a href="https://mp.weixin.qq.com/s?src=11&amp;timestamp=1554345104&amp;ver=1525&amp;signature=nv3IJ0jWadpcSy4ZJz6CRoEChzTMau2o9zf3Nl736gN4pWbufSm9XvgY7nh2EykPaJ37oX2iroXw9Ai0sLIQNxmi5r3mtXNDSjypQ*poIZkDqhyy3CrCMD-IB*0XU*8N&amp;new=1" target="_blank" rel="noopener">随机森林概述 by SIGAI</a></li><li><a href="https://zhuanlan.zhihu.com/p/52704839" target="_blank" rel="noopener">随机森林算法介绍(理论)</a></li><li><a href="https://www.cnblogs.com/pinard/p/6160412.html" target="_blank" rel="noopener">scikit-learn随机森林调参小结</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sklearn </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>梯度提升树(GBDT)算法梳理</title>
      <link href="/2019/04/04/%E6%A2%AF%E5%BA%A6%E6%8F%90%E5%8D%87%E5%86%B3%E7%AD%96%E6%A0%91(GBDT)%E7%AE%97%E6%B3%95%E6%A2%B3%E7%90%86/"/>
      <url>/2019/04/04/%E6%A2%AF%E5%BA%A6%E6%8F%90%E5%8D%87%E5%86%B3%E7%AD%96%E6%A0%91(GBDT)%E7%AE%97%E6%B3%95%E6%A2%B3%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>梯度提升决策树（Gradient Boosting Decision Tree， GBDT）是Boosting算法中非常流行的模型，也是近来在机器学习竞赛、商业应用中表现都非常优秀的模型。GBDT非常好地体现了“从错误中学习”的理念，基于决策树预测的残差进行迭代的学习。</p><p><strong>学习任务：</strong></p><ul><li>前向分步算法</li><li>负梯度拟合</li><li>损失函数</li><li>回归</li><li>二分类，多分类</li><li>正则化</li><li>优缺点</li><li>sklearn参数</li></ul><a id="more"></a><p>GDBT 基本思想是根据当前模型损失函数的负梯度信息来训练新加入的弱分类器， 然后将训练好的弱分类器以累加的形式结合到现有模型中。</p><p>采用决策树作为弱分类器的Gradient Boosting算法被称为GBDT，有时又被称为MART（Multiple Additive Regression Tree）。GBDT中使用的决策树通常为CART。</p><p>GBDT中每一棵树学的是之前所有树结论和的残差， 这个残差就是一个加预测值后能得真实值的累加量。</p><p>举例子来说，假设对每个用户的年龄做出预测，例如用户A的真实年龄是25岁， 但第一棵决策树的预测年龄是22岁， 差了3岁， 即残差为3。 那么在第二棵树里我们把A的年龄设为3岁去学习， 如果第二棵树能把A分到3岁的叶子节点， 那两棵树的结果相加就可以得到A的真实年龄； 如果第二棵树的结论是5岁， 则A仍然存在−2岁的残差， 第三棵树里A的年龄就变成−2岁，继续学。 这里使用残差继续学习， 就是GBDT中Gradient Boosted所表达的意思。</p><h1 id="前向分步算法">前向分步算法</h1><p>在GBDT的迭代中，假设我们前一轮迭代得到的强学习器（即当前模型）是 <span class="math inline">\(f_{m-1}(x)\)</span>, 损失函数是 <span class="math inline">\(L(y, f_{m-1}(x))\)</span> , 我们本轮迭代的目标是找到一个CART回归树模型的弱学习器 <span class="math inline">\(h(x:\alpha_{m})\)</span>，让本轮的损失函数 <span class="math inline">\(L(y, f_{m}(x) =L(y, f_{m-1}(x)+ h(x:\alpha))\)</span> 最小。也就是说，从前向后，每一步只学习一个基函数及其系数，逐步逼近优化损失函数。</p><p>输入：训练数据集 <span class="math inline">\(T=\{(x_,y_1),(x_2,y_2), ...(x_N,y_N)\}\)</span>; 损失函数是 <span class="math inline">\(L(y, f(x))\)</span>; 基函数集 <span class="math inline">\({h(x:\alpha)}\)</span>;</p><p>输出：加法模型<span class="math inline">\(f(x)\)</span>.</p><ol style="list-style-type: decimal"><li>初始化<span class="math inline">\(f_{0}(x)=0\)</span></li><li><p>For <span class="math inline">\(m=1\)</span> to <span class="math inline">\(M\)</span> do：</p></li><li><p>通过极小化损失函数(如下公式1)得到下一颗决策树的参数:<span class="math inline">\(\beta_{m},\alpha_{m}\)</span>.</p></li></ol><p><span class="math display">\[(\beta_{m},\alpha_{m}) = arg\min \limits_{\beta,\alpha}\sum\limits_{i=1}^{N} L(y_i,f_{m-1}(x_i) + \beta h(x:\alpha))\tag{1}\]</span></p><ol start="4" style="list-style-type: decimal"><li>更新</li></ol><p><span class="math display">\[f_{m}(x) = f_{tm-1}(x) + \beta_{m} h(x:\alpha_{m}))\tag{2}\]</span> 5. 前三步循环结束即可得到加法模型：</p><p><span class="math display">\[f(x) = f_{M}(x) = \sum\limits_{m=1}^{M} \beta_{m} h(x:\alpha_{m}))\tag{3}\]</span></p><h1 id="gbdt-的负梯度拟合">GBDT 的负梯度拟合</h1><p>若上述算法采用平方误差损失函数,</p><p><span class="math display">\[L(y, f(x)) = (y-f(x))^2\tag{4}\]</span></p><p>其损失变为</p><p><span class="math display">\[L(y,f_{m-1}(x) + \beta h(x:\alpha)\\=[y-f_{m-1}(x) - \beta h(x:\alpha)]^2\\=[r - \beta h(x:\alpha)]^2\]</span></p><p>这里，</p><p><span class="math display">\[r = y - f_{m-1}(x)\tag{5}\]</span></p><p>是当前模型拟合数据的残差（residual ). 所以， 对冋归问题的提升树算法来说，只需简单地拟合当前模型的残差.</p><p>提升树利用加法模型与前向分歩算法实现学习的优化过程. 当损失函数是平方损失和指数损失函数时， 每一步优化是很简单的. 但对一般损失函数而言， 往往每一步优化并不那么容易.</p><p>损失函数各种各样，怎么找到一种通用的拟合方法呢？</p><p>针对这一问题， Freidman 提出了梯度提升（gradient boosting) 算法. 这是利用最速下降法的近似方法， 其关键是利用损失函数的负梯度在当前模型的值来拟合本轮损失（即残差）的近似值。第m轮的第i个样本的损失函数的负梯度表示为下式(6):</p><p><span class="math display">\[r_{mi} = -\bigg[\frac{\partial L(y_i, f(x_i)))}{\partial f(x_i)}\bigg]_{f(x) = f_{m-1}\;\; (x)}\tag{6}\]</span></p><h1 id="gbdt-的算法思想">GBDT 的算法思想</h1><p>在每一轮迭代中，</p><ol style="list-style-type: decimal"><li>计算出当前模型在所有样本上的负梯度（可以作为残差的近似值）</li><li>以该值为目标训练一个新的弱分类器进行拟合</li><li>计算出该弱分类器的权重</li><li>最终实现对模型的更新</li></ol><p>Gradient Boosting算法的伪代码如下：</p><p>输入：训练数据集 <span class="math inline">\(T=\{(x_,y_1),(x_2,y_2), ...(x_N,y_N)\}\)</span>; 损失函数是 <span class="math inline">\(L(y, f(x))\)</span>; 基函数集 <span class="math inline">\({h(x:\alpha)}\)</span>;</p><p>输出：加法模型<span class="math inline">\(f(x)\)</span>.</p><ol style="list-style-type: decimal"><li>初始化<span class="math inline">\(f_{0}(x)= arg\min \limits_{\rho}\sum\limits_{i=1}^{N} L(y_i,\rho))\)</span></li><li>For <span class="math inline">\(m=1\)</span> to <span class="math inline">\(M\)</span> do：</li></ol><ul><li><ol style="list-style-type: decimal"><li>计算负梯度</li></ol></li></ul><p><span class="math display">\[r_{mi} = -\bigg[\frac{\partial L(y_i, f(x_i)))}{\partial f(x_i)}\bigg]_{f(x) = f_{m-1}\;\; (x)}\tag{6}\]</span></p><ul><li><ol start="2" style="list-style-type: decimal"><li>通过极小化损失函数得到新的学习器的参数:下降的步长<span class="math inline">\(\beta_{m}\)</span>和方向 <span class="math inline">\(\alpha_{m}\)</span>.</li></ol></li></ul><p><span class="math display">\[\alpha_{m} = arg\min \limits_{\beta,\alpha}\sum\limits_{i=1}^{N} (r_{mi} - \beta h(x_i:\alpha))^2\tag{7}\]</span> - (3) 计算新学习器的权重</p><p><span class="math display">\[\rho_m = arg\min \limits_{\rho}\sum\limits_{i=1}^{N} L(y_i,f_{m-1}(x_i) + \rho h(x_i:\alpha_{m}))\tag{8}\]</span></p><ul><li><ol start="4" style="list-style-type: decimal"><li>更新</li></ol></li></ul><p><span class="math display">\[f_{m}(x) = f_{m-1}(x) + \rho_{m} h(x:\alpha_{m}))\tag{9}\]</span> 5. 循环结束即可得到加法模型：</p><p><span class="math display">\[f(x) = f_{M}(x) = \sum\limits_{m=1}^{M} \rho_{m} h(x:\alpha_{m}))\tag{10}\]</span></p><p>由于GBDT是利用残差训练的， 在预测的过程中， 我们需要把所有树的预测值加起来， 得到最终的预测结果。</p><h1 id="gbdt回归算法">GBDT回归算法</h1><p>输入是训练集样本<span class="math inline">\(T=\{(x_,y_1),(x_2,y_2), ...(x_m,y_m)\}\)</span>， 最大迭代次数T, 损失函数L。</p><p>输出是强学习器f(x)</p><ol style="list-style-type: decimal"><li>初始化弱学习器</li></ol><p><span class="math display">\[f_0(x) = \underbrace{arg\; min}_{c}\sum\limits_{i=1}^{m}L(y_i, c)\]</span></p><ol start="2" style="list-style-type: decimal"><li>对迭代轮数t=1,2,...T有：</li></ol><p>a)对样本i=1,2，...m，计算负梯度</p><p><span class="math display">\[r_{ti} = -\bigg[\frac{\partial L(y_i, f(x_i)))}{\partial f(x_i)}\bigg]_{f(x) = f_{t-1}\;\; (x)}\]</span></p><p>b)利用<span class="math inline">\((x_i,r_{ti})\;\; (i=1,2,..m)\)</span>, 拟合一颗CART回归树,得到第t颗回归树，其对应的叶子节点区域为<span class="math inline">\(R_{tj}, j =1,2,..., J\)</span>。其中J为回归树t的叶子节点的个数。</p><ol start="3" style="list-style-type: lower-alpha"><li>对叶子区域j =1,2,..J,计算最佳拟合值</li></ol><p><span class="math display">\[c_{tj} = \underbrace{arg\; min}_{c}\sum\limits_{x_i \in R_{tj}} L(y_i,f_{t-1}(x_i) +c)\]</span></p><ol start="4" style="list-style-type: lower-alpha"><li>更新强学习器</li></ol><p><span class="math display">\[f_{t}(x) = f_{t-1}(x) + \sum\limits_{j=1}^{J}c_{tj}I(x \in R_{tj})\]</span></p><ol start="3" style="list-style-type: decimal"><li>得到强学习器f(x)的表达式</li></ol><p><span class="math display">\[f(x) = f_T(x) =f_0(x) + \sum\limits_{t=1}^{T}\sum\limits_{j=1}^{J}c_{tj}I(x \in R_{tj})\]</span></p><h1 id="gbdt分类算法">GBDT分类算法</h1><p>GBDT的分类算法从思想上和GBDT的回归算法没有区别，但是由于样本输出不是连续的值，而是离散的类别，导致我们无法直接从输出类别去拟合类别输出的误差。</p><p>为了解决这个问题，主要有两个方法，</p><ol style="list-style-type: decimal"><li>用指数损失函数，此时GBDT退化为Adaboost算法。</li><li>是用类似于逻辑回归的对数似然损失函数的方法。也就是说，我们用的是类别的预测概率值和真实概率值的差来拟合损失。</li></ol><p>本文仅讨论用对数似然损失函数的GBDT分类。对此我们又有二元分类和多元分类的区别。</p><h2 id="二元gbdt分类算法">二元GBDT分类算法</h2><p>对于二元GBDT，如果用类似于逻辑回归的对数似然损失函数，则损失函数为：</p><p><span class="math display">\[L(y, f(x)) = log(1+ exp(-yf(x)))\]</span></p><p>　　　　其中<span class="math inline">\(y∈\{−1,+1\}\)</span>.则此时的负梯度误差为:</p><p><span class="math display">\[r_{mi} = -\bigg[\frac{\partial L(y, f(x_i)))}{\partial f(x_i)}\bigg]_{f(x) = f_{m-1}\;\; (x)} = \frac{y_i}{1+exp(y_if(x_i))}\]</span> 　　　　 对于生成的决策树，我们各个叶子节点的最佳负梯度拟合值为:</p><p><span class="math display">\[c_{mj} = \underbrace{arg\; min}_{c}\sum\limits_{x_i \in R_{mj}} log(1+exp(-y_i(f_{m-1}(x_i) +c)))\]</span> 　　　　由于上式比较难优化，我们一般使用近似值代替</p><p><span class="math display">\[c_{mj} = \frac{\sum\limits_{x_i \in R_{mj}}r_{mi}} {\sum\limits_{x_i \in R_{mj}}|r_{mi}|(1-|r_{mi}|)}\]</span></p><p>　　　　除了负梯度计算和叶子节点的最佳负梯度拟合的线性搜索，二元GBDT分类和GBDT回归算法过程相同。</p><h2 id="多元gbdt分类算法">多元GBDT分类算法</h2><p>多元GBDT要比二元GBDT复杂一些，对应的是多元逻辑回归和二元逻辑回归的复杂度差别。</p><p>假设类别数为K，则此时我们的对数似然损失函数为：</p><p><span class="math display">\[L(y, f(x)) = -  \sum\limits_{k=1}^{K}y_klog\;p_k(x)\]</span></p><p>其中如果样本输出类别为k，则<span class="math inline">\(y_k=1\)</span>。第k类的概率<span class="math inline">\(p_k(x)\)</span>的表达式为：</p><p><span class="math display">\[p_k(x) = \frac{exp(f_k(x))} {\sum\limits_{l=1}^{K} exp(f_l(x))}\]</span></p><p>集合上两式，我们可以计算出第t轮的第i个样本对应类别l的负梯度误差为</p><p><span class="math display">\[r_{mil} = -\bigg[\frac{\partial L(y_i, f(x_i)))}{\partial f(x_i)}\bigg]_{f_k(x) = f_{l, m-1}\;\; (x)} = y_{il} - p_{l, m-1}(x_i)\]</span></p><p>观察上式可以看出，其实这里的误差就是样本i对应类别l的真实概率和m−1轮预测概率的差值。</p><p>对于生成的决策树，我们各个叶子节点的最佳负梯度拟合值为</p><p><span class="math display">\[c_{mjl} = \underbrace{arg\; min}_{c_{jl}}\sum\limits_{i=0}^{m}\sum\limits_{k=1}^{K} L(y_k, f_{m-1, l}(x) + \sum\limits_{j=0}^{J}c_{jl} I(x_i \in R_{mj}))\]</span> 　　　　 由于上式比较难优化，我们一般使用近似值代替</p><p><span class="math display">\[c_{tjl} =  \frac{K-1}{K} \; \frac{\sum\limits_{x_i \in R_{tjl}}r_{til}}{\sum\limits_{x_i \in R_{til}}|r_{til}|(1-|r_{til}|)}\]</span></p><p>除了负梯度计算和叶子节点的最佳负梯度拟合的线性搜索，多元GBDT分类和二元GBDT分类以及GBDT回归算法过程相同。</p><h1 id="gbdt常用损失函数">GBDT常用损失函数</h1><h2 id="分类算法">分类算法</h2><p>损失函数一般有对数损失函数和指数损失函数两种:</p><ol style="list-style-type: decimal"><li>指数损失函数</li></ol><p><span class="math display">\[L(y, f(x)) = exp(-yf(x))\]</span> 　　　　 其负梯度计算和叶子节点的最佳负梯度拟合和Adaboost原理相同。</p><ol start="2" style="list-style-type: decimal"><li>对数损失函数，分为二元分类和多元分类两种，参见上文的GBDT分类算法。　　</li></ol><h2 id="回归算法">回归算法</h2><p>常用损失函数有如下4种:</p><ol style="list-style-type: decimal"><li>均方差，最常见的回归损失函数</li></ol><p><span class="math display">\[L(y, f(x)) =(y-f(x))^2\]</span> 2. 绝对损失，这个损失函数也很常见</p><p><span class="math display">\[L(y, f(x)) =|y-f(x)|\]</span> 　　　　　　 对应负梯度误差为：</p><p><span class="math display">\[sign(y_i-f(x_i))\]</span></p><ol start="3" style="list-style-type: decimal"><li>Huber损失，它是均方差和绝对损失的折衷产物，对于远离中心的异常点，采用绝对损失，而中心附近的点采用均方差。这个界限一般用分位数点度量。损失函数如下：</li></ol><p><span class="math display">\[L(y, f(x))= \begin{cases} \frac{1}{2}(y-f(x))^2&amp; {|y-f(x)| \leq \delta}\\ \delta(|y-f(x)| - \frac{\delta}{2})&amp; {|y-f(x)| &gt; \delta} \end{cases}\]</span> 　　　　对应的负梯度误差为：</p><p><span class="math display">\[r(y_i, f(x_i))= \begin{cases} y_i-f(x_i)&amp; {|y_i-f(x_i)| \leq \delta}\\ \delta sign(y_i-f(x_i))&amp; {|y_i-f(x_i)| &gt; \delta} \end{cases}\]</span></p><ol start="4" style="list-style-type: decimal"><li>分位数损失。它对应的是分位数回归的损失函数，表达式为</li></ol><p><span class="math display">\[L(y, f(x)) =\sum\limits_{y \geq f(x)}\theta|y - f(x)| + \sum\limits_{y &lt; f(x)}(1-\theta)|y - f(x)|\]</span></p><p>其中θ为分位数，需要我们在回归前指定。对应的负梯度误差为：</p><p><span class="math display">\[r(y_i, f(x_i))= \begin{cases} \theta&amp; { y_i \geq f(x_i)}\\ \theta - 1 &amp; {y_i &lt; f(x_i) } \end{cases}\]</span></p><p>对于Huber损失和分位数损失，主要用于健壮回归，也就是减少异常点对损失函数的影响。</p><h1 id="gbdt的正则化">GBDT的正则化</h1><p>和Adaboost一样，我们也需要对GBDT进行正则化，防止过拟合。GBDT的正则化主要有三种方式。</p><h2 id="步长learning-rate">步长(learning rate)</h2><p>第一种是和Adaboost类似的正则化项，即步长(learning rate)。定义为ν,对于前面的弱学习器的迭代</p><p><span class="math display">\[f_{k}(x) = f_{k-1}(x) + h_k(x)\]</span></p><p>如果我们加上了正则化项，则有</p><p><span class="math display">\[f_{k}(x) = f_{k-1}(x) + \nu h_k(x)\]</span></p><p>ν的取值范围为0&lt;ν≤1。对于同样的训练集学习效果，较小的ν意味着我们需要更多的弱学习器的迭代次数。通常我们用步长和迭代最大次数一起来决定算法的拟合效果。</p><h2 id="子采样">子采样</h2><p>第二种正则化的方式是通过子采样比例（subsample）。取值为(0,1]。注意这里的子采样和随机森林不一样，随机森林使用的是放回抽样，而这里是不放回抽样。如果取值为1，则全部样本都使用，等于没有使用子采样。如果取值小于1，则只有一部分样本会去做GBDT的决策树拟合。选择小于1的比例可以减少方差，即防止过拟合，但是会增加样本拟合的偏差，因此取值不能太低。推荐在[0.5, 0.8]之间。</p><p>使用了子采样的GBDT有时也称作随机梯度提升树(Stochastic Gradient Boosting Tree, SGBT)。由于使用了子采样，程序可以通过采样分发到不同的任务去做boosting的迭代过程，最后形成新树，从而减少弱学习器难以并行学习的弱点。</p><h2 id="正则化剪枝">正则化剪枝</h2><p>针对于弱学习器（即CART回归树）进行正则化剪枝。就是决策树的正则化方法</p><h1 id="gbdt的优点和局限性">GBDT的优点和局限性</h1><p>优点</p><ol style="list-style-type: decimal"><li>预测阶段的计算速度快， 树与树之间可并行化计算。</li><li>在分布稠密的数据集上， 泛化能力和表达能力都很好， 这使得GBDT在Kaggle的众多竞赛中， 经常名列榜首。</li><li>采用决策树作为弱分类器使得GBDT模型具有较好的解释性和鲁棒性，能够自动发现特征间的高阶关系， 并且也不需要对数据进行特殊的预处理如归一化等。</li></ol><p>局限性</p><ol style="list-style-type: decimal"><li>GBDT在高维稀疏的数据集上， 表现不如支持向量机或者神经网络。</li><li>GBDT在处理文本分类特征问题上， 相对其他模型的优势不如它在处理数值特征时明显。</li><li>训练过程需要串行训练， 只能在决策树内部采用一些局部并行的手段提高训练速度。</li></ol><h1 id="sklearn参数">sklearn参数</h1><p>在sacikit-learn中，<code>GradientBoostingClassifier</code>为GBDT的分类类， 而<code>GradientBoostingRegressor</code>为GBDT的回归类。两者的参数类型完全相同，当然有些参数比如损失函数loss的可选择项并不相同。</p><p>这些参数中，类似于Adaboost，我们把重要参数分为两类， - 第一类是Boosting框架的重要参数， - 第二类是弱学习器（即CART回归树）的重要参数。</p><p>下面我们就从这两个方面来介绍这些参数的使用。 ## GBDT类库boosting框架参数 由于GradientBoostingClassifier和GradientBoostingRegressor的参数绝大部分相同，我们下面会一起来讲，不同点会单独指出。</p><ol style="list-style-type: decimal"><li><p>n_estimators: 也就是弱学习器的最大迭代次数，或者说最大的弱学习器的个数。一般来说n_estimators太小，容易欠拟合，n_estimators太大，又容易过拟合，一般选择一个适中的数值。</p><ul><li>默认是100。在实际调参的过程中，我们常常将n_estimators和下面介绍的参数learning_rate一起考虑。</li></ul></li><li>learning_rate: 即每个弱学习器的权重缩减系数ν，也称作步长，加上了正则化项，我们的强学习器的迭代公式为<span class="math inline">\(f_{k}(x) = f_{k-1}(x) + \nu h_k(x)\)</span>。ν的取值范围为0&lt;ν≤1。对于同样的训练集拟合效果，较小的ν意味着我们需要更多的弱学习器的迭代次数。通常我们用步长和迭代最大次数一起来决定算法的拟合效果。<ul><li>所以这两个参数n_estimators和learning_rate要一起调参。一般来说，可以从一个小一点的ν开始调参，默认是1。</li></ul></li><li>subsample: 即我们在上文的正则化章节讲到的子采样，取值为(0,1]。注意这里的子采样和随机森林不一样，随机森林使用的是放回抽样，而这里是不放回抽样。如果取值为1，则全部样本都使用，等于没有使用子采样。如果取值小于1，则只有一部分样本会去做GBDT的决策树拟合。选择小于1的比例可以减少方差，即防止过拟合，但是会增加样本拟合的偏差，因此取值不能太低。<ul><li>推荐在[0.5, 0.8]之间，默认是1.0，即不使用子采样。</li></ul></li><li><p>init: 即我们的初始化的时候的弱学习器，拟合对应原理里面的f0(x)，如果不输入，则用训练集样本来做样本集的初始化分类回归预测。否则用init参数提供的学习器做初始化分类回归预测。一般用在我们对数据有先验知识，或者之前做过一些拟合的时候，如果没有的话就不用管这个参数了。</p></li><li><p>loss: 即我们GBDT算法中的损失函数。分类模型和回归模型的损失函数是不一样的。</p><ul><li><p>对于分类模型，有对数似然损失函数&quot;deviance&quot;和指数损失函数&quot;exponential&quot;两者输入选择。默认是对数似然损失函数&quot;deviance&quot;。在原理篇中对这些分类损失函数有详细的介绍。一般来说，推荐使用默认的&quot;deviance&quot;。它对二元分离和多元分类各自都有比较好的优化。而指数损失函数等于把我们带到了Adaboost算法。</p></li><li><p>对于回归模型，有均方差&quot;ls&quot;, 绝对损失&quot;lad&quot;, Huber损失&quot;huber&quot;和分位数损失“quantile”。默认是均方差&quot;ls&quot;。一般来说，如果数据的噪音点不多，用默认的均方差&quot;ls&quot;比较好。如果是噪音点较多，则推荐用抗噪音的损失函数&quot;huber&quot;。而如果我们需要对训练集进行分段预测的时候，则采用“quantile”。</p></li></ul></li><li><p>alpha：这个参数只有GradientBoostingRegressor有，当我们使用Huber损失&quot;huber&quot;和分位数损失“quantile”时，需要指定分位数的值。默认是0.9，如果噪音点较多，可以适当降低这个分位数的值。</p></li></ol><h2 id="gbdt类库弱学习器参数">GBDT类库弱学习器参数</h2><p>由于GBDT使用了CART回归决策树，因此它的参数基本来源于决策树类，也就是说，和<code>DecisionTreeClassifier</code>和<code>DecisionTreeRegressor</code>的参数基本类似。</p><ol style="list-style-type: decimal"><li>划分时考虑的最大特征数max_features: 可以使用很多种类型的值，默认是&quot;None&quot;,意味着划分时考虑所有的特征数；如果是&quot;log2&quot;意味着划分时最多考虑log2N个特征；如果是&quot;sqrt&quot;或者&quot;auto&quot;意味着划分时最多考虑N−−√个特征。如果是整数，代表考虑的特征绝对数。如果是浮点数，代表考虑特征百分比，即考虑（百分比xN）取整后的特征数。其中N为样本总特征数。<ul><li>一般来说，如果样本特征数不多，比如小于50，我们用默认的&quot;None&quot;就可以了，如果特征数非常多，我们可以灵活使用刚才描述的其他取值来控制划分时考虑的最大特征数，以控制决策树的生成时间。</li></ul></li><li>决策树最大深度max_depth: 默认可以不输入，如果不输入的话，默认值是3。一般来说，数据少或者特征少的时候可以不管这个值。如果模型样本量多，特征也多的情况下，推荐限制这个最大深度，具体的取值取决于数据的分布。<ul><li>常用的可以取值10-100之间。</li></ul></li><li>内部节点再划分所需最小样本数min_samples_split: 这个值限制了子树继续划分的条件，如果某节点的样本数少于min_samples_split，则不会继续再尝试选择最优特征来进行划分。<ul><li>默认是2.如果样本量不大，不需要管这个值。如果样本量数量级非常大，则推荐增大这个值。</li></ul></li><li>叶子节点最少样本数min_samples_leaf: 这个值限制了叶子节点最少的样本数，如果某叶子节点数目小于样本数，则会和兄弟节点一起被剪枝。 默认是1,可以输入最少的样本数的整数，或者最少样本数占样本总数的百分比。<ul><li>如果样本量不大，不需要管这个值。如果样本量数量级非常大，则推荐增大这个值。</li></ul></li><li>叶子节点最小的样本权重和min_weight_fraction_leaf：这个值限制了叶子节点所有样本权重和的最小值，如果小于这个值，则会和兄弟节点一起被剪枝。<ul><li>默认是0，就是不考虑权重问题。一般来说，如果我们有较多样本有缺失值，或者分类树样本的分布类别偏差很大，就会引入样本权重，这时我们就要注意这个值了。</li></ul></li><li>最大叶子节点数max_leaf_nodes: 通过限制最大叶子节点数，可以防止过拟合，默认是&quot;None”，即不限制最大的叶子节点数。如果加了限制，算法会建立在最大叶子节点数内最优的决策树。<ul><li>如果特征不多，可以不考虑这个值，但是如果特征分成多的话，可以加以限制，具体的值可以通过交叉验证得到。</li></ul></li><li>节点划分最小不纯度min_impurity_split: 这个值限制了决策树的增长，如果某节点的不纯度(基于基尼系数，均方差)小于这个阈值，则该节点不再生成子节点。即为叶子节点 。<ul><li>一般不推荐改动默认值1e-7。</li></ul></li></ol><h1 id="参考">参考</h1><ul><li>《百面机器学习》</li><li><a href="https://www.cnblogs.com/pinard/p/6140514.html" target="_blank" rel="noopener">梯度提升树(GBDT)原理小结</a></li><li><a href="https://www.cnblogs.com/pinard/p/6143927.html" target="_blank" rel="noopener">scikit-learn 梯度提升树(GBDT)调参小结</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sklearn </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pandas 处理时间类型数据</title>
      <link href="/2019/04/01/pandas%E5%A4%84%E7%90%86%E6%97%B6%E9%97%B4%E5%92%8C%E6%97%A5%E6%9C%9F%E7%B1%BB%E5%9E%8B%E6%95%B0%E6%8D%AE/"/>
      <url>/2019/04/01/pandas%E5%A4%84%E7%90%86%E6%97%B6%E9%97%B4%E5%92%8C%E6%97%A5%E6%9C%9F%E7%B1%BB%E5%9E%8B%E6%95%B0%E6%8D%AE/</url>
      
        <content type="html"><![CDATA[<p><strong>学习目标：</strong> - 时间序列数据导入，并转为时间类型 -</p><p>导入一个时间相关的数据集 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment">## importing a dataset</span></span><br><span class="line">url=<span class="string">"http://mlr.cs.umass.edu/ml/machine-learning-databases/event-detection/CalIt2.data"</span></span><br><span class="line">data = pd.read_csv(url, header = <span class="keyword">None</span>)</span><br></pre></td></tr></table></figure></p><p>查看数据的属性</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>data.head(<span class="number">3</span>)</span><br><span class="line">   <span class="number">0</span>         <span class="number">1</span>         <span class="number">2</span>  <span class="number">3</span></span><br><span class="line"><span class="number">0</span>  <span class="number">7</span>  <span class="number">07</span>/<span class="number">24</span>/<span class="number">05</span>  <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>  <span class="number">0</span></span><br><span class="line"><span class="number">1</span>  <span class="number">9</span>  <span class="number">07</span>/<span class="number">24</span>/<span class="number">05</span>  <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>  <span class="number">0</span></span><br><span class="line"><span class="number">2</span>  <span class="number">7</span>  <span class="number">07</span>/<span class="number">24</span>/<span class="number">05</span>  <span class="number">00</span>:<span class="number">30</span>:<span class="number">00</span>  <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 查看所有列的数据类型</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>data.dtypes</span><br><span class="line"><span class="number">0</span>     int64</span><br><span class="line"><span class="number">1</span>    object</span><br><span class="line"><span class="number">2</span>    object</span><br><span class="line"><span class="number">3</span>     int64</span><br><span class="line">dtype: object</span><br></pre></td></tr></table></figure><p>可以看出来第1列和第2列包含时间时间序列数据，但却是object类型，我们可以转换成时间类型。 ## 数据类型转化(object → datetime) <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>data[<span class="number">1</span>] = pd.to_datetime(data[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>data[<span class="number">2</span>] = pd.to_datetime(data[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>data.dtypes</span><br><span class="line"><span class="number">0</span>             int64</span><br><span class="line"><span class="number">1</span>    datetime64[ns]</span><br><span class="line"><span class="number">2</span>    datetime64[ns]</span><br><span class="line"><span class="number">3</span>             int64</span><br><span class="line">dtype: object</span><br></pre></td></tr></table></figure></p><h2 id="查看datetime类型数据">查看datetime类型数据</h2><ul><li>查看这个数据集中的时间数据中包含了哪些年、月、日等。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>data[<span class="number">1</span>].dt.year.unique()</span><br><span class="line">array([<span class="number">2005</span>], dtype=int64)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>data[<span class="number">1</span>].dt.month.unique()</span><br><span class="line">array([ <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>], dtype=int64)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>data[<span class="number">1</span>].dt.day.unique()</span><br><span class="line">array([<span class="number">24</span>, <span class="number">25</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">28</span>, <span class="number">29</span>, <span class="number">30</span>, <span class="number">31</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>,</span><br><span class="line">       <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>, <span class="number">20</span>, <span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>], dtype=int64)</span><br></pre></td></tr></table></figure><ul><li><p>查看某月的数据有多少 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>data[data[<span class="number">1</span>].dt.month == <span class="number">10</span>].shape</span><br><span class="line">(<span class="number">2976</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure></p></li><li><p>查看两个时间相差多久</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>data.loc[<span class="number">6624</span>,<span class="number">1</span>] - data.loc[<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">Timedelta(<span class="string">'69 days 00:00:00'</span>)</span><br></pre></td></tr></table></figure><p>第1行和第6624行的数据相差69天，结果是个Timedelta数据类型。</p><p>参考：<a href="https://stepik.org/lesson/44678/step/1?unit=22718" target="_blank" rel="noopener">Working with Dates and timedelta in Pandas</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> pandas </tag>
            
            <tag> 时间序列 </tag>
            
            <tag> 数据分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模型评估指标</title>
      <link href="/2019/03/21/%E6%A8%A1%E5%9E%8B%E9%AA%8C%E8%AF%81/"/>
      <url>/2019/03/21/%E6%A8%A1%E5%9E%8B%E9%AA%8C%E8%AF%81/</url>
      
        <content type="html"><![CDATA[<p>先加载数据 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Data Loading</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># Load data</span></span><br><span class="line">melbourne_file_path = <span class="string">'../input/melbourne-housing-snapshot/melb_data.csv'</span></span><br><span class="line">melbourne_data = pd.read_csv(melbourne_file_path) </span><br><span class="line"><span class="comment"># Filter rows with missing price values</span></span><br><span class="line">filtered_melbourne_data = melbourne_data.dropna(axis=<span class="number">0</span>)</span><br><span class="line"><span class="comment"># Choose target and features</span></span><br><span class="line">y = filtered_melbourne_data.Price</span><br><span class="line">melbourne_features = [<span class="string">'Rooms'</span>, <span class="string">'Bathroom'</span>, <span class="string">'Landsize'</span>, <span class="string">'BuildingArea'</span>, </span><br><span class="line">                        <span class="string">'YearBuilt'</span>, <span class="string">'Lattitude'</span>, <span class="string">'Longtitude'</span>]</span><br><span class="line">X = filtered_melbourne_data[melbourne_features]</span><br></pre></td></tr></table></figure></p><p>回归模型评价指标MSE、RMSE、MAE、R-Squared</p><h1 id="均方误差mae">均方误差(MAE)</h1><p>MSE （Mean Squared Error）叫做均方误差。看公式</p><p><span class="math display">\[ \frac{1}{m}\sum _ { i=1 }^m (y_ i-\hat{y_i})^2\]</span></p><h1 id="参考">参考</h1><ul><li><a href="https://www.kaggle.com/dansbecker/model-validation" target="_blank" rel="noopener">Model Validation</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>梯度下降(gradient boosting)</title>
      <link href="/2019/03/18/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D/"/>
      <url>/2019/03/18/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> 梯度下降 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>决策树(Decision trees)</title>
      <link href="/2019/03/18/%E5%86%B3%E7%AD%96%E6%A0%91/"/>
      <url>/2019/03/18/%E5%86%B3%E7%AD%96%E6%A0%91/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回溯、分治、动态规划</title>
      <link href="/2019/03/16/%E5%9B%9E%E6%BA%AF%E3%80%81%E5%88%86%E6%B2%BB%E3%80%81%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%20/"/>
      <url>/2019/03/16/%E5%9B%9E%E6%BA%AF%E3%80%81%E5%88%86%E6%B2%BB%E3%80%81%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%20/</url>
      
        <content type="html"><![CDATA[<p>回溯法是暴力搜索法中的一种。 对于某些计算问题而言，回溯法是一种可以找出所有解的一般性算法，尤其适用于约束满足问题。回溯法采用试错的思想，它尝试分步的去解决一个问题。</p><p>在分步解决问题的过程中，当它通过尝试发现现有的分步答案不能得到有效的正确的解答的时候，它将取消上一步甚至是上几步的计算，再通过其它的可能的分步解答再次尝试寻找问题的答案。回溯法通常用最简单的递归方法来实现，在反复重复上述的步骤后可能出现两种情况：</p><ul><li>找到一个可能存在的正确的答案</li><li>在尝试了所有可能的分步方法后宣告该问题没有答案</li></ul><p><strong>学习目标：</strong> - 利用回溯算法求解八皇后问题 - 利用回溯算法求解 0-1 背包问题</p><a id="more"></a><p>分治 利用分治算法求一组数据的逆序对个数</p><p>动态规划 0-1 背包问题 最小路径和（详细可看 Minimum Path Sum） 编程实现莱文斯坦最短编辑距离 编程实现查找两个字符串的最长公共子序列 编程实现一个数据序列的最长递增子序列</p><p>对应的 LeetCode 练习题 实战递归：完成Leetcode上的Letter Combinations of a Phone Number(17)及permutations(46) （保留往期第六天任务） 实战DP：完成0-1背包问题实现(自我实现)及Leetcode上Palindrome Partitioning II(132) （保留往期第七天任务） Regular Expression Matching（正则表达式匹配） 英文版：https://leetcode.com/problems/regular-expression-matching/ 中文版：https://leetcode-cn.com/problems/regular-expression-matching/ Minimum Path Sum（最小路径和） 英文版：https://leetcode.com/problems/minimum-path-sum/ 中文版：https://leetcode-cn.com/problems/minimum-path-sum/ Coin Change （零钱兑换） 英文版：https://leetcode.com/problems/coin-change/ 中文版：https://leetcode-cn.com/problems/coin-change/ Best Time to Buy and Sell Stock（买卖股票的最佳时机） 英文版：https://leetcode.com/problems/best-time-to-buy-and-sell-stock/ 中文版：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/ Maximum Product Subarray（乘积最大子序列） 英文版：https://leetcode.com/problems/maximum-product-subarray/ 中文版：https://leetcode-cn.com/problems/maximum-product-subarray/ Triangle（三角形最小路径和） 英文版：https://leetcode.com/problems/triangle/ 中文版：https://leetcode-cn.com/problems/triangle/</p><h1 id="八皇后问题">八皇后问题</h1><p>有一个棋盘和8个要放到上面的皇后。唯一的要求是皇后之间不能形成威胁。（必须把它们放置成每个皇后都不能吃掉其他皇后的状态）皇后要如何放置呢？</p><p>假设不只是8个，而是有任意数目的皇后，怎么解决？</p><h2 id="方法回溯-生成器">方法：回溯 + 生成器</h2><p>这是一个典型的回溯问题。首先尝试在第一行放置第1个皇后，然后第二行放置第2个，依次类推。 如果发现不能放置下一个皇后，就回溯到上一步，试着将皇后放到其他的位置。最后，或者尝试完所有的可能，或者找到解决方案。</p><ol style="list-style-type: decimal"><li>状态表示<ul><li>元组表示：每个元组中的元素都指示相应行的皇后的列的位置信息。</li><li>比如 <code>state[0] == 3</code> 就是第一行的皇后在第4列。</li></ul></li><li>寻找冲突<ul><li>定义一个 conflict 函数，传入已知的皇后位置，判断下一个皇后可能的位置是否与它们有冲突。</li><li>冲突指的是水平位置(即列数)相同，或者对角线位置相同(即行数之差==列数之差)。</li></ul></li><li>基本情况：最后一个皇后该怎么做？<ul><li>已知其他行皇后的位置(相互间没有冲突)，遍历这一行的每一列，返回没有冲突发生的位置。</li></ul></li><li>需要递归的情况<ul><li>同样已知底层的所有行皇后位置(相互间没有冲突)，判断当前行的这一列没有冲突，则加入包含位置信息的元组中，递归传到下一层，下一层返回它的所有正确位置，加入到当前层的位置信息中。</li></ul></li><li>打包<ul><li>清理输出。将输出处理得更容易理解一点。</li></ul></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">conflict</span><span class="params">(state, nextX)</span>:</span> <span class="comment">#nextX是当前列数</span></span><br><span class="line">    nextY = len(state) <span class="comment"># 当前行数</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(nextY):<span class="comment"># 遍历之前所有行</span></span><br><span class="line">        <span class="keyword">if</span> abs(state[i]-nextX) <span class="keyword">in</span> (<span class="number">0</span>, nextY-i):</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span> <span class="comment"># 同一列或统一对角线上，就冲突</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#生成器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">queens</span><span class="params">(num=<span class="number">8</span>, state=<span class="params">()</span>)</span>:</span> </span><br><span class="line">    <span class="keyword">for</span> pos <span class="keyword">in</span> range(num):<span class="comment">#遍历所有列</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> conflict(state,pos): <span class="comment">#如果这一列不冲突</span></span><br><span class="line">            <span class="keyword">if</span> len(state) == num<span class="number">-1</span>:<span class="comment">#到了最后一个皇后</span></span><br><span class="line">                <span class="keyword">yield</span> (pos,)</span><br><span class="line">            <span class="keyword">else</span>:<span class="comment">#递归</span></span><br><span class="line">                <span class="keyword">for</span> result <span class="keyword">in</span> queens(num,state+(pos,)):<span class="comment">#加上当前层的正确列数pos去下一层</span></span><br><span class="line">                    <span class="comment">#result就是递归的下一层返回来的一个列结果</span></span><br><span class="line">                    <span class="keyword">yield</span> (pos,) + result <span class="comment"># 当前层应该返回的结果</span></span><br><span class="line"><span class="comment"># 生成器给出所有解决方案</span></span><br><span class="line">print(list(queens(<span class="number">3</span>)))  <span class="comment"># []</span></span><br><span class="line">print(list(queens(<span class="number">4</span>)))  <span class="comment"># [(1, 3, 0, 2), (2, 0, 3, 1)]</span></span><br><span class="line"><span class="comment"># 8个皇后有多少中解决方案：</span></span><br><span class="line">print(len(list(queens(<span class="number">8</span>))))  <span class="comment"># 92</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打包：更形象得随机输出解决方案</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">prettyprint</span><span class="params">(solution)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">line</span><span class="params">(pos,length=len<span class="params">(solution)</span>)</span>:</span> <span class="comment"># 对于每一行pos</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'. '</span>*pos + <span class="string">'X '</span> + <span class="string">'. '</span>*(length-pos<span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">for</span> pos <span class="keyword">in</span> solution:<span class="comment"># 对于每一行pos</span></span><br><span class="line">        print(line(pos))</span><br><span class="line">        </span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line">prettyprint(random.choice(list(queens(<span class="number">8</span>))))</span><br><span class="line"><span class="comment">#输出：</span></span><br><span class="line"><span class="comment">#. . . . . . X . </span></span><br><span class="line"><span class="comment">#X . . . . . . . </span></span><br><span class="line"><span class="comment">#. . X . . . . . </span></span><br><span class="line"><span class="comment">#. . . . . . . X </span></span><br><span class="line"><span class="comment">#. . . . . X . . </span></span><br><span class="line"><span class="comment">#. . . X . . . . </span></span><br><span class="line"><span class="comment">#. X . . . . . . </span></span><br><span class="line"><span class="comment">#. . . . X . . .</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python 魔法方法</title>
      <link href="/2019/03/14/python%E9%AD%94%E6%B3%95%E6%96%B9%E6%B3%95/"/>
      <url>/2019/03/14/python%E9%AD%94%E6%B3%95%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>Python 中有的方法的名称前后都有两个下划线，这些方法被称为魔法方法。如果对象实现了这些方法中的某一个，那么这个方法就会在特殊的情况下被 Python 所调用，而这一切都是自动发生的。</p><p>这里总结一些重要的魔法方法： - 构造方法 <code>__init__</code> , <code>__new__</code></p><a id="more"></a><h1 id="构造方法">构造方法</h1><h2 id="init__"><code>__init__</code></h2><p>在定义类的时候，会去定义构造方法。当一个对象被创造后，会立即调用构造方法，定义这个对象的初始值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooBar</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,s=<span class="number">8</span>)</span>:</span></span><br><span class="line">        self.var = <span class="number">40</span></span><br><span class="line">        self.some = s</span><br><span class="line"></span><br><span class="line">f = FooBar(<span class="number">9</span>)</span><br><span class="line">print(f.var) <span class="comment"># 40</span></span><br><span class="line">print(f.some) <span class="comment"># 9</span></span><br></pre></td></tr></table></figure><p>可以给构造函数传几个参数。</p><h2 id="new__"><code>__new__</code></h2><p>这个方法我们一般很少定义，不过我们在一些开源框架中偶尔会遇到定义这个方法的类。实际上，这才是“真正的构造方法”，它会在对象实例化时第一个被调用，然后再调用<code>__init__</code>，它们的区别主要如下：</p><ul><li><code>__new__</code>的第一个参数是<code>cls</code>xz，而<code>__init__</code>的第一个参数是<code>self</code></li><li><code>__new__</code>返回值是一个实例，而<code>__init__</code>没有任何返回值，只做初始化操作</li><li><code>__new__</code>由于是返回一个实例对象，所以它可以给所有实例进行统一的初始化操作</li><li>由于 <code>__new__</code> 优先于 <code>__init__</code> 调用，且返回一个实例。</li></ul><p>看下面例子： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kwargs)</span>:</span></span><br><span class="line">        print(<span class="string">"in __new__"</span>)</span><br><span class="line">        instance = object.__new__(cls)</span><br><span class="line">        <span class="keyword">return</span> instance</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span></span><br><span class="line">        print(<span class="string">"in __init__"</span>)</span><br><span class="line">        self._name = name</span><br><span class="line">        self._age = age</span><br><span class="line"></span><br><span class="line">p = Person(<span class="string">"Wang"</span>, <span class="number">33</span>)</span><br><span class="line"><span class="comment">#输出：</span></span><br><span class="line"><span class="comment">#in __new__</span></span><br><span class="line"><span class="comment">#in __init__</span></span><br></pre></td></tr></table></figure></p><p>可以每次返回同一个实例来实现一个单例类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span><span class="params">(object)</span>:</span></span><br><span class="line">    _instance = <span class="keyword">None</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> cls._instance <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            cls._instance = object.__new__(cls, *args, **kwargs)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cls._instance</span><br><span class="line"></span><br><span class="line">s1 = Singleton()</span><br><span class="line">s2 = Singleton()</span><br><span class="line">print(s1)</span><br><span class="line">print(s2) </span><br><span class="line"><span class="comment">#输出：</span></span><br><span class="line"><span class="comment"># &lt;__main__.Singleton object at 0x000001AEC9403400&gt;</span></span><br><span class="line"><span class="comment"># &lt;__main__.Singleton object at 0x000001AEC9403400&gt;</span></span><br></pre></td></tr></table></figure><p>可以看到s1和s2都指向同一个对象，实现了单例模式。</p><p>再来看下工厂模式的实现 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fruit</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">print_color</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span><span class="params">(Fruit)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">print_color</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"apple is in red"</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Orange</span><span class="params">(Fruit)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">print_color</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"orange is in orange"</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FruitFactory</span><span class="params">(object)</span>:</span></span><br><span class="line">    fruits = &#123;<span class="string">"apple"</span>: Apple, <span class="string">"orange"</span>: Orange&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, name)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> name <span class="keyword">in</span> cls.fruits.keys():</span><br><span class="line">            <span class="keyword">return</span> cls.fruits[name]()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> Fruit()</span><br><span class="line"></span><br><span class="line">fruit1 = FruitFactory(<span class="string">"apple"</span>)</span><br><span class="line">fruit2 = FruitFactory(<span class="string">"orange"</span>)</span><br><span class="line">fruit1.print_color()    </span><br><span class="line">fruit2.print_color()    </span><br><span class="line">fruit3 = FruitFactory(<span class="string">"banana"</span>)</span><br><span class="line">print(fruit2)</span><br><span class="line">print(fruit3)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="comment"># apple is in red</span></span><br><span class="line"><span class="comment"># orange is in orange</span></span><br><span class="line"><span class="comment"># &lt;__main__.Orange object at 0x000001AEC940F2E8&gt;</span></span><br><span class="line"><span class="comment"># &lt;__main__.Fruit object at 0x000001AEC94277F0&gt;</span></span><br></pre></td></tr></table></figure></p><p>另外一种使用场景是当你需要继承内置类时，例如int、str、tuple，只能通过__new__来达到初始化数据的效果： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">g</span><span class="params">(float)</span>:</span></span><br><span class="line">    <span class="string">"""千克转克"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, kg)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> float.__new__(cls, kg * <span class="number">2</span>)</span><br><span class="line"><span class="comment"># 50千克转为克</span></span><br><span class="line">a = g(<span class="number">50</span>)</span><br><span class="line">print(a)<span class="comment"># 100.0</span></span><br><span class="line">print(a + <span class="number">100</span>)<span class="comment"># 200.0, 由于继承了float，所以可以直接运算，非常方便！</span></span><br></pre></td></tr></table></figure></p><h2 id="del__"><code>__del__</code></h2><p>这是析构方法，也就是在对象被垃圾回收之前被调用。</p><h1 id="自定义序列和映射">自定义序列和映射</h1><p>序列和映射是对象的集合。为了实现它们的基本行为，如果对象是不可变的，就需要使用 <code>__len__</code> 和 <code>__getitem__</code> 两个魔法方法，如果是可变的，则还需要使用 <code>__setitem__</code> 和 <code>__delitem__</code> 。</p><p><code>__len__(self)</code></p><p>返回容器的长度，可变和不可变类型都需要实现。</p><p><code>__getitem__(self, key)</code></p><p>定义对容器中某一项使用 <code>self[key]</code> 的方式进行读取操作时的行为。这也是可变和不可变容器类型都需要实现的一个方法。它应该在键的类型错误式产生 TypeError 异常，同时在没有与键值相匹配的内容时产生 KeyError 异常。</p><p><code>__setitem__(self, key)</code></p><p>定义对容器中某一项使用 <code>self[key]</code> 的方式进行赋值操作时的行为。它是可变容器类型必须实现的一个方法，同样应该在合适的时候产生 KeyError 和 TypeError 异常。</p><p><code>__delitem__(self, key)</code></p><p>这个方法在对一部分对象使用 del 语句时被调用，同时必须删除和键相关的键。</p><h1 id="访问控制">访问控制</h1><h2 id="str__"><code>__str__</code></h2><p>当被 str() 调用时会执行__str__。此方法类似JAVA中的toString方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span><span class="comment">#重写__str__方法</span></span><br><span class="line">        <span class="keyword">return</span> self.name</span><br><span class="line"></span><br><span class="line">a = A(<span class="string">"Tom"</span>)</span><br><span class="line">print(a)</span><br><span class="line">b = B(<span class="string">"Jake"</span>)</span><br><span class="line">print(b)</span><br><span class="line"><span class="comment">#输出：</span></span><br><span class="line"><span class="comment">#&lt;__main__.A object at 0x000001AEC9447198&gt;</span></span><br><span class="line"><span class="comment">#Jake</span></span><br></pre></td></tr></table></figure><h1 id="迭代器">迭代器</h1><h2 id="iter__"><code>__iter__</code></h2><p>该方法会返回一个迭代器。</p><p>迭代器是具有next方法的对象。在调用next方法时，会返回迭代器的下一个值。</p><p>除了在迭代器和可迭代对象上进行迭代外，还能把他们转换为序列。</p><p>下面的例子是用list构造方法显示地将迭代器转化为列表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="生成器">生成器</h1><h1 id="参考">参考</h1><ul><li><a href="https://juejin.im/post/5add4446f265da0b8d4186af" target="_blank" rel="noopener">Python面试之理解__new__和__init__的区别</a></li><li></li></ul>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python实现数据结构之图</title>
      <link href="/2019/03/10/python%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%9B%BE/"/>
      <url>/2019/03/10/python%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<p><strong>学习目标：</strong></p><ul><li>实现有向图、无向图、有权图、无权图的邻接矩阵和邻接表表示方法</li><li>实现图的深度优先搜索、广度优先搜索 实现 Dijkstra 算法、A* 算法 实现拓扑排序的 Kahn 算法、DFS 算法 对应的 LeetCode 练习题 200 Number of Islands（岛屿的个数） 英文版：https://leetcode.com/problems/number-of-islands/description/ 中文版：https://leetcode-cn.com/problems/number-of-islands/description/ Valid Sudoku（有效的数独） 英文版：https://leetcode.com/problems/valid-sudoku/ 中文版：https://leetcode-cn.com/problems/valid-sudoku/</li></ul><a id="more"></a><h1 id="实现一个邻接表表示的有向带权图">实现一个邻接表表示的有向带权图</h1><p>每个顶点的所有邻接点和对应的边的权重用字典表示。</p><p>对于无权图，可以只将顶点的所有邻接点放入 list 中即可。</p><p>图的所有顶点名称及对应的顶点对象用字典表示。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vertex</span>:</span><span class="comment">#顶点</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,key)</span>:</span></span><br><span class="line">        self.id = key</span><br><span class="line">        self.connectedTo = &#123;&#125; <span class="comment">#邻接点，及相应的权重</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addNeighbor</span><span class="params">(self, nbr, weight=<span class="number">0</span>)</span>:</span></span><br><span class="line">        self.connectedTo[nbr] = weight</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> str(self.id) + <span class="string">' connectedTo: '</span>+str([x.id <span class="keyword">for</span> x <span class="keyword">in</span> self.connectedTo])</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getConnections</span><span class="params">(self)</span>:</span> <span class="comment">#多有邻接点</span></span><br><span class="line">        <span class="keyword">return</span> self.connectedTo.keys()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getId</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.id</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getWeight</span><span class="params">(self,nbr)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.connectedTo[nbr]</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graph</span>:</span> <span class="comment"># 邻接表表示的有向带权图</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.vertList = &#123;&#125; <span class="comment"># 所有顶点</span></span><br><span class="line">        self.numVertices = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addVertex</span><span class="params">(self, key)</span>:</span> <span class="comment">#添加顶点</span></span><br><span class="line">        self.numVertices += <span class="number">1</span></span><br><span class="line">        newVertex = Vertex(key)</span><br><span class="line">        self.vertList[key] = newVertex</span><br><span class="line">        <span class="keyword">return</span> newVertex</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getVertex</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> n <span class="keyword">in</span> self.vertList:</span><br><span class="line">            <span class="keyword">return</span> self.vertList[n]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__contains__</span><span class="params">(self,n)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> n <span class="keyword">in</span> self.vertList</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addEdge</span><span class="params">(self,f,t,cost=<span class="number">0</span>)</span>:</span> <span class="comment">#添加边</span></span><br><span class="line">        <span class="keyword">if</span> f <span class="keyword">not</span> <span class="keyword">in</span> self.vertList:</span><br><span class="line">            self.addVertex(f)</span><br><span class="line">        <span class="keyword">if</span> t <span class="keyword">not</span> <span class="keyword">in</span> self.vertList:</span><br><span class="line">            self.addVertex(t)</span><br><span class="line">        self.vertList[f].addNeighbor(self.vertList[t], cost)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getVertices</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.vertList.keys()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> iter(self.vertList.values())</span><br><span class="line">    </span><br><span class="line">g = Graph()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">6</span>):</span><br><span class="line">    g.addVertex(i)</span><br><span class="line">print(g.getVertex(<span class="number">3</span>))</span><br><span class="line">print(g.vertList)</span><br><span class="line">print(<span class="number">3</span> <span class="keyword">in</span> g)</span><br><span class="line">g.addEdge(<span class="number">0</span>,<span class="number">1</span>,<span class="number">5</span>)</span><br><span class="line">g.addEdge(<span class="number">0</span>,<span class="number">5</span>,<span class="number">2</span>)</span><br><span class="line">g.addEdge(<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>)</span><br><span class="line">g.addEdge(<span class="number">2</span>,<span class="number">3</span>,<span class="number">9</span>)</span><br><span class="line">g.addEdge(<span class="number">3</span>,<span class="number">4</span>,<span class="number">7</span>)</span><br><span class="line">g.addEdge(<span class="number">3</span>,<span class="number">5</span>,<span class="number">3</span>)</span><br><span class="line">g.addEdge(<span class="number">4</span>,<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">g.addEdge(<span class="number">5</span>,<span class="number">4</span>,<span class="number">8</span>)</span><br><span class="line">g.addEdge(<span class="number">5</span>,<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">print(g.getVertices())</span><br><span class="line"><span class="keyword">for</span> v <span class="keyword">in</span> g:</span><br><span class="line">    <span class="keyword">for</span> w <span class="keyword">in</span> v.getConnections():</span><br><span class="line">        print(<span class="string">'(%s,%s)'</span>%(v.getId(), w.getId()))</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">3 connectedTo: []</span><br><span class="line">&#123;0: &lt;__main__.Vertex object at 0x000001AEC9423B70&gt;, 1: &lt;__main__.Vertex object at 0x000001AEC903F748&gt;, 2: &lt;__main__.Vertex object at 0x000001AEC85F8CC0&gt;, 3: &lt;__main__.Vertex object at 0x000001AEC9415FD0&gt;, 4: &lt;__main__.Vertex object at 0x000001AEC9415EF0&gt;, 5: &lt;__main__.Vertex object at 0x000001AEC9415B70&gt;&#125;</span><br><span class="line">True</span><br><span class="line">dict_keys([0, 1, 2, 3, 4, 5])</span><br><span class="line">(0,1)</span><br><span class="line">(0,5)</span><br><span class="line">(1,2)</span><br><span class="line">(2,3)</span><br><span class="line">(3,4)</span><br><span class="line">(3,5)</span><br><span class="line">(4,0)</span><br><span class="line">(5,4)</span><br><span class="line">(5,2)</span><br></pre></td></tr></table></figure><h1 id="图的遍历">图的遍历</h1><p>遍历图最常用的有两种方式，就是你常听到的 BFS 和 DFS.</p><ul><li>BFS: Breadth First Search，广度优先搜索</li><li>DFS: Depdth First Search，深度优先搜索</li></ul><h2 id="bfs">BFS</h2><p>BFS 类似于树的层序遍历，从第一个节点开始，先访问离 A 最近的点，接着访问次近的点。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line">GRAPH = &#123;  <span class="comment"># 邻接表表示的无向无权图</span></span><br><span class="line">    <span class="string">'A'</span>: [<span class="string">'B'</span>, <span class="string">'F'</span>],</span><br><span class="line">    <span class="string">'B'</span>: [<span class="string">'C'</span>, <span class="string">'I'</span>, <span class="string">'G'</span>],</span><br><span class="line">    <span class="string">'C'</span>: [<span class="string">'B'</span>, <span class="string">'I'</span>, <span class="string">'D'</span>],</span><br><span class="line">    <span class="string">'D'</span>: [<span class="string">'C'</span>, <span class="string">'I'</span>, <span class="string">'G'</span>, <span class="string">'H'</span>, <span class="string">'E'</span>],</span><br><span class="line">    <span class="string">'E'</span>: [<span class="string">'D'</span>, <span class="string">'H'</span>, <span class="string">'F'</span>],</span><br><span class="line">    <span class="string">'F'</span>: [<span class="string">'A'</span>, <span class="string">'G'</span>, <span class="string">'E'</span>],</span><br><span class="line">    <span class="string">'G'</span>: [<span class="string">'B'</span>, <span class="string">'F'</span>, <span class="string">'H'</span>, <span class="string">'D'</span>],</span><br><span class="line">    <span class="string">'H'</span>: [<span class="string">'G'</span>, <span class="string">'D'</span>, <span class="string">'E'</span>],</span><br><span class="line">    <span class="string">'I'</span>: [<span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span><span class="params">(object)</span>:</span> <span class="comment"># 队列辅助</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._deque = deque()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._deque.append(value)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._deque.popleft()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self._deque)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bfs</span><span class="params">(graph, start)</span>:</span></span><br><span class="line">    search_queue = Queue()</span><br><span class="line">    search_queue.push(start)<span class="comment"># 起点先入队</span></span><br><span class="line">    searched = set() <span class="comment"># 已经访问过的结点</span></span><br><span class="line">    <span class="keyword">while</span> search_queue:   <span class="comment"># 队列不为空就继续</span></span><br><span class="line">        cur_node = search_queue.pop() <span class="comment"># 出队</span></span><br><span class="line">        <span class="keyword">if</span> cur_node <span class="keyword">not</span> <span class="keyword">in</span> searched: <span class="comment"># 若是未访问的结点</span></span><br><span class="line">            <span class="keyword">yield</span> cur_node <span class="comment"># 读出</span></span><br><span class="line">            searched.add(cur_node) <span class="comment"># 添加到记录中</span></span><br><span class="line">            <span class="keyword">for</span> node <span class="keyword">in</span> graph[cur_node]: <span class="comment"># 所有邻接点</span></span><br><span class="line">                search_queue.push(node)<span class="comment"># 起点的所有邻接点入队</span></span><br><span class="line"></span><br><span class="line">print([i <span class="keyword">for</span> i <span class="keyword">in</span> bfs(GRAPH, <span class="string">'A'</span>)])</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&apos;A&apos;, &apos;B&apos;, &apos;F&apos;, &apos;C&apos;, &apos;I&apos;, &apos;G&apos;, &apos;E&apos;, &apos;D&apos;, &apos;H&apos;]</span><br></pre></td></tr></table></figure><h2 id="dfs">DFS</h2><p>深度优先搜索(DFS)是每遇到一个节点，如果没有被访问过，就直接去访问它的邻居节点，不断加深。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">GRAPH = &#123;  <span class="comment">#邻接表表示的无向无权图</span></span><br><span class="line">    <span class="string">'A'</span>: [<span class="string">'B'</span>, <span class="string">'F'</span>],</span><br><span class="line">    <span class="string">'B'</span>: [<span class="string">'C'</span>, <span class="string">'I'</span>, <span class="string">'G'</span>],</span><br><span class="line">    <span class="string">'C'</span>: [<span class="string">'B'</span>, <span class="string">'I'</span>, <span class="string">'D'</span>],</span><br><span class="line">    <span class="string">'D'</span>: [<span class="string">'C'</span>, <span class="string">'I'</span>, <span class="string">'G'</span>, <span class="string">'H'</span>, <span class="string">'E'</span>],</span><br><span class="line">    <span class="string">'E'</span>: [<span class="string">'D'</span>, <span class="string">'H'</span>, <span class="string">'F'</span>],</span><br><span class="line">    <span class="string">'F'</span>: [<span class="string">'A'</span>, <span class="string">'G'</span>, <span class="string">'E'</span>],</span><br><span class="line">    <span class="string">'G'</span>: [<span class="string">'B'</span>, <span class="string">'F'</span>, <span class="string">'H'</span>, <span class="string">'D'</span>],</span><br><span class="line">    <span class="string">'H'</span>: [<span class="string">'G'</span>, <span class="string">'D'</span>, <span class="string">'E'</span>],</span><br><span class="line">    <span class="string">'I'</span>: [<span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DFS_SEARCHED = set()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(graph, start)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> start <span class="keyword">not</span> <span class="keyword">in</span> DFS_SEARCHED: <span class="comment"># 若是未访问的结点</span></span><br><span class="line">        print(start)</span><br><span class="line">        DFS_SEARCHED.add(start)</span><br><span class="line">    <span class="keyword">for</span> node <span class="keyword">in</span> graph[start]: <span class="comment"># 所有邻接点</span></span><br><span class="line">        <span class="keyword">if</span> node <span class="keyword">not</span> <span class="keyword">in</span> DFS_SEARCHED:<span class="comment"># 一旦是未访问的结点</span></span><br><span class="line">            dfs(graph, node)  <span class="comment"># 递归</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dfs(GRAPH, <span class="string">'A'</span>)  <span class="comment"># A B C I D G F E H</span></span><br></pre></td></tr></table></figure><h1 id="参考">参考</h1><ul><li>《Problem Solving with Algorithms and Data Structures using Python》</li><li><a href="https://python-data-structures-and-algorithms.readthedocs.io/zh/latest/18_%E5%9B%BE%E4%B8%8E%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86/graph/" target="_blank" rel="noopener">18_图与图的遍历</a></li><li><a href="https://www.zybuluo.com/guoxs/note/249812" target="_blank" rel="noopener">数据结构之图</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python实现数据结构之堆</title>
      <link href="/2019/03/10/python%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%A0%86/"/>
      <url>/2019/03/10/python%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%A0%86/</url>
      
        <content type="html"><![CDATA[<p>学习目标：</p><ul><li>实现一个小顶堆、大顶堆、优先级队列</li><li>实现堆排序</li><li>利用优先级队列合并 K 个有序数组</li><li>求一组动态数据集合的最大 Top K</li><li>（选做）第三天堆排序学习（复习）</li></ul><a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 堆 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python实现数据结构之二叉树</title>
      <link href="/2019/03/09/python%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2019/03/09/python%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>二叉查找树（英语：Binary Search Tree），也称为二叉搜索树、有序二叉树（ordered binary tree）或排序二叉树（sorted binary tree）。</p><p><strong>学习目标：</strong> - 实现一个二叉查找树，并且支持插入、删除、查找操作 - LeetCode 108. 将有序数组转换为二叉搜索树 - LeetCode 109. 有序链表转换二叉搜索树 - LeetCode 701. 二叉搜索树中的插入操作 - LeetCode 700. 二叉搜索树中的搜索 - LeetCode 450. 删除二叉搜索树中的结点 - 实现查找二叉查找树中某个结点的后继、前驱结点 - 实现二叉树前、中、后序以及按层遍历 - LeetCode 144. 二叉树的前序遍历 - LeetCode 94. 二叉树的中序遍历 - LeetCode 145. 二叉树的后序遍历 - LeetCode 102. 二叉树的层次遍历 - LeetCode 98. 验证二叉搜索树 - LeetCode 103. 二叉树的锯齿形层次遍历 - LeetCode 226. 翻转二叉树 - LeetCode 104. 二叉树的最大深度 - LeetCode 112. 路径总和</p><a id="more"></a><p>二叉查找树是指一棵空树或者具有下列性质的二叉树：</p><ol style="list-style-type: decimal"><li>若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值；</li><li>若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值；</li><li>任意节点的左、右子树也分别为二叉查找树；</li><li>没有键值相等的节点。</li></ol><p>二叉查找树相比于其他数据结构的优势在于查找、插入的时间复杂度较低，为 <span class="math inline">\(O(log n)\)</span>。 每次插入的新的结点都是二叉查找树上新的叶子结点，在进行插入操作时，不必移动其它结点，只需改动某个结点的指针，由空变为非空即可。</p><h1 id="将有序数组转换为二叉搜索树">将有序数组转换为二叉搜索树</h1><p><a href="https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/" target="_blank" rel="noopener">LeetCode 108. Convert Sorted Array to Binary Search Tree</a></p><p>将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。</p><p>本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。</p><p>示例: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">给定有序数组: [-10,-3,0,5,9],</span><br><span class="line"></span><br><span class="line">一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树：</span><br><span class="line"></span><br><span class="line">      0</span><br><span class="line">     / \</span><br><span class="line">   -3   9</span><br><span class="line">   /   /</span><br><span class="line"> -10  5</span><br></pre></td></tr></table></figure></p><h2 id="方法递归">方法：递归</h2><p>由于要求二叉查找树是平衡的。所以可以选在数组的中间那个数当树根root。</p><p>然后这个数左边的数组为左子树，右边的数组为右子树，分别递归产生左右子树就可以了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortedArrayToBST</span><span class="params">(self, nums: List[int])</span> -&gt; TreeNode:</span>        </span><br><span class="line">        length = len(nums)</span><br><span class="line">        <span class="keyword">if</span> length == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">if</span> length == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> TreeNode(nums[<span class="number">0</span>])</span><br><span class="line">        middle = (length<span class="number">-1</span>)//<span class="number">2</span></span><br><span class="line">        root = TreeNode(nums[middle])</span><br><span class="line">        root.left = self.sortedArrayToBST(nums[:middle])</span><br><span class="line">        root.right = self.sortedArrayToBST(nums[middle+<span class="number">1</span>:])</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><h1 id="有序链表转换二叉搜索树">有序链表转换二叉搜索树</h1><p><a href="https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/" target="_blank" rel="noopener">LeetCode 109. Convert Sorted List to Binary Search Tree</a></p><p>给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。</p><p>本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。</p><p>示例: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">给定的有序链表： [-10, -3, 0, 5, 9],</span><br><span class="line"></span><br><span class="line">一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树：</span><br><span class="line"></span><br><span class="line">      0</span><br><span class="line">     / \</span><br><span class="line">   -3   9</span><br><span class="line">   /   /</span><br><span class="line"> -10  5</span><br></pre></td></tr></table></figure></p><h2 id="方法链表转成数组">方法：链表转成数组</h2><p>转成数组后，方法同上一题108的解法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortedListToBST</span><span class="params">(self, head: ListNode)</span> -&gt; TreeNode:</span></span><br><span class="line">        nums = []</span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            nums.append(head.val)</span><br><span class="line">            head = head.next</span><br><span class="line">            </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">sortedArrayToBST</span><span class="params">(nums)</span>:</span></span><br><span class="line">            length = len(nums)</span><br><span class="line">            <span class="keyword">if</span> length == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">            <span class="keyword">if</span> length == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> TreeNode(nums[<span class="number">0</span>])</span><br><span class="line">            middle = (length<span class="number">-1</span>)//<span class="number">2</span></span><br><span class="line">            root = TreeNode(nums[middle])</span><br><span class="line">            root.left = sortedArrayToBST(nums[:middle])</span><br><span class="line">            root.right = sortedArrayToBST(nums[middle+<span class="number">1</span>:])</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> sortedArrayToBST(nums)</span><br></pre></td></tr></table></figure><h1 id="二叉搜索树中的插入操作">二叉搜索树中的插入操作</h1><p><a href="https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/" target="_blank" rel="noopener">LeetCode 701. Insert into a Binary Search Tree</a></p><p>给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 保证原始二叉搜索树中不存在新值。</p><p>注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回任意有效的结果。</p><p>例如, <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">给定二叉搜索树:</span><br><span class="line"></span><br><span class="line">        4</span><br><span class="line">       / \</span><br><span class="line">      2   7</span><br><span class="line">     / \</span><br><span class="line">    1   3</span><br><span class="line"></span><br><span class="line">和 插入的值: 5</span><br></pre></td></tr></table></figure></p><p>你可以返回这个二叉搜索树: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     4</span><br><span class="line">   /   \</span><br><span class="line">  2     7</span><br><span class="line"> / \   /</span><br><span class="line">1   3 5</span><br></pre></td></tr></table></figure></p><p>或者这个树也是有效的: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">     5</span><br><span class="line">   /   \</span><br><span class="line">  2     7</span><br><span class="line"> / \   </span><br><span class="line">1   3</span><br><span class="line">     \</span><br><span class="line">      4</span><br></pre></td></tr></table></figure></p><h2 id="方法">方法</h2><p>与根结点比较大小，递归左子树或右子树。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insertIntoBST</span><span class="params">(self, root: TreeNode, val: int)</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> root:</span><br><span class="line">            <span class="keyword">if</span> val &lt; root.val:</span><br><span class="line">                root.left = self.insertIntoBST(root.left, val)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                root.right = self.insertIntoBST(root.right, val)</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> TreeNode(val)</span><br></pre></td></tr></table></figure><h1 id="二叉搜索树中的搜索">二叉搜索树中的搜索</h1><p><a href="https://leetcode-cn.com/problems/search-in-a-binary-search-tree/" target="_blank" rel="noopener">LeetCode 700. Search in a Binary Search Tree</a></p><p>给定二叉搜索树（BST）的根节点和一个值。 你需要在BST中找到节点值等于给定值的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 NULL。</p><p>例如，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">给定二叉搜索树:</span><br><span class="line"></span><br><span class="line">        4</span><br><span class="line">       / \</span><br><span class="line">      2   7</span><br><span class="line">     / \</span><br><span class="line">    1   3</span><br><span class="line"></span><br><span class="line">和值: 2</span><br></pre></td></tr></table></figure><p>你应该返回如下子树: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  2     </span><br><span class="line"> / \   </span><br><span class="line">1   3</span><br></pre></td></tr></table></figure></p><h2 id="方法-1">方法</h2><p>与根结点比较大小，等于则返回，大于小于则 <strong>递归</strong> 左子树或右子树。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"><span class="comment">#    def sortedArrayToBST(self, nums: [int]) -&gt; TreeNode:</span></span><br><span class="line"><span class="comment">#        #层序树的列表转为树结构</span></span><br><span class="line"><span class="comment">#        l=len(nums)</span></span><br><span class="line"><span class="comment">#        nodeLst = []</span></span><br><span class="line"><span class="comment">#        for i in range(l):</span></span><br><span class="line"><span class="comment">#            nodeLst.append(TreeNode(nums[i]))</span></span><br><span class="line"><span class="comment">#        for i in range(l//2-1):</span></span><br><span class="line"><span class="comment">#            nodeLst[i].left = nodeLst[2*i+1]</span></span><br><span class="line"><span class="comment">#            nodeLst[i].right = nodeLst[2*i+2]</span></span><br><span class="line"><span class="comment">#        nodeLst[l//2-1].left = nodeLst[2*(l//2-1)+1]</span></span><br><span class="line"><span class="comment">#        if len(nums)%2 == 1:</span></span><br><span class="line"><span class="comment">#             nodeLst[l//2-2].left = nodeLst[2*(l//2-1)+1]</span></span><br><span class="line"><span class="comment">#        return nodeLst[0]</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#    def BSTTraversal(self,root): #层序输出树的列表</span></span><br><span class="line"><span class="comment">#        a = []</span></span><br><span class="line"><span class="comment">#        L = []</span></span><br><span class="line"><span class="comment">#        L.append(root)</span></span><br><span class="line"><span class="comment">#        while L:</span></span><br><span class="line"><span class="comment">#            if L[0].left is not None:</span></span><br><span class="line"><span class="comment">#                L.append(L[0].left)  </span></span><br><span class="line"><span class="comment">#            if L[0].right is not None:</span></span><br><span class="line"><span class="comment">#                L.append(L[0].right)</span></span><br><span class="line"><span class="comment">#            a.append(L.pop(0).val)</span></span><br><span class="line"><span class="comment">#        return a </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchBST</span><span class="params">(self, root: TreeNode, val: int)</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">if</span> val == root.val:</span><br><span class="line">            <span class="keyword">return</span> root        </span><br><span class="line">        <span class="keyword">if</span> val &lt; root.val:</span><br><span class="line">            <span class="keyword">return</span> self.searchBST(root.left, val)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.searchBST(root.right, val)</span><br></pre></td></tr></table></figure><h1 id="删除二叉搜索树中的节点">删除二叉搜索树中的节点</h1><p><a href="https://leetcode-cn.com/problems/delete-node-in-a-bst/" target="_blank" rel="noopener">LeetCode 450. Delete Node in a BST</a></p><p>给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。</p><p>一般来说，删除节点可分为两个步骤：</p><p>首先找到需要删除的节点； 如果找到了，删除它。 说明： 要求算法时间复杂度为 O(h)，h 为树的高度。</p><p>示例: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">root = [5,3,6,2,4,null,7]</span><br><span class="line">key = 3</span><br><span class="line"></span><br><span class="line">    5</span><br><span class="line">   / \</span><br><span class="line">  3   6</span><br><span class="line"> / \   \</span><br><span class="line">2   4   7</span><br><span class="line"></span><br><span class="line">给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它。</span><br><span class="line"></span><br><span class="line">一个正确的答案是 [5,4,6,2,null,null,7], 如下图所示。</span><br><span class="line"></span><br><span class="line">    5</span><br><span class="line">   / \</span><br><span class="line">  4   6</span><br><span class="line"> /     \</span><br><span class="line">2       7</span><br><span class="line"></span><br><span class="line">另一个正确答案是 [5,2,6,null,4,null,7]。</span><br><span class="line"></span><br><span class="line">    5</span><br><span class="line">   / \</span><br><span class="line">  2   6</span><br><span class="line">   \   \</span><br><span class="line">    4   7</span><br></pre></td></tr></table></figure></p><h2 id="方法-2">方法</h2><ol style="list-style-type: decimal"><li>递归遍历整个树</li><li>找到这个要删除的结点后，如果只有左孩子，或没有孩子，返回左孩子或空</li><li>如果有右孩子，找右子树的最小值，即待删结点的后继，交换两个值。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteNode</span><span class="params">(self, root: TreeNode, key: int)</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">if</span> root.val == key: <span class="comment"># 找到这个结点</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root.right: <span class="comment"># 如果只有左孩子，或没有孩子</span></span><br><span class="line">                <span class="keyword">return</span> root.left</span><br><span class="line">            <span class="keyword">else</span>: <span class="comment"># 如果有右孩子</span></span><br><span class="line">                succ = root.right</span><br><span class="line">                <span class="keyword">while</span> succ.left:<span class="comment"># 找右子树的最小值，即待删结点的后继</span></span><br><span class="line">                    succ = succ.left</span><br><span class="line">                succ.val, root.val = root.val, succ.val <span class="comment">#交换两个值</span></span><br><span class="line">        root.left = self.deleteNode(root.left, key) <span class="comment"># 递归遍历左子树</span></span><br><span class="line">        root.right = self.deleteNode(root.right, key) <span class="comment"># 递归遍历右子树</span></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><h1 id="查找后继节点">查找后继节点</h1><p>查找二叉查找树中某个节点的前驱节点</p><h2 id="思路">思路</h2><ol style="list-style-type: decimal"><li><p>若一个节点有右子树，那么该节点的后继节点是其右子树中val值最小的节点（也就是右子树中所谓的leftMostNode）</p></li><li><p>若一个节点没有右子树，那么判断该节点和其父节点的关系</p><ol style="list-style-type: decimal"><li><p>若该节点是其父节点的左边孩子，那么该节点的后继结点即为其父节点</p></li><li><p>若该节点是其父节点的右边孩子，那么需要沿着其父亲节点一直向树的顶端寻找，直到找到一个节点P，P节点是其父节点Q的左边孩子，那么Q就是该节点的后继节点</p></li></ol></li></ol><h2 id="方法-3">方法</h2><p>写成递归形式，</p><ul><li>当根节点值小于等于p节点值，说明p的后继节点一定在右子树中，<ul><li>所以对右子节点递归调用此函数</li></ul></li><li>如果根节点值大于p节点值，那么有可能根节点就是p的后继节点，或者左子树中的某个节点是p的后继节点，<ul><li>所以先对左子节点递归调用此函数，如果返回空，说明根节点是后继节点，返回即可，如果不为空，则将那个节点返回 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="keyword">None</span></span><br><span class="line">        self.right = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortedArrayToBST</span><span class="params">(self, nums: [int])</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="comment">#层序树的列表转为树结构</span></span><br><span class="line">        l=len(nums)</span><br><span class="line">        nodeLst = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(l):</span><br><span class="line">            nodeLst.append(TreeNode(nums[i]))</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(l//<span class="number">2</span><span class="number">-1</span>):</span><br><span class="line">            nodeLst[i].left = nodeLst[<span class="number">2</span>*i+<span class="number">1</span>]</span><br><span class="line">            nodeLst[i].right = nodeLst[<span class="number">2</span>*i+<span class="number">2</span>]</span><br><span class="line">        nodeLst[l//<span class="number">2</span><span class="number">-1</span>].left = nodeLst[<span class="number">2</span>*(l//<span class="number">2</span><span class="number">-1</span>)+<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> len(nums)%<span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">             nodeLst[l//<span class="number">2</span><span class="number">-2</span>].left = nodeLst[<span class="number">2</span>*(l//<span class="number">2</span><span class="number">-1</span>)+<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> nodeLst[<span class="number">0</span>]    </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchSuccNode</span><span class="params">(self, root: TreeNode, key: int)</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">if</span> root.val &lt;= key: <span class="comment"># 后继在右子树中</span></span><br><span class="line">             <span class="keyword">return</span> self.searchSuccNode(root.right, key)</span><br><span class="line">        <span class="keyword">else</span>: <span class="comment"># 后继就是该结点，或者在该结点的左子树中。</span></span><br><span class="line">            left = self.searchSuccNode(root.left, key)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> left:</span><br><span class="line">                <span class="keyword">return</span> root </span><br><span class="line">            <span class="keyword">else</span>: <span class="keyword">return</span> left</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    root = [<span class="number">4</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>]</span><br><span class="line">    p = <span class="number">5</span></span><br><span class="line">    S = Solution()</span><br><span class="line">    root = S.sortedArrayToBST(root)</span><br><span class="line">    </span><br><span class="line">    r= S.searchSuccNode(root,p) </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> r:</span><br><span class="line">        print(str(p) + <span class="string">'的后继不存在'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(str(p) + <span class="string">'的后继是'</span> + str(r.val)) </span><br><span class="line"><span class="comment">#输出：5的后继是7</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h1 id="查找前驱结点">查找前驱结点</h1><p>查找二叉查找树中某个节点的前驱节点</p><h2 id="思路-1">思路</h2><ol style="list-style-type: decimal"><li><p>若一个节点有左子树，那么该节点的前驱节点是其左子树中val值最大的节点（也就是左子树中所谓的rightMostNode）</p></li><li><p>若一个节点没有左子树，那么判断该节点和其父节点的关系</p><ol style="list-style-type: decimal"><li><p>若该节点是其父节点的右边孩子，那么该节点的前驱结点即为其父节点。</p></li><li><p>若该节点是其父节点的左边孩子，那么需要沿着其父亲节点一直向树的顶端寻找，直到找到一个节点P，P节点是其父节点Q的右边孩子，那么Q就是该节点的前驱节点</p></li></ol></li></ol><h2 id="方法-4">方法</h2><p>方法和查找后继结点相同。只是左右子树比较相反。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="keyword">None</span></span><br><span class="line">        self.right = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortedArrayToBST</span><span class="params">(self, nums: [int])</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="comment">#层序树的列表转为树结构</span></span><br><span class="line">        l=len(nums)</span><br><span class="line">        nodeLst = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(l):</span><br><span class="line">            nodeLst.append(TreeNode(nums[i]))</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(l//<span class="number">2</span><span class="number">-1</span>):</span><br><span class="line">            nodeLst[i].left = nodeLst[<span class="number">2</span>*i+<span class="number">1</span>]</span><br><span class="line">            nodeLst[i].right = nodeLst[<span class="number">2</span>*i+<span class="number">2</span>]</span><br><span class="line">        nodeLst[l//<span class="number">2</span><span class="number">-1</span>].left = nodeLst[<span class="number">2</span>*(l//<span class="number">2</span><span class="number">-1</span>)+<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> len(nums)%<span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">             nodeLst[l//<span class="number">2</span><span class="number">-2</span>].left = nodeLst[<span class="number">2</span>*(l//<span class="number">2</span><span class="number">-1</span>)+<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> nodeLst[<span class="number">0</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchPredecessorNode</span><span class="params">(self, root: TreeNode, key: int)</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">if</span> root.val &gt;= key: <span class="comment"># 前驱在左子树中</span></span><br><span class="line">             <span class="keyword">return</span> self.searchPredecessorNode(root.left, key)</span><br><span class="line">        <span class="keyword">else</span>: <span class="comment"># 后继就是该结点，或者在该结点的左子树中。</span></span><br><span class="line">            right = self.searchPredecessorNode(root.right, key)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> right:</span><br><span class="line">                <span class="keyword">return</span> root </span><br><span class="line">            <span class="keyword">else</span>: <span class="keyword">return</span> right</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    root = [<span class="number">4</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>]</span><br><span class="line">    p = <span class="number">3</span></span><br><span class="line">    S = Solution()</span><br><span class="line">    root = S.sortedArrayToBST(root)</span><br><span class="line">    </span><br><span class="line">    r= S.searchPredecessorNode(root,p) </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> r:</span><br><span class="line">        print(str(p) + <span class="string">'的前驱不存在'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(str(p) + <span class="string">'的前驱是'</span> + str(r.val))</span><br></pre></td></tr></table></figure><h1 id="二叉树的前序遍历">二叉树的前序遍历</h1><p><a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/" target="_blank" rel="noopener">LeetCode 144. Binary Tree Preorder Traversal</a></p><p>给定一个二叉树，返回它的 前序 遍历。</p><p>示例: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,null,2,3]  </span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    /</span><br><span class="line">   3 </span><br><span class="line"></span><br><span class="line">输出: [1,2,3]</span><br></pre></td></tr></table></figure></p><h2 id="方法一用栈从上到下遍历">方法一：用栈从上到下遍历</h2><p>先右孩子入栈，再左孩子入栈。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        stack = [root] <span class="comment"># 用栈来辅助存储</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            node = stack.pop() </span><br><span class="line">            res.append(node.val)</span><br><span class="line">            <span class="keyword">if</span> node.right: stack.append(node.right)</span><br><span class="line">            <span class="keyword">if</span> node.left: stack.append(node.left)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="方法二递归">方法二：递归</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(root, res)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> root:</span><br><span class="line">                res.append(root.val)</span><br><span class="line">                dfs(root.left, res)</span><br><span class="line">                dfs(root.right, res)</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        <span class="keyword">return</span> dfs(root,res)</span><br></pre></td></tr></table></figure><h2 id="方法三用栈迭代">方法三：用栈迭代</h2><p>从根节点開始，一直找它的左子树，直到为空，再找右子树。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        stack = [] <span class="comment"># 用栈来辅助存储</span></span><br><span class="line">        res = []</span><br><span class="line">        cur = root</span><br><span class="line">        <span class="keyword">while</span> stack <span class="keyword">or</span> cur:</span><br><span class="line">            <span class="keyword">while</span> cur: <span class="comment">#从根节点開始，一直找它的左子树，直到cur为空</span></span><br><span class="line">                stack.append(cur) <span class="comment"># 栈中存入根节点和左孩子</span></span><br><span class="line">                res.append(cur.val)</span><br><span class="line">                cur = cur.left</span><br><span class="line">            cur = stack.pop().right <span class="comment">#找右子树</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p><h1 id="二叉树的中序遍历">二叉树的中序遍历</h1><p><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/" target="_blank" rel="noopener">LeetCode 94. Binary Tree Inorder Traversal</a></p><p>给定一个二叉树，返回它的中序 遍历。</p><p>示例: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,null,2,3]</span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    /</span><br><span class="line">   3</span><br><span class="line"></span><br><span class="line">输出: [1,3,2]</span><br></pre></td></tr></table></figure></p><h2 id="方法一递归">方法一：递归</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">inorder</span><span class="params">(root, res)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> root:                </span><br><span class="line">                inorder(root.left, res)</span><br><span class="line">                res.append(root.val)</span><br><span class="line">                inorder(root.right, res)</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        <span class="keyword">return</span> inorder(root,res)</span><br></pre></td></tr></table></figure><h2 id="方法二用栈迭代">方法二：用栈迭代</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        stack = [] <span class="comment"># 用栈来辅助存储</span></span><br><span class="line">        res = []</span><br><span class="line">        cur = root</span><br><span class="line">        <span class="keyword">while</span> stack <span class="keyword">or</span> cur:</span><br><span class="line">            <span class="keyword">while</span> cur: <span class="comment">#从根节点開始，一直找它的左子树，直到cur为空</span></span><br><span class="line">                stack.append(cur) <span class="comment"># 栈中存入根节点和左孩子                </span></span><br><span class="line">                cur = cur.left</span><br><span class="line">            temp = stack.pop() <span class="comment"># 出栈，则左孩子先出来，然后才是根结点</span></span><br><span class="line">            res.append(temp.val)</span><br><span class="line">            cur = temp.right <span class="comment">#找右子树</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h1 id="二叉树的后序遍历">二叉树的后序遍历</h1><p><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/" target="_blank" rel="noopener">LeetCode 145. Binary Tree Postorder Traversal</a></p><p>给定一个二叉树，返回它的 后序 遍历。</p><p>示例: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,null,2,3]  </span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    /</span><br><span class="line">   3 </span><br><span class="line"></span><br><span class="line">输出: [3,2,1]</span><br></pre></td></tr></table></figure></p><h2 id="方法一递归-1">方法一：递归</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">postorder</span><span class="params">(root, res)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> root:                </span><br><span class="line">                postorder(root.left, res)</span><br><span class="line">                postorder(root.right, res)</span><br><span class="line">                res.append(root.val)</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        <span class="keyword">return</span> postorder(root,res)</span><br></pre></td></tr></table></figure><h2 id="方法二迭代">方法二：迭代</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        stack = [] <span class="comment"># 用栈来辅助存储</span></span><br><span class="line">        res = []</span><br><span class="line">        cur = root</span><br><span class="line">        <span class="keyword">while</span> stack <span class="keyword">or</span> cur:</span><br><span class="line">            <span class="keyword">while</span> cur: <span class="comment">#从根节点開始，一直找它的左子树，直到cur为空</span></span><br><span class="line">                stack.append(cur) <span class="comment"># 栈中存入根节点和右孩子</span></span><br><span class="line">                res.append(cur.val)</span><br><span class="line">                cur = cur.right</span><br><span class="line">            cur = stack.pop().left <span class="comment">#找左子树</span></span><br><span class="line">        <span class="keyword">return</span> res[::<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h1 id="二叉树的层次遍历">二叉树的层次遍历</h1><p><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener">LeetCode 102. Binary Tree Level Order Traversal</a></p><p>给定一个二叉树，返回其按层次遍历的节点值。 （即逐层地，从左到右访问所有节点）。</p><p>例如: 给定二叉树: [3,9,20,null,null,15,7], <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure></p><p>返回其层次遍历结果： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [9,20],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><h2 id="方法一-广度优先搜索bfs">方法一： 广度优先搜索（BFS）</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span><span class="params">(self, root: TreeNode)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        res = []</span><br><span class="line">        currLevel = [root]</span><br><span class="line">        <span class="keyword">while</span> currLevel:</span><br><span class="line">            res.append([node.val <span class="keyword">for</span> node <span class="keyword">in</span> currLevel])</span><br><span class="line">            nextLevel = []</span><br><span class="line">            <span class="keyword">for</span> node <span class="keyword">in</span> currLevel:</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    nextLevel.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    nextLevel.append(node.right)</span><br><span class="line">            currLevel = nextLevel</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="方法二深度优先搜索dfs">方法二：深度优先搜索（DFS）</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span><span class="params">(self, root: TreeNode)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(root, depth, res)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span> res</span><br><span class="line">            <span class="keyword">if</span> len(res) &lt;= depth:</span><br><span class="line">                res.append([])</span><br><span class="line">            res[depth].append(root.val)</span><br><span class="line">            dfs(root.left, depth+<span class="number">1</span>,res)</span><br><span class="line">            dfs(root.right,depth+<span class="number">1</span>,res)</span><br><span class="line">        res = []</span><br><span class="line">        dfs(root,<span class="number">0</span>,res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h1 id="二叉树的锯齿形层次遍历">二叉树的锯齿形层次遍历</h1><p><a href="https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/" target="_blank" rel="noopener">LeetCode 103. Binary Tree Zigzag Level Order Traversal</a></p><p>给定一个二叉树，返回其节点值的锯齿形层次遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</p><p>例如： 给定二叉树 [3,9,20,null,null,15,7], <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure></p><p>返回锯齿形层次遍历如下： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [20,9],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><h2 id="方法-5">方法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">zigzagLevelOrder</span><span class="params">(self, root: TreeNode)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(root, depth, res)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span> res</span><br><span class="line">            <span class="keyword">if</span> len(res) &lt;= depth:</span><br><span class="line">                res.append([])</span><br><span class="line">            <span class="keyword">if</span> depth % <span class="number">2</span> == <span class="number">0</span>: </span><br><span class="line">                res[depth].append(root.val)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res[depth].insert(<span class="number">0</span>, root.val)</span><br><span class="line">            dfs(root.left, depth+<span class="number">1</span>,res)</span><br><span class="line">            dfs(root.right,depth+<span class="number">1</span>,res)</span><br><span class="line">        res = []</span><br><span class="line">        dfs(root,<span class="number">0</span>,res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h1 id="验证二叉搜索树">验证二叉搜索树</h1><p><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/" target="_blank" rel="noopener">LeetCode 98. Validate Binary Search Tree</a></p><p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p><p>假设一个二叉搜索树具有如下特征：</p><p>节点的左子树只包含小于当前节点的数。 节点的右子树只包含大于当前节点的数。 所有左子树和右子树自身必须也是二叉搜索树。 示例 1: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">    2</span><br><span class="line">   / \</span><br><span class="line">  1   3</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure></p><p>示例 2: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">    5</span><br><span class="line">   / \</span><br><span class="line">  1   4</span><br><span class="line">     / \</span><br><span class="line">    3   6</span><br><span class="line">输出: false</span><br><span class="line">解释: 输入为: [5,1,4,null,null,3,6]。</span><br><span class="line">     根节点的值为 5 ，但是其右子节点值为 4 。</span><br></pre></td></tr></table></figure></p><h2 id="方法一中序遍历">方法一：中序遍历</h2><p>中序遍历按照 左孩子－根节点－右孩子 这个顺序遍历，如果每个子树都满足左孩子<根节点<右孩子，那就应该是个bst吧。 <figure="" class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValidBST</span><span class="params">(self, root: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">inorder</span><span class="params">(root, res)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> root:                </span><br><span class="line">                inorder(root.left, res)</span><br><span class="line">                res.append(root.val)</span><br><span class="line">                inorder(root.right, res)</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        inorder(root,res)</span><br><span class="line">        <span class="keyword">return</span> res == sorted(res) <span class="keyword">and</span> len(res) == len(set(res))</span><br></pre></td></tr></table></根节点<右孩子，那就应该是个bst吧。></p><h1 id="方法二递归-1">方法二：递归</h1><p>左子树的值要在(min,mid)之间，右子树的值在(mid,max)之间，这个mid值并不是中位数而是当前节点的值。</p><p>定义一个辅助函数， - 要给这个辅助函数传入：当前要判断的节点、当前要判断的这个节点的取值下限和取值上限。 - 然后使用递归即可，每次要计算下一个节点的时候都要根据这个节点是左孩子还是右孩子对其取值的区间进行更新。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValidBST</span><span class="params">(self, root: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">return</span> self.valid(root, float(<span class="string">'-inf'</span>), float(<span class="string">'inf'</span>))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">valid</span><span class="params">(self, root, min, max)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">if</span> root.val &gt;= max <span class="keyword">or</span> root.val &lt;= min:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> self.valid(root.left, min, root.val) <span class="keyword">and</span> self.valid(root.right, root.val, max)</span><br></pre></td></tr></table></figure><h1 id="翻转二叉树">翻转二叉树</h1><p><a href="https://leetcode-cn.com/problems/invert-binary-tree/" target="_blank" rel="noopener">LeetCode 226. Invert Binary Tree</a></p><p>翻转一棵二叉树。</p><p>示例： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line"></span><br><span class="line">     4</span><br><span class="line">   /   \</span><br><span class="line">  2     7</span><br><span class="line"> / \   / \</span><br><span class="line">1   3 6   9</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"></span><br><span class="line">     4</span><br><span class="line">   /   \</span><br><span class="line">  7     2</span><br><span class="line"> / \   / \</span><br><span class="line">9   6 3   1</span><br></pre></td></tr></table></figure></p><h2 id="方法一递归-2">方法一：递归</h2><p>DFS 每次递归交换当前节点的左右子树，同时对左右子树做同样的处理。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">invertTree</span><span class="params">(self, root: TreeNode)</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        temp = root.left</span><br><span class="line">        root.left = self.invertTree(root.right)</span><br><span class="line">        root.right = self.invertTree(temp)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure></p><h2 id="方法二栈">方法二：栈</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">invertTree</span><span class="params">(self, root: TreeNode)</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        stack = [root]</span><br><span class="line">        <span class="keyword">while</span> len(stack) != <span class="number">0</span>:</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            node.left, node.right = node.right, node.left</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                stack.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                stack.append(node.right)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><h1 id="二叉树的最大深度">二叉树的最大深度</h1><p><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noopener">LeetCode 104. Maximum Depth of Binary Tree</a></p><p>给定一个二叉树，找出其最大深度。</p><p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p><p>说明: 叶子节点是指没有子节点的节点。</p><p>示例： 给定二叉树 [3,9,20,null,null,15,7]， <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure></p><p>返回它的最大深度 3 。</p><h2 id="方法一深度优先搜索">方法一：深度优先搜索</h2><p>深度优先搜索（DFS），递归求解。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + max(self.maxDepth(root.left), self.maxDepth(root.right))</span><br></pre></td></tr></table></figure></p><h2 id="方法二广度优先搜索">方法二：广度优先搜索</h2><p>广度优先搜索（BFS），利用队列求解。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        depth = <span class="number">0</span></span><br><span class="line">        q = [root]</span><br><span class="line">        <span class="keyword">while</span> len(q) != <span class="number">0</span>:</span><br><span class="line">            depth += <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(q)):</span><br><span class="line">                <span class="keyword">if</span> q[<span class="number">0</span>].left:</span><br><span class="line">                    q.append(q[<span class="number">0</span>].left)</span><br><span class="line">                <span class="keyword">if</span> q[<span class="number">0</span>].right:</span><br><span class="line">                    q.append(q[<span class="number">0</span>].right)</span><br><span class="line">                <span class="keyword">del</span> q[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">return</span> depth</span><br></pre></td></tr></table></figure></p><h1 id="路径总和">路径总和</h1><p><a href="https://leetcode-cn.com/problems/path-sum/" target="_blank" rel="noopener">LeetCode 112. Path Sum</a></p><p>给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。</p><p>说明: 叶子节点是指没有子节点的节点。</p><p>示例: 给定如下二叉树，以及目标和 sum = 22， <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">      5</span><br><span class="line">     / \</span><br><span class="line">    4   8</span><br><span class="line">   /   / \</span><br><span class="line">  11  13  4</span><br><span class="line"> /  \      \</span><br><span class="line">7    2      1</span><br></pre></td></tr></table></figure></p><p>返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5-&gt;4-&gt;11-&gt;2。</p><h2 id="方法一dfs-递归">方法一：DFS + 递归</h2><p>用深度优先搜索（DFS）遍历所有可能的从根到叶的路径，要注意每深一层要从和中减去相应节点的数值。下面是递归实现的代码。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasPathSum</span><span class="params">(self, root: TreeNode, sum: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">if</span> root.left <span class="keyword">or</span> root.right:</span><br><span class="line">            <span class="keyword">return</span> self.hasPathSum(root.left, sum-root.val) <span class="keyword">or</span> self.hasPathSum(root.right, sum-root.val)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span> <span class="keyword">if</span> sum == root.val <span class="keyword">else</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure></p><h2 id="方法二dfs-栈">方法二：DFS + 栈</h2><p>DFS的非递归实现，用栈实现。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasPathSum</span><span class="params">(self, root: TreeNode, sum: int)</span> -&gt; bool:</span></span><br><span class="line">        stack = [(root, sum)]</span><br><span class="line">        <span class="keyword">while</span> len(stack) != <span class="number">0</span>:</span><br><span class="line">            node, tmp_sum = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> node:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> node.left <span class="keyword">and</span> <span class="keyword">not</span> node.right <span class="keyword">and</span> node.val == tmp_sum:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">                stack.append((node.right, tmp_sum-node.val))</span><br><span class="line">                stack.append((node.left, tmp_sum-node.val))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure></p><h2 id="方法三bfs-队列">方法三：BFS + 队列</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasPathSum</span><span class="params">(self, root: TreeNode, sum: int)</span> -&gt; bool:</span></span><br><span class="line">        queue = [(root, sum)]</span><br><span class="line">        <span class="keyword">while</span> len(queue) != <span class="number">0</span>:</span><br><span class="line">            node, tmp_sum = queue.pop()</span><br><span class="line">            <span class="keyword">if</span> node:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> node.left <span class="keyword">and</span> <span class="keyword">not</span> node.right <span class="keyword">and</span> node.val == tmp_sum:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">                queue.insert(<span class="number">0</span>, (node.right, tmp_sum-node.val))</span><br><span class="line">                queue.insert(<span class="number">0</span>, (node.left, tmp_sum-node.val))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure><h2 id="方法四后序遍历-栈">方法四：后序遍历 + 栈</h2><p>直接将路径保存在栈中，每次进入不同的层不需要记录当前的和 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasPathSum</span><span class="params">(self, root: TreeNode, sum: int)</span> -&gt; bool:</span></span><br><span class="line">        pre, cur = <span class="keyword">None</span>, root</span><br><span class="line">        tmp_sum = <span class="number">0</span></span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">or</span> len(stack) &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">while</span> cur:</span><br><span class="line">                stack.append(cur)</span><br><span class="line">                tmp_sum += cur.val</span><br><span class="line">                cur = cur.left   <span class="comment"># 最左子树</span></span><br><span class="line">            cur = stack[<span class="number">-1</span>]</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> cur.left <span class="keyword">and</span> <span class="keyword">not</span> cur.right <span class="keyword">and</span> tmp_sum == sum:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">if</span> cur.right <span class="keyword">and</span> pre != cur.right:</span><br><span class="line">                cur = cur.right <span class="comment"># 右子树</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pre = cur</span><br><span class="line">                stack.pop()  <span class="comment"># 左子树</span></span><br><span class="line">                tmp_sum -= cur.val</span><br><span class="line">                cur = <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure></p><h1 id="参考">参考</h1><ul><li>《Problem Solving with Algorithms and Data Structures using Python》</li><li><a href="http://www.cnblogs.com/grandyang/p/5306162.html" target="_blank" rel="noopener">[LeetCode] Inorder Successor in BST 二叉搜索树中的中序后继节点</a></li><li><a href="https://blog.csdn.net/coder_orz/article/details/51383933" target="_blank" rel="noopener">226. Invert Binary Tree [easy] (Python)</a></li><li><a href="https://blog.csdn.net/coder_orz/article/details/51595815" target="_blank" rel="noopener">112. Path Sum [easy] (Python)</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python实现数据结构之字符串</title>
      <link href="/2019/03/08/python%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2019/03/08/python%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<p>学习目标：</p><ul><li>实现一个字符集，只包含 a～z 这 26 个英文字母的 Trie 树</li><li>实现朴素的字符串匹配算法</li><li>LeetCode 344. 反转字符串</li><li>LeetCode 151. 翻转字符串里的单词</li><li>LeetCode 8. 字符串转换整数 (atoi)</li></ul><a id="more"></a><h1 id="leetcode-208.-实现-trie-前缀树">LeetCode 208. 实现 Trie (前缀树)</h1><p>实现一个 Trie (前缀树)，包含 insert, search, 和 startsWith 这三个操作。</p><p>示例: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Trie trie = new Trie();</span><br><span class="line"></span><br><span class="line">trie.insert(&quot;apple&quot;);</span><br><span class="line">trie.search(&quot;apple&quot;);   // 返回 true</span><br><span class="line">trie.search(&quot;app&quot;);     // 返回 false</span><br><span class="line">trie.startsWith(&quot;app&quot;); // 返回 true</span><br><span class="line">trie.insert(&quot;app&quot;);   </span><br><span class="line">trie.search(&quot;app&quot;);     // 返回 true</span><br></pre></td></tr></table></figure></p><p>说明:</p><p>你可以假设所有的输入都是由小写字母 a-z 构成的。</p><p>保证所有输入均为非空字符串。</p><h2 id="方法">方法</h2><p>trie，又称前缀树或字典树，是一种有序树，用于保存关联数组，其中的键通常是字符串。</p><p>一个节点的所有子孙都有相同的前缀，也就是这个节点对应的字符串，而根节点对应空字符串。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.isEnd = <span class="keyword">False</span>  <span class="comment"># 判断是否是词尾</span></span><br><span class="line">        self.children = dict() <span class="comment">#子结点</span></span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Initialize your data structure here.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.root = TrieNode()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, word: str)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Inserts a word into the trie.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        currNode = self.root</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> word:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> currNode.children:</span><br><span class="line">                currNode.children[i] = TrieNode()</span><br><span class="line">            currNode = currNode.children[i]</span><br><span class="line">        currNode.isEnd = <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, word: str)</span> -&gt; bool:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Returns if the word is in the trie.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        currNode = self.root </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> word:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> currNode.children:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            currNode = currNode.children[i]</span><br><span class="line">        <span class="keyword">return</span> currNode.isEnd</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">startsWith</span><span class="params">(self, prefix: str)</span> -&gt; bool:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Returns if there is any word in the trie that starts with the given prefix.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        currNode = self.root</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> prefix:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> currNode.children:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            currNode = currNode.children[i]</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your Trie object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = Trie()</span></span><br><span class="line"><span class="comment"># obj.insert(word)</span></span><br><span class="line"><span class="comment"># param_2 = obj.search(word)</span></span><br><span class="line"><span class="comment"># param_3 = obj.startsWith(prefix)</span></span><br></pre></td></tr></table></figure><h2 id="trie树的优缺点">Trie树的优缺点</h2><p>Trie树的核心思想是空间换时间，利用字符串的公共前缀来减少无谓的字符串比较以达到提高查询效率的目的。</p><p>优点</p><ul><li><p>插入和查询的效率很高，都为O(m)O(m)，其中 mm 是待插入/查询的字符串的长度。</p><ul><li>关于查询，会有人说 hash 表时间复杂度是O(1)O(1)不是更快？但是，哈希搜索的效率通常取决于 hash 函数的好坏，若一个坏的 hash 函数导致很多的冲突，效率并不一定比Trie树高。</li></ul></li><li><p>Trie树中不同的关键字不会产生冲突。</p></li><li><p>Trie树只有在允许一个关键字关联多个值的情况下才有类似hash碰撞发生。</p></li><li><p>Trie树不用求 hash 值，对短字符串有更快的速度。通常，求hash值也是需要遍历字符串的。</p></li><li><p>Trie树可以对关键字按字典序排序。</p></li></ul><p>缺点</p><ul><li>当 hash 函数很好时，Trie树的查找效率会低于哈希搜索。</li></ul><p>空间消耗比较大。</p><h1 id="leetcode-28.-实现strstr">LeetCode 28. 实现strStr()</h1><p><a href="https://leetcode-cn.com/problems/implement-strstr/" target="_blank" rel="noopener">Implement strStr()</a></p><p>实现 strStr() 函数。</p><p>给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回 -1。</p><p>示例 1: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: haystack = &quot;hello&quot;, needle = &quot;ll&quot;</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure></p><p>示例 2: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: haystack = &quot;aaaaa&quot;, needle = &quot;bba&quot;</span><br><span class="line">输出: -1</span><br></pre></td></tr></table></figure></p><p>说明:</p><p>当 needle 是空字符串时我们返回 0 。这与C语言的 strstr() 以及 Java的 indexOf() 定义相符。</p><h2 id="方法内置find函数">方法：内置find()函数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">strStr</span><span class="params">(self, haystack: str, needle: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> haystack.find(needle)</span><br></pre></td></tr></table></figure><h2 id="方法朴素算法">方法：朴素算法</h2><p>字符串匹配算法主要是两类，最基本的暴力解法，也叫做朴素算法，另一种是KMP算法。</p><p>朴素算法是通过一个循环找到所有有效偏移，检查是否满足条件。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">strStr</span><span class="params">(self, haystack: str, needle: str)</span> -&gt; int:</span></span><br><span class="line">        M, N = len(haystack), len(needle)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(M-N+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> haystack[i:i+N] == needle:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure></p><h1 id="leetcode-344.-反转字符串">LeetCode 344. 反转字符串</h1><p><a href="https://leetcode-cn.com/problems/reverse-string/" target="_blank" rel="noopener">反转字符串</a></p><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。</p><p>不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。</p><p>你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。</p><p>示例 1： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]</span><br><span class="line">输出：[&quot;o&quot;,&quot;l&quot;,&quot;l&quot;,&quot;e&quot;,&quot;h&quot;]</span><br></pre></td></tr></table></figure></p><p>示例 2： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[&quot;H&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;h&quot;]</span><br><span class="line">输出：[&quot;h&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;H&quot;]</span><br></pre></td></tr></table></figure></p><h2 id="方法-1">方法</h2><p>依次交换前面和后面的字符直至中间字符，完成反转。 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def reverseString(self, s: List[str]) -&gt; None:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        Do not return anything, modify s in-place instead.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        for i in range(len(s)//2):</span><br><span class="line">            tmp = s[i]</span><br><span class="line">            s[i] = s[len(s)-1-i]</span><br><span class="line">            s[len(s)-1-i] = tmp</span><br></pre></td></tr></table></figure></p><h1 id="leetcode-151.-翻转字符串里的单词">LeetCode 151. 翻转字符串里的单词</h1><p><a href="https://leetcode-cn.com/problems/reverse-words-in-a-string/" target="_blank" rel="noopener">Reverse Words in a String</a></p><p>给定一个字符串，逐个翻转字符串中的每个单词。</p><p>示例 1： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;the sky is blue&quot;</span><br><span class="line">输出: &quot;blue is sky the&quot;</span><br></pre></td></tr></table></figure></p><p>示例 2： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;  hello world!  &quot;</span><br><span class="line">输出: &quot;world! hello&quot;</span><br><span class="line">解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</span><br></pre></td></tr></table></figure></p><p>示例 3： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;a good   example&quot;</span><br><span class="line">输出: &quot;example good a&quot;</span><br><span class="line">解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</span><br></pre></td></tr></table></figure></p><p>说明：</p><ul><li>无空格字符构成一个单词。</li><li>输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</li><li>如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</li></ul><h2 id="方法-2">方法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseWords</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        lst = s.split()</span><br><span class="line">        lst.reverse()</span><br><span class="line">        <span class="keyword">return</span> <span class="string">" "</span>.join(lst)</span><br></pre></td></tr></table></figure><h1 id="leetcode-8.-字符串转换整数-atoi">LeetCode 8. 字符串转换整数 (atoi)</h1><p><a href="https://leetcode-cn.com/problems/string-to-integer-atoi/" target="_blank" rel="noopener">字符串转换整数 (atoi)</a></p><p>请你来实现一个 atoi 函数，使其能将字符串转换成整数。</p><p>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。</p><p>当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。</p><p>该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。</p><p>注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。</p><p>在任何情况下，若函数不能进行有效的转换时，请返回 0。</p><p>说明：假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 <span class="math inline">\([−2^{31}, 2^{31} − 1]\)</span>。如果数值超过这个范围，qing返回 INT_MAX<span class="math inline">\((2^{31} − 1)\)</span> 或 INT_MIN <span class="math inline">\((−2^{31})\)</span> 。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;42&quot;</span><br><span class="line">输出: 42</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;   -42&quot;</span><br><span class="line">输出: -42</span><br><span class="line">解释: 第一个非空白字符为 &apos;-&apos;, 它是一个负号。</span><br><span class="line">     我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;4193 with words&quot;</span><br><span class="line">输出: 4193</span><br><span class="line">解释: 转换截止于数字 &apos;3&apos; ，因为它的下一个字符不为数字。</span><br></pre></td></tr></table></figure></p><p><strong>示例 4:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;words and 987&quot;</span><br><span class="line">输出: 0</span><br><span class="line">解释: 第一个非空字符是 &apos;w&apos;, 但它不是数字或正、负号。</span><br><span class="line">     因此无法执行有效的转换。</span><br></pre></td></tr></table></figure><p><strong>示例 5:</strong> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;-91283472332&quot;</span><br><span class="line">输出: -2147483648</span><br><span class="line">解释: 数字 &quot;-91283472332&quot; 超过 32 位有符号整数范围。 </span><br><span class="line">     因此返回 INT_MIN (−231) 。</span><br></pre></td></tr></table></figure></p><h2 id="方法一按条件多次判断">方法一：按条件多次判断</h2><p>按题目要求进行如下处理和判断： 1. strip()去掉首位空格字符 2. 如果字符串为空，返回0 3. 判断首字符是否为正负号 4. 遍历每个字符，若在0-9范围内，则加入数字中；否则break。 5. 乘上正负号之后，判断数字是否越界。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">myAtoi</span><span class="params">(self, str)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type str: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span>        </span><br><span class="line">        str = str.strip()</span><br><span class="line">        number, flag = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> str:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> str[<span class="number">0</span>] == <span class="string">'-'</span> <span class="keyword">and</span> len(str)&gt;<span class="number">1</span>:</span><br><span class="line">            str = str[<span class="number">1</span>:]</span><br><span class="line">            flag = <span class="number">-1</span></span><br><span class="line">        <span class="keyword">elif</span> str[<span class="number">0</span>] == <span class="string">'+'</span> <span class="keyword">and</span> len(str)&gt;<span class="number">1</span>:</span><br><span class="line">            str = str[<span class="number">1</span>:]</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> str:</span><br><span class="line">            <span class="keyword">if</span> c &gt;= <span class="string">'0'</span> <span class="keyword">and</span> c &lt;= <span class="string">'9'</span>:</span><br><span class="line">                number = <span class="number">10</span>*number + ord(c) - ord(<span class="string">'0'</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        number = flag * number</span><br><span class="line">        number = number <span class="keyword">if</span> number &lt;= <span class="number">2</span>**<span class="number">31</span><span class="number">-1</span> <span class="keyword">else</span> <span class="number">2</span>**<span class="number">31</span><span class="number">-1</span></span><br><span class="line">        number = number <span class="keyword">if</span> number &gt;= <span class="number">-2</span>**<span class="number">31</span> <span class="keyword">else</span> <span class="number">-2</span>**<span class="number">31</span></span><br><span class="line">        <span class="keyword">return</span> number</span><br></pre></td></tr></table></figure><h2 id="方法二正则匹配">方法二：正则匹配</h2><p>用正则表达式来匹配 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">myAtoi</span><span class="params">(self, str)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type str: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 导入正则模块</span></span><br><span class="line">        <span class="keyword">import</span> re</span><br><span class="line">        <span class="comment"># 字符串中查找全部符合条件的整数，返回的是列表，第一个参数是正则，第二个参数是字符串</span></span><br><span class="line">        ret = re.findall(<span class="string">r"^[-+]?\d+"</span>, str.strip())  <span class="comment"># strip()字符串去空格</span></span><br><span class="line">        <span class="comment"># 判断是否有匹配的值，没有的话返回0，例如"word values 987"，匹配不到，返回0</span></span><br><span class="line">        <span class="keyword">if</span> ret:</span><br><span class="line">            ret_str = ret[<span class="number">0</span>]  <span class="comment"># 匹配的数字的字符串</span></span><br><span class="line">            ret_str2 = <span class="string">""</span>  <span class="comment"># 记录去符号的字符串，ret_str后面还要使用，所以定义一个新的变量记录</span></span><br><span class="line">            <span class="comment"># 判断是否带有符号 + or -</span></span><br><span class="line">            <span class="keyword">if</span> ret_str[<span class="number">0</span>] == <span class="string">"-"</span> <span class="keyword">or</span> ret_str[<span class="number">0</span>] == <span class="string">"+"</span>:</span><br><span class="line">                ret_str2 = ret_str[<span class="number">1</span>:]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ret_str2 = ret_str</span><br><span class="line">            <span class="comment"># str转int</span></span><br><span class="line">            ret_int = int(ret_str2)</span><br><span class="line">            <span class="comment"># 判断第一个字符是否为负号</span></span><br><span class="line">            <span class="keyword">if</span> ret_str[<span class="number">0</span>] == <span class="string">"-"</span>:</span><br><span class="line">                <span class="comment"># 三目运算符，判断是否溢出</span></span><br><span class="line">                <span class="comment"># 如果ret_int &lt;= 2**31则返回-ret_int，否则返回-2**31</span></span><br><span class="line">                <span class="keyword">return</span> -ret_int <span class="keyword">if</span> ret_int &lt;= <span class="number">2</span>**<span class="number">31</span> <span class="keyword">else</span> <span class="number">-2</span>**<span class="number">31</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> ret_int <span class="keyword">if</span> ret_int &lt; <span class="number">2</span>**<span class="number">31</span> <span class="keyword">else</span> <span class="number">2</span>**<span class="number">31</span><span class="number">-1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></p><p>比方法一的执行时间短</p><h1 id="参考">参考</h1><ul><li><a href="https://blog.csdn.net/lisonglisonglisong/article/details/45584721" target="_blank" rel="noopener">Trie树（Prefix Tree）介绍</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python实现数据结构之哈希表</title>
      <link href="/2019/03/07/python%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
      <url>/2019/03/07/python%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E5%93%88%E5%B8%8C%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p>散列表（Hash table，也叫哈希表），是根据键（Key）而直接访问在内存存储位置的数据结构。</p><p>具体方法是：</p><ol style="list-style-type: decimal"><li>选定一个整数的下标范围（通常以 0 或 1 开始)，建立一个包括相应元素位置范围的顺序表。</li><li>选定一个从实际关键码集合到上述下标范围的适当映射 h<ul><li>在需要存入关键码为 key 的数据时，将其存入表中第 h(key) 个位置。</li><li>遇到以 key 为关键码检索数据时，直接去找表中第 h(key) 个位置的元素。</li></ul></li></ol><p>这个 h 称为散列函数， 也常被称为哈希（hash)函数或杂凑函数，它就是从可能的关键码集合到一个整数区间（下标区间）的映射。</p><p>学习目标：</p><ul><li>实现一个基于链表法解决冲突问题的散列表</li><li>实现一个 LRU 缓存淘汰算法</li><li>LeetCode 1. 两数之和</li><li>LeetCode 202. Happy Number</li></ul><a id="more"></a><h1 id="实现一个基于链表法解决冲突问题的散列表">实现一个基于链表法解决冲突问题的散列表</h1><p>在存储数据的过程中，如果发生冲突，可以利用链表在已有数据的后面插入新数据来解决冲突。这种方法被称为“链地址法”。</p><p>在哈希表中，我们可以利用哈希函数快速访问到数组中的目标数据。如果发生哈希冲突，就使用链表进行存储。这样一来，不管数据量为多少，我们都能够灵活应对。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HashTable</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.size = <span class="number">11</span> <span class="comment">#容量自定，但必须是素数</span></span><br><span class="line">        self.hash_table = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(self.size)] <span class="comment"># 存放keys-values</span></span><br><span class="line">        <span class="comment"># list中的list是同一个位置的元素集合</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self,key,value)</span>:</span></span><br><span class="line">        hash_value =hash(key)%self.size  <span class="comment">#哈希函数</span></span><br><span class="line">        key_exists = <span class="keyword">False</span> </span><br><span class="line">        bucket = self.hash_table[hash_value]</span><br><span class="line">        <span class="keyword">for</span> i, kv <span class="keyword">in</span> enumerate(bucket):</span><br><span class="line">            k, v = kv</span><br><span class="line">            <span class="keyword">if</span> key == k:</span><br><span class="line">                key_exists = <span class="keyword">True</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> key_exists:</span><br><span class="line">            bucket[i] = ((key,value))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            bucket.append((key,value))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        hash_value = hash(key)%self.size  <span class="comment">#哈希函数   </span></span><br><span class="line">        bucket = self.hash_table[hash_value]</span><br><span class="line">        <span class="keyword">for</span> i, kv <span class="keyword">in</span> enumerate(bucket):</span><br><span class="line">            k, v = kv</span><br><span class="line">            <span class="keyword">if</span> key == k:</span><br><span class="line">                <span class="keyword">return</span> v</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        hash_value = hash(key)%self.size  <span class="comment">#哈希函数       </span></span><br><span class="line">        key_exists = <span class="keyword">False</span></span><br><span class="line">        bucket = self.hash_table[hash_value]</span><br><span class="line">        <span class="keyword">for</span> i, kv <span class="keyword">in</span> enumerate(bucket):</span><br><span class="line">            k, v = kv </span><br><span class="line">            <span class="keyword">if</span> key == k:</span><br><span class="line">                key_exists = <span class="keyword">True</span> </span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> key_exists:</span><br><span class="line">            <span class="keyword">del</span> bucket[i]</span><br><span class="line">            <span class="keyword">return</span> v</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"> </span><br><span class="line">           </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:           </span><br><span class="line">    H=HashTable()</span><br><span class="line">    H.insert(<span class="number">2</span>,<span class="string">"lion"</span>)</span><br><span class="line">    H.insert(<span class="number">10</span>,<span class="string">"cat"</span>)</span><br><span class="line">    H.insert(<span class="number">25</span>,<span class="string">"dog"</span>)</span><br><span class="line">    print(H.hash_table) <span class="comment"># 输出</span></span><br><span class="line">    H.insert(<span class="number">10</span>,<span class="string">"kitty"</span>)</span><br><span class="line">    H.insert(<span class="number">21</span>,<span class="string">"tiger"</span>)</span><br><span class="line">    print(H.hash_table) <span class="comment"># 输出</span></span><br><span class="line">    print(<span class="string">"查找10的值为"</span>+ H.search(<span class="number">10</span>))</span><br><span class="line">    print(<span class="string">"删除10，值为"</span> + H.delete(<span class="number">10</span>))</span><br><span class="line">    print(H.hash_table) <span class="comment"># 输出</span></span><br></pre></td></tr></table></figure><p>输出： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[[], [], [(2, &apos;lion&apos;)], [(25, &apos;dog&apos;)], [], [], [], [], [], [], [(10, &apos;cat&apos;)]]</span><br><span class="line">[[], [], [(2, &apos;lion&apos;)], [(25, &apos;dog&apos;)], [], [], [], [], [], [], [(10, &apos;kitty&apos;), (21, &apos;tiger&apos;)]]</span><br><span class="line">查找10的值为kitty</span><br><span class="line">删除10，值为kitty</span><br><span class="line">[[], [], [(2, &apos;lion&apos;)], [(25, &apos;dog&apos;)], [], [], [], [], [], [], [(21, &apos;tiger&apos;)]]</span><br></pre></td></tr></table></figure></p><p>如果数组的空间太小，使用哈希表的时候就容易发生冲突，线性查找的使用频率也会更高；反过来，如果数组的空间太大，就会出现很多空箱子，造成内存的浪费。因此，给数组设定合适的空间非常重要。</p><h1 id="leetcode-146.-lru缓存机制">LeetCode 146. LRU缓存机制</h1><p><a href="https://leetcode-cn.com/problems/lru-cache/" target="_blank" rel="noopener">LRU Cache</a></p><p>一个用hash表作为底层结构的数据库，当然少不了缓存淘汰算法。当缓存需要被清理时（比如空间占用已经接近临界值了），需要使用某种淘汰算法来决定清理掉哪些数据。</p><p>LRU：Least Recently Used，最近最少使用。判断最近被使用的时间，目前最远的数据优先被淘汰，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高”。</p><p>LRU 算法过程：</p><ol style="list-style-type: decimal"><li>新数据插入到链表头部；</li><li>每当缓存命中（即缓存数据被访问），则将数据移到链表头部；</li><li>当链表满的时候，将链表尾部的数据丢弃。</li></ol><p>这个缓存器主要有两个成员函数，get 和 put。</p><p>其中 get 函数是通过输入 key 来获得 value，如果成功获得后，这对 (key, value) 升至缓存器中最常用的位置（顶部），如果 key 不存在，则返回 -1 。</p><p>而 put 函数是插入一对新的 (key, value)，如果原缓存器中有该 key，则需要先删除掉原有的，将新的插入到缓存器的顶部。如果不存在，则直接插入到顶部。</p><p>若加入新的值后缓存器超过了容量，则需要删掉一个最不常用的值，也就是底部的值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, capacity: int)</span>:</span></span><br><span class="line">        self.cap = capacity <span class="comment"># 容量</span></span><br><span class="line">        self._cache = [] <span class="comment">#缓存</span></span><br><span class="line">        self._cacheMap = &#123;&#125; <span class="comment">#缓存哈希表</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, key: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> self._cacheMap:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        self._cache.remove(key)</span><br><span class="line">        self._cache.append(key)</span><br><span class="line">        <span class="keyword">return</span> self._cacheMap[key]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span><span class="params">(self, key: int, value: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self._cacheMap:</span><br><span class="line">            self._cacheMap[key] = value</span><br><span class="line">            self._cache.remove(key)</span><br><span class="line">            self._cache.append(key)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> len(self._cache) == self.cap:</span><br><span class="line">                x = self._cache.pop(<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">del</span> self._cacheMap[x]</span><br><span class="line">            self._cache.append(key)</span><br><span class="line">            self._cacheMap[key] = value</span><br><span class="line"></span><br><span class="line"><span class="comment"># Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = LRUCache(capacity)</span></span><br><span class="line"><span class="comment"># param_1 = obj.get(key)</span></span><br><span class="line"><span class="comment"># obj.put(key,value)</span></span><br></pre></td></tr></table></figure><h1 id="leetcode-1.-两数之和">LeetCode 1. 两数之和</h1><p><a href="https://leetcode-cn.com/problems/two-sum/" target="_blank" rel="noopener">Two Sum</a> ## 题目描述 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那<strong>两个</strong>整数，并返回他们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p><!-- more --><p><strong>示例:</strong></p><blockquote><p>给定 nums = [2, 7, 11, 15], target = 9</p></blockquote><blockquote><p>因为 nums[0] + nums[1] = 2 + 7 = 9</p></blockquote><blockquote><p>所以返回 [0, 1]</p></blockquote><h2 id="方法哈希表">方法：哈希表</h2><p>利用python中的字典记录记录下每个元素出现的位置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        </span><br><span class="line">        dic = dict()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> index,value <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            sub = target - value</span><br><span class="line">            <span class="keyword">if</span> sub <span class="keyword">in</span> dic:</span><br><span class="line">                <span class="keyword">return</span> [dic[sub], index]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dic[value]=index</span><br></pre></td></tr></table></figure><h1 id="leetcode-202.-happy-number">LeetCode 202. Happy Number</h1><p><a href="https://leetcode-cn.com/problems/happy-number/" target="_blank" rel="noopener">202. 快乐数</a></p><p>编写一个算法来判断一个数是不是“快乐数”。</p><p>一个“快乐数”定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是无限循环但始终变不到 1。如果可以变为 1，那么这个数就是快乐数。</p><p>示例: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: 19</span><br><span class="line">输出: true</span><br><span class="line">解释: </span><br><span class="line">12 + 92 = 82</span><br><span class="line">82 + 22 = 68</span><br><span class="line">62 + 82 = 100</span><br><span class="line">12 + 02 + 02 = 1</span><br></pre></td></tr></table></figure></p><h2 id="方法一">方法一</h2><p>按照“happy number”的定义，直接循环计算各位平方和，观察收敛到1 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isHappy</span><span class="params">(self, n: int)</span> -&gt; bool:</span></span><br><span class="line">        mem = set()</span><br><span class="line">        <span class="keyword">while</span> n!=<span class="number">1</span>:</span><br><span class="line">            n = sum([int(x)*int(x) <span class="keyword">for</span> x <span class="keyword">in</span> list(str(n))])</span><br><span class="line">            <span class="keyword">if</span> n <span class="keyword">in</span> mem:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                mem.add(n)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure></p><h2 id="方法二">方法二</h2><p>先求出100以内的所有happy number， 按照“happy number”的定义，直接循环计算各位平方和，观察收敛到100之内后的数值是否在列表之内。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isHappy</span><span class="params">(self, n: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="comment"># 100以内的happyNumber</span></span><br><span class="line">        happySet = set([<span class="number">1</span>, <span class="number">7</span>, <span class="number">10</span>, <span class="number">13</span>, <span class="number">19</span>, <span class="number">23</span>, <span class="number">28</span>, <span class="number">31</span>, <span class="number">32</span>, <span class="number">44</span>, <span class="number">49</span>, <span class="number">68</span>, <span class="number">70</span>, <span class="number">79</span>, <span class="number">82</span>, <span class="number">86</span>, <span class="number">91</span>, <span class="number">94</span>, <span class="number">97</span>])</span><br><span class="line">        <span class="keyword">while</span> n&gt;<span class="number">99</span>:</span><br><span class="line">            n = sum([int(x)*int(x) <span class="keyword">for</span> x <span class="keyword">in</span> list(str(n))])</span><br><span class="line">        <span class="keyword">return</span> n <span class="keyword">in</span> happySet</span><br></pre></td></tr></table></figure><h1 id="参考">参考</h1><ul><li><a href="https://zhuanlan.zhihu.com/p/34989978" target="_blank" rel="noopener">缓存淘汰算法--LRU算法</a></li><li><a href="http://www.cxyxiaowu.com/posts/f5f29cad/" target="_blank" rel="noopener">看动画理解「链表」实现LRU缓存淘汰算法</a></li><li>《我的第一本算法书》</li><li><a href="http://blog.chapagain.com.np/hash-table-implementation-in-python-data-structures-algorithms/" target="_blank" rel="noopener">Hash Table implementation in Python [Data Structures &amp; Algorithms]</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分查找算法</title>
      <link href="/2019/03/06/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/"/>
      <url>/2019/03/06/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>学习目标：</p><ul><li>实现一个有序数组的二分查找算法</li><li>实现模糊二分查找算法<ul><li>大于给定值的第一个元素</li></ul></li><li>LeetCode 69. x 的平方根</li><li>LeetCode 35. 搜索插入位置</li></ul><a id="more"></a><h1 id="二分查找">二分查找</h1><p>查找和目标值 k 完全相等的数 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">BinarySearch</span><span class="params">(lst,k)</span>:</span></span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    right = len(lst)<span class="number">-1</span></span><br><span class="line">    <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">        mid = (left+right)//<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> lst[mid] &lt; k:</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">elif</span> lst[mid] &gt; k:</span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    lst = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">34</span>,<span class="number">56</span>,<span class="number">57</span>,<span class="number">78</span>,<span class="number">87</span>]</span><br><span class="line">    print(BinarySearch(lst,<span class="number">2</span>))</span><br></pre></td></tr></table></figure></p><h1 id="模糊二分查找">模糊二分查找</h1><p>可能是跟目标值相等的数在数组中并不唯一，而是有多个，那么这种情况下nums[mid] == target这条判断语句就没有必要存在。</p><h2 id="大于给定值的第一个元素">大于给定值的第一个元素</h2><p>查找数组中第一个比 target 大的数的下标。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">searchInsert</span><span class="params">(nums, target)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :type nums: List[int]</span></span><br><span class="line"><span class="string">    :type target: int</span></span><br><span class="line"><span class="string">    :rtype: int</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    </span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    right = len(nums)<span class="number">-1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">        mid = (right+left)//<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] &gt; target:</span><br><span class="line">            right = mid<span class="number">-1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            left = mid+<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> right+<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    lst =[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">8</span>]</span><br><span class="line">    print(searchInsert(lst,<span class="number">5</span>))</span><br></pre></td></tr></table></figure></p><p>输出7</p><p>还可变形为查找最后一个不大于目标值的数。 我们已经找到了第一个大于目标值的数，那么再往前退一位，位置 - 1，就是最后一个不大于目标值的数。比如在数组[0, 1, 1, 1, 1, 5]中查找数字1，就会返回最后一个数字1的位置4。</p><p><code>if nums[mid] &gt; target:</code> 中的'&gt;' 改为 '&gt;='，就能找到<strong>大于等于</strong>给定值的第一个元素。往前退一位，可变形为查找最后一个小于目标值的数。</p><h1 id="leetcode-69.-x-的平方根">LeetCode 69. x 的平方根</h1><p>实现 int sqrt(int x) 函数。</p><p>计算并返回 x 的平方根，其中 x 是非负整数。</p><p>由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。</p><p>示例 1: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 4</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure></p><p>示例 2: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: 8</span><br><span class="line">输出: 2</span><br><span class="line">说明: 8 的平方根是 2.82842..., </span><br><span class="line">     由于返回类型是整数，小数部分将被舍去。</span><br></pre></td></tr></table></figure></p><h2 id="方法二分查找">方法：二分查找</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mySqrt</span><span class="params">(self, x: int)</span> -&gt; int:</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = x</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = (left+right)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> mid * mid &lt; x:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> mid * mid &gt; x:</span><br><span class="line">                right = mid <span class="number">-1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">return</span> left <span class="number">-1</span></span><br></pre></td></tr></table></figure><h1 id="leetcode-35.-搜索插入位置">LeetCode 35. 搜索插入位置</h1><p><a href="https://leetcode-cn.com/problems/search-insert-position/" target="_blank" rel="noopener">Search Insert Position</a></p><h2 id="题目描述">题目描述</h2><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><p>你可以假设数组中无重复元素。</p><p><strong>示例 1:</strong></p><blockquote><p>输入: [1,3,5,6], 5</p></blockquote><blockquote><p>输出: 2</p></blockquote><p><strong>示例 2:</strong></p><blockquote><p>输入: [1,3,5,6], 2</p></blockquote><blockquote><p>输出: 1</p></blockquote><p><strong>示例 3:</strong></p><blockquote><p>输入: [1,3,5,6], 7</p></blockquote><blockquote><p>输出: 4</p></blockquote><h2 id="方法二分查找-1">方法：二分查找</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchInsert</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        </span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = len(nums)<span class="number">-1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = (right-left)/<span class="number">2</span> + left</span><br><span class="line">            <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            <span class="keyword">elif</span> nums[mid] &gt; target:</span><br><span class="line">                right = mid<span class="number">-1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left = mid+<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure><h1 id="leetcode-34.-在排序数组中查找元素的第一个和最后一个位置">LeetCode 34. 在排序数组中查找元素的第一个和最后一个位置</h1><p>给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。</p><p>你的算法时间复杂度必须是 O(log n) 级别。</p><p>如果数组中不存在目标值，返回 [-1, -1]。</p><p>示例 1: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [5,7,7,8,8,10], target = 8</span><br><span class="line">输出: [3,4]</span><br></pre></td></tr></table></figure></p><p>示例 2: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [5,7,7,8,8,10], target = 6</span><br><span class="line">输出: [-1,-1]</span><br></pre></td></tr></table></figure></p><h2 id="方法">方法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchRange</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> [<span class="number">-1</span>,<span class="number">-1</span>]</span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = len(nums)<span class="number">-1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = (right+left)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &gt; target:</span><br><span class="line">                right = mid<span class="number">-1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left = mid+<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> nums[right] != target:</span><br><span class="line">            <span class="keyword">return</span> [<span class="number">-1</span>,<span class="number">-1</span>]</span><br><span class="line">        l = right</span><br><span class="line">        <span class="keyword">while</span> l&gt;<span class="number">0</span> <span class="keyword">and</span> nums[l<span class="number">-1</span>] == target:</span><br><span class="line">            l -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> [l,right]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 二分查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python实现排序算法</title>
      <link href="/2019/03/04/python%E5%AE%9E%E7%8E%B0%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>/2019/03/04/python%E5%AE%9E%E7%8E%B0%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>学习目标：</p><ul><li>实现归并排序、快速排序、插入排序、冒泡排序、选择排序、堆排序</li><li>LeetCode 215. 数组中的第K个最大元素</li></ul><a id="more"></a><h1 id="插入排序">插入排序</h1><p>每次假设前面的元素都是已经排好序了的，然后将当前位置的元素插入到前面已排好序的序列中。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert_sort</span><span class="params">(lst)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> range(<span class="number">1</span>, len(lst)): <span class="comment">#开始时[0,1]已排序</span></span><br><span class="line">        x = lst[index] <span class="comment">#待排序的元素</span></span><br><span class="line">        p = index <span class="comment"># 从位置j往前开始比较</span></span><br><span class="line">        <span class="keyword">while</span> p&gt;<span class="number">0</span> <span class="keyword">and</span> lst[p<span class="number">-1</span>] &gt; x:</span><br><span class="line">            lst[p] = lst[p<span class="number">-1</span>]</span><br><span class="line">            p -= <span class="number">1</span></span><br><span class="line">        lst[p] = x</span><br><span class="line"></span><br><span class="line">lst = [<span class="number">63</span>,<span class="number">21</span>,<span class="number">44</span>,<span class="number">3</span>,<span class="number">67</span>,<span class="number">9</span>,<span class="number">6</span>,<span class="number">86</span>,<span class="number">12</span>]</span><br><span class="line">insert_sort(lst)</span><br><span class="line">print(lst)</span><br></pre></td></tr></table></figure></p><p>空间复杂度是<span class="math inline">\(O(1)\)</span></p><p>平均时间复杂度<span class="math inline">\(O(n^2)\)</span></p><h2 id="二分查找的插入排序">二分查找的插入排序</h2><p>在插人排序中需要检索元素的插人位置， 而且是在排序的(部分)序列里检索。 这提示了另一可能方案： 采用二分查找。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert_sort_binarysearch</span><span class="params">(lst)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> range(<span class="number">1</span>, len(lst)):</span><br><span class="line">        x = lst[index]</span><br><span class="line">        p = index</span><br><span class="line">        low = <span class="number">0</span></span><br><span class="line">        high = index<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> high &gt;= low:</span><br><span class="line">            mid = (high+low)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> lst[mid] &gt; x:</span><br><span class="line">                high = mid<span class="number">-1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                low = mid+<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> p &gt; low:</span><br><span class="line">            lst[p] = lst[p<span class="number">-1</span>]</span><br><span class="line">            p -= <span class="number">1</span></span><br><span class="line">        lst[p] = x</span><br><span class="line"></span><br><span class="line">lst = [<span class="number">63</span>,<span class="number">21</span>,<span class="number">44</span>,<span class="number">3</span>,<span class="number">67</span>,<span class="number">9</span>,<span class="number">6</span>,<span class="number">86</span>,<span class="number">12</span>]</span><br><span class="line">insert_sort_binarysearch(lst)</span><br><span class="line">print(lst)</span><br></pre></td></tr></table></figure></p><p>但这种做法不可能从根本上改变算法的性质： 虽然每次检索位置的代价降低了， 但找到位置后还需要顺序移动元素， 腾出空位将元素插人。 后一操作仍然可能需要线性时间。</p><h1 id="选择排序">选择排序</h1><p>思路： 1. 以空序列作为排序工作的开始， 2. 遍历，每次从剩余未排序的元素中选取最小值， 将其放在已排序的<span class="math inline">\(i\)</span>个元素的后面，作为序列的第<span class="math inline">\(i+ 1\)</span>个元素， 使已排序序列增长。 3. 做到尚未排序的序列里只剩一个元素时（它必然为最大)，只需直接将其放在已排序的记录之后， 整个排序就完成了。</p><p>需要解决两个问题： 第一是如何选择元素； 第二是做出适当安排，尽可能利用现有序列的存储空间，避免另行安排存储。 - 最简单的选择方法是顺序扫描序列中的元素， 记住遇到的最小元素。 一次扫描完毕就找到了一个最小元素。反复扫描就能完成排序工作。 - 选出了一个元素，原来的序列中就出现了一个空位，可以把这些空位集中起来存放排好序的序列。</p><p>在排序过程中的任何时刻， 表的前段积累了一批递增的已经排好序的元素，而且它们都不大于任何一个未排序记录。 下一步从未排序段中选岀最小的元素， 将其存放在已排序元素段的后面(直接交换紧随已排序段的那个位置和最小值)。 这样在只剩一个元素时， 一定最大值， 工作即可结束。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">select_sort</span><span class="params">(lst)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> range(len(lst)<span class="number">-1</span>): <span class="comment">#不需要循环最后一个元素</span></span><br><span class="line">        k = index <span class="comment"># 从index位置开始往后遍历比较找到最小元素</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(index, len(lst)):</span><br><span class="line">            <span class="keyword">if</span> lst[j] &lt; lst[k]:</span><br><span class="line">                k = j</span><br><span class="line">        <span class="keyword">if</span> index != k: <span class="comment"># 确认不是同一个位置</span></span><br><span class="line">            lst[index],lst[k] = lst[k], lst[index] <span class="comment">#交换元素    </span></span><br><span class="line">    </span><br><span class="line">lst = [<span class="number">63</span>,<span class="number">21</span>,<span class="number">44</span>,<span class="number">3</span>,<span class="number">67</span>,<span class="number">9</span>,<span class="number">6</span>,<span class="number">86</span>,<span class="number">12</span>]</span><br><span class="line">select_sort(lst)</span><br><span class="line">print(lst)</span><br></pre></td></tr></table></figure><p>空间复杂度是<span class="math inline">\(O(1)\)</span></p><p>时间复杂度是<span class="math inline">\(O(n^2)\)</span></p><p>选择排序比较低效， 原因就在于其中的顺序比较： 每次选择一个元素， 都是从头开始做一遍完全的比较， 在整个排序过程中做了很多重复比较工作。</p><h1 id="堆排序">堆排序</h1><p>如果在一个连续表里存储的数据是一个小顶堆（ 元素之间的关系满足堆序 )， 按优先队列的操作方式反复弹出堆顶元素， 能够得到一个递增序列。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heap_sort</span><span class="params">(elems)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">siftdown</span><span class="params">(elems,e,begin,end)</span>:</span><span class="comment"># 建立大根堆，排序</span></span><br><span class="line">        i, j = begin, begin*<span class="number">2</span>+<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> j &lt; end:</span><br><span class="line">            <span class="keyword">if</span> j+<span class="number">1</span>&lt;end <span class="keyword">and</span> elems[j+<span class="number">1</span>] &gt; elems[j]:</span><br><span class="line">                j = j+<span class="number">1</span> <span class="comment">#左右子树比较，选择较大的为j</span></span><br><span class="line">            <span class="keyword">if</span> e &gt; elems[j]:</span><br><span class="line">                <span class="keyword">break</span> <span class="comment">#e比左右子树都大，那就不用下移比较了</span></span><br><span class="line">            elems[i] = elems[j]</span><br><span class="line">            i, j = j, j*<span class="number">2</span>+<span class="number">1</span> <span class="comment">#下移</span></span><br><span class="line">        elems[i] = e</span><br><span class="line">    </span><br><span class="line">    end = len(elems)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(end//<span class="number">2</span>,<span class="number">-1</span>,<span class="number">-1</span>):<span class="comment">#建立堆</span></span><br><span class="line">        siftdown(elems,elems[i],i,end)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(end<span class="number">-1</span>, <span class="number">0</span>, <span class="number">-1</span>):<span class="comment">#排序</span></span><br><span class="line">        e = elems[i]</span><br><span class="line">        elems[i] = elems[<span class="number">0</span>]</span><br><span class="line">        siftdown(elems,e,<span class="number">0</span>,i)</span><br><span class="line"> </span><br><span class="line">l=[<span class="number">-1</span>,<span class="number">26</span>,<span class="number">5</span>,<span class="number">77</span>,<span class="number">1</span>,<span class="number">61</span>,<span class="number">11</span>,<span class="number">59</span>,<span class="number">15</span>,<span class="number">48</span>,<span class="number">19</span>] </span><br><span class="line">heap_sort(l)</span><br><span class="line">print(l)</span><br></pre></td></tr></table></figure><p>时间复杂度是<span class="math inline">\(O(nlogn)\)</span></p><h1 id="冒泡排序">冒泡排序</h1><p>冒泡排序就是<strong>重复</strong>“从序列右边开始比较相邻两个数字的大小，再根据结果交换两个数字的位置”<strong>这一操作</strong>的算法。</p><p>每一轮操作（比较和交换）都会有一个最大值移到右端。</p><p>在这个过程中，数字会像泡泡一样，慢慢从左往右“浮”到序列的一端，所以这个算法才被称为“冒泡排序”。</p><p>通过一遍遍扫描，表的最后将积累起越来越多排好顺序的大元素。 每遍扫描，这段元素增加一个，经过 n-1 遍扫描，一定能完成排序。 此外，做一遍，扫描的范围可以缩短一项。 把这些考虑综合起来就得到了下面的算法： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span><span class="params">(lst)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(lst)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,len(lst)-i):</span><br><span class="line">            <span class="keyword">if</span> lst[j<span class="number">-1</span>] &gt; lst[j]:</span><br><span class="line">                lst[j<span class="number">-1</span>],lst[j] = lst[j], lst[j<span class="number">-1</span>]</span><br><span class="line">                </span><br><span class="line"> </span><br><span class="line">l=[<span class="number">-1</span>,<span class="number">26</span>,<span class="number">5</span>,<span class="number">77</span>,<span class="number">1</span>,<span class="number">61</span>,<span class="number">11</span>,<span class="number">59</span>,<span class="number">15</span>,<span class="number">48</span>,<span class="number">19</span>] </span><br><span class="line">bubble_sort(l)</span><br><span class="line">print(l)</span><br></pre></td></tr></table></figure></p><h2 id="改进">改进</h2><p>虽然有时起泡排序确实需要做满 n-1 遍，但那是特例，只有被排序表的最小元素恰好在最后时才会出现这种情况。</p><p>在其他情况下，扫描就不需要做那么多次，如果发现排序已经完成就可以及早结束。</p><p>如果在一次扫描中没遇到逆序，就说明排序工作已经完成， 可以提前结束了。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span><span class="params">(lst)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(lst)):</span><br><span class="line">        found = <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,len(lst)-i):</span><br><span class="line">            <span class="keyword">if</span> lst[j<span class="number">-1</span>] &gt; lst[j]:</span><br><span class="line">                lst[j<span class="number">-1</span>],lst[j] = lst[j], lst[j<span class="number">-1</span>]</span><br><span class="line">                found = <span class="keyword">True</span> <span class="comment">#有逆序</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> found:<span class="comment"># 如果没有逆序</span></span><br><span class="line">            <span class="keyword">break</span> <span class="comment">#可以跳出循环结束了</span></span><br><span class="line"> </span><br><span class="line">l=[<span class="number">-1</span>,<span class="number">26</span>,<span class="number">5</span>,<span class="number">77</span>,<span class="number">1</span>,<span class="number">61</span>,<span class="number">11</span>,<span class="number">59</span>,<span class="number">15</span>,<span class="number">48</span>,<span class="number">19</span>] </span><br><span class="line">bubble_sort(l)</span><br><span class="line">print(l)</span><br></pre></td></tr></table></figure></p><h1 id="归并排序">归并排序</h1><p>归并排序算法会把序列分成长度相同的两个子序列，当无法继续往下分时（也就是每个子序列中只有一个数据时），就对子序列进行归并。归并指的是把两个排好序的子序列合并成一个有序序列。该操作会一直重复执行，直到所有子序列都归并为一个整体为止。</p><p>归并排序中，分割序列所花费的时间不算在运行时间内（可以当作序列本来就是分割好的）。在合并两个已排好序的子序列时，只需重复比较首位数据的大小，然后移动较小的数据，因此只需花费和两个子序列的长度相应的运行时间。</p><p>也就是说，完成一行归并所需的运行时间取决于这一行的数据量。 无论哪一行都是n个数据，所以每行的运行时间都为 O(n)。 而将长度为 n 的序列对半分割直到只有一个数据为止时，可以分成<span class="math inline">\(log_2n\)</span>行，因此，总 共有<span class="math inline">\(log_2n\)</span>行。也就是说，总的运行时间为 O(nlogn)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mergesort</span><span class="params">(lst)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(lst) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> lst</span><br><span class="line">    mid = len(lst)//<span class="number">2</span> <span class="comment"># 将列表分成更小的两个列表</span></span><br><span class="line">    <span class="comment"># 分别对左右两个列表进行处理，分别返回两个排序好的列表</span></span><br><span class="line">    left = mergesort(lst[:mid])</span><br><span class="line">    right = mergesort(lst[mid:])</span><br><span class="line">    <span class="comment"># 对排序好的两个列表合并，产生一个新的排序好的列表</span></span><br><span class="line">    <span class="keyword">return</span> merge(left, right)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(left, right)</span>:</span></span><br><span class="line">    res = []</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 对两个列表中的元素 两两对比。</span></span><br><span class="line">    <span class="comment"># 将最小的元素，放到res中</span></span><br><span class="line">    <span class="keyword">while</span> i&lt;len(left) <span class="keyword">and</span> j&lt;len(right):</span><br><span class="line">        <span class="keyword">if</span> left[i] &lt;= right[j]:</span><br><span class="line">            res.append(left[i])</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            res.append(right[j])</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">    res += left[i:]</span><br><span class="line">    res += right[j:]</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"> </span><br><span class="line">l=[<span class="number">-1</span>,<span class="number">26</span>,<span class="number">5</span>,<span class="number">77</span>,<span class="number">1</span>,<span class="number">61</span>,<span class="number">11</span>,<span class="number">59</span>,<span class="number">15</span>,<span class="number">48</span>,<span class="number">19</span>] </span><br><span class="line">res = mergesort(l)</span><br><span class="line">print(res)</span><br></pre></td></tr></table></figure><h1 id="快速排序">快速排序</h1><p>快速排序算法首先会在序列中随机选择一个基准值（pivot），然后将除了基准值以外的数分为“比基准值小的数”和“比基准值大的数”这两个类别，再将其排列成以下形式。</p><p><code>[ 比基准值小的数 ] 基准值 [ 比基准值大的数 ]</code></p><p>接着，对两个“[ ]”中的数据进行排序之后，整体的排序便完成了。对“[ ]”里面的数据进行排序时同样也会使用快速排序(递归)。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">qsort_rec</span><span class="params">(lst, l, r)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> l&gt;=r:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    i = l</span><br><span class="line">    j = r</span><br><span class="line">    pivot = lst[i]</span><br><span class="line">    <span class="keyword">while</span> i&lt;j: <span class="comment"># 找pivot的最终位置</span></span><br><span class="line">        <span class="keyword">while</span> i&lt;j <span class="keyword">and</span> lst[j]&gt;=pivot:</span><br><span class="line">            j -= <span class="number">1</span> <span class="comment"># 用j向左扫描找小于pivot的记录</span></span><br><span class="line">        <span class="keyword">if</span> i&lt;j:</span><br><span class="line">            lst[i] = lst[j]</span><br><span class="line">            i += <span class="number">1</span> <span class="comment"># 小记录移到左边</span></span><br><span class="line">        <span class="keyword">while</span> i&lt;j <span class="keyword">and</span> lst[i]&lt;pivot:</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> i&lt;j:</span><br><span class="line">            lst[j] = lst[i]</span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">    lst[i] = pivot</span><br><span class="line">    qsort_rec(lst, l, i<span class="number">-1</span>) <span class="comment"># 递归处理左半区间</span></span><br><span class="line">    qsort_rec(lst, i+<span class="number">1</span>, r) <span class="comment"># 递归处理左右半区间</span></span><br><span class="line"> </span><br><span class="line">l=[<span class="number">-1</span>,<span class="number">26</span>,<span class="number">5</span>,<span class="number">77</span>,<span class="number">1</span>,<span class="number">61</span>,<span class="number">11</span>,<span class="number">59</span>,<span class="number">15</span>,<span class="number">48</span>,<span class="number">19</span>] </span><br><span class="line">qsort_rec(l,<span class="number">0</span>,len(l)<span class="number">-1</span>)</span><br><span class="line">print(l)</span><br></pre></td></tr></table></figure><p>时间复杂度<span class="math inline">\(O(nlogn)\)</span></p><h2 id="改进-1">改进</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort1</span><span class="params">(lst)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">qsort</span><span class="params">(lst, begin,end)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> begin &gt;= end:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        pivot = lst[begin]</span><br><span class="line">        i = begin</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(begin+<span class="number">1</span>, end+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> lst[j] &lt; pivot:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                lst[i],lst[j] = lst[j],lst[i]</span><br><span class="line">        lst[begin],lst[i] = lst[i], lst[begin]</span><br><span class="line">        qsort(lst, begin, i<span class="number">-1</span>)</span><br><span class="line">        qsort(lst,i+<span class="number">1</span>, end)</span><br><span class="line">    qsort(lst,<span class="number">0</span>,len(lst)<span class="number">-1</span>)</span><br><span class="line">l=[<span class="number">-1</span>,<span class="number">26</span>,<span class="number">5</span>,<span class="number">77</span>,<span class="number">1</span>,<span class="number">61</span>,<span class="number">11</span>,<span class="number">59</span>,<span class="number">15</span>,<span class="number">48</span>,<span class="number">19</span>] </span><br><span class="line">quick_sort1(l)</span><br><span class="line">print(l)</span><br></pre></td></tr></table></figure><h1 id="leetcode-215.-数组中的第k个最大元素">LeetCode 215. 数组中的第K个最大元素</h1><p>在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</p><p>示例 1: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,2,1,5,6,4] 和 k = 2</span><br><span class="line">输出: 5</span><br></pre></td></tr></table></figure></p><p>示例 2: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,2,3,1,2,4,5,5,6] 和 k = 4</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure></p><p>说明: 你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。</p><h2 id="方法快速排序中选择">方法：快速排序中选择</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthLargest</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; int:</span>    </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">qsort</span><span class="params">(lst, begin,end)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> begin &gt;= end:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            pivot = lst[begin]</span><br><span class="line">            i = begin</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(begin+<span class="number">1</span>, end+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> lst[j] &gt; pivot:</span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">                    lst[i],lst[j] = lst[j],lst[i]</span><br><span class="line">            lst[begin],lst[i] = lst[i], lst[begin]</span><br><span class="line">            <span class="keyword">if</span> i&gt;k<span class="number">-1</span>:</span><br><span class="line">                qsort(lst, begin, i<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">elif</span> i&lt;k<span class="number">-1</span>:</span><br><span class="line">                qsort(lst,i+<span class="number">1</span>, end)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        qsort(nums,<span class="number">0</span>,len(nums)<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> nums[k<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h2 id="方法改进">方法改进</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthLargest</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">        pivot = random.choice(nums)</span><br><span class="line">        nums1, nums2 = [], []</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> num &gt; pivot:</span><br><span class="line">                nums1.append(num)</span><br><span class="line">            <span class="keyword">elif</span> num &lt; pivot:</span><br><span class="line">                nums2.append(num)</span><br><span class="line">        <span class="keyword">if</span> k &lt;= len(nums1):</span><br><span class="line">            <span class="keyword">return</span> self.findKthLargest(nums1, k)</span><br><span class="line">        <span class="keyword">if</span> k &gt; len(nums) - len(nums2):</span><br><span class="line">            <span class="keyword">return</span> self.findKthLargest(nums2, k - (len(nums) - len(nums2)))</span><br><span class="line">        <span class="keyword">return</span> pivot</span><br></pre></td></tr></table></figure><h1 id="参考">参考</h1><ul><li>《数据结构(C++语言版)》</li><li><a href="https://hujiaweibujidao.github.io/blog/2014/05/07/python-data-structures---c2-sort/" target="_blank" rel="noopener">Python Data Structures - C2 Sort</a></li><li><a href="https://www.jianshu.com/p/3ad5373465fd" target="_blank" rel="noopener">python归并排序--递归实现</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>递归(python)</title>
      <link href="/2019/03/02/%E9%80%92%E5%BD%92(python)/"/>
      <url>/2019/03/02/%E9%80%92%E5%BD%92(python)/</url>
      
        <content type="html"><![CDATA[<p>在函数的定义中对这个函数自身的调用，就是递归。</p><p>递归结构中，递归的部分必须比原来的整体简单，才有可能到达某种终结点(出口)。而且必须存在非递归的基本结构构成的部分，否则会无限递归。</p><p>学习目标：</p><ul><li>编程实现斐波那契数列求值 f(n)=f(n-1)+f(n-2)</li><li>编程实现求阶乘 n!</li><li>编程实现一组数据集合的全排列</li><li>LeetCode 70. 爬楼梯</li></ul><p>以上问题都可以用递归来解决。</p><a id="more"></a><h1 id="斐波那契数列求值-fnfn-1fn-2">斐波那契数列求值 f(n)=f(n-1)+f(n-2)</h1><p>斐波那契数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。</p><p>[0,1,1,2,3,5,8,13,...] 给定<code>n</code>,计算 <code>f(N)</code></p><p>对应LeetCode习题：<a href="https://leetcode-cn.com/problems/fibonacci-number/" target="_blank" rel="noopener">509. Fibonacci Number</a></p><h2 id="方法">方法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(self, N: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> N &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> N</span><br><span class="line">        <span class="keyword">return</span> self.fib(N<span class="number">-1</span>) + self.fib(N<span class="number">-2</span>)</span><br></pre></td></tr></table></figure><p>动态规划方法参见：<a href="https://cathy3.github.io/2019/04/05/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" target="_blank" rel="noopener">动态规划</a></p><h1 id="求阶乘-n">求阶乘 n!</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factorial</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> <span class="keyword">or</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> (n*factorial(n<span class="number">-1</span>))</span><br><span class="line"></span><br><span class="line">a = factorial(<span class="number">3</span>)</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure><p>输出：6</p><h1 id="leetcode-46.-全排列">LeetCode 46. 全排列</h1><p><a href="https://leetcode-cn.com/problems/permutations/" target="_blank" rel="noopener">Permutations</a></p><p>给定一个<strong>没有重复</strong>数字的序列，返回其所有可能的全排列。</p><p><strong>示例</strong></p><blockquote><p>输入: [1,2,3]</p></blockquote><blockquote><p>输出: [ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]]</p></blockquote><h2 id="方法-1">方法</h2><p>每次选择一个数出来，然后把剩下的数，再选择一个出来，依次类推，选到头，就回溯到上一层。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permute</span><span class="params">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">        res = []</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(nums = nums, path = [])</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">                res.append(path)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">                dfs(nums[:i]+nums[i+<span class="number">1</span>:], path+[nums[i]])</span><br><span class="line">        dfs()</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p><h1 id="leetcode-47.-全排列-ii">LeetCode 47. 全排列 II</h1><p><a href="https://leetcode-cn.com/problems/permutations-ii/" target="_blank" rel="noopener">Permutations II</a></p><p>给定一个可包含重复数字的序列，返回所有不重复的全排列。</p><p><strong>示例:</strong></p><blockquote><p>输入: [1,1,2]</p></blockquote><blockquote><p>输出: [ [1, 1, 2], [1, 2, 1], [2, 1, 1] ]</p></blockquote><h2 id="方法-2">方法</h2><p>相比上一题，多了排序和内部的重复判断。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permuteUnique</span><span class="params">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        res = []</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(nums = nums, path=[])</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">                res.append(path)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">                <span class="keyword">if</span> i&gt;<span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i<span class="number">-1</span>]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                dfs(nums[:i]+nums[i+<span class="number">1</span>:], path+[nums[i]])</span><br><span class="line">        dfs()</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p><h1 id="leetcode-70.-爬楼梯">LeetCode 70. 爬楼梯</h1><p><a href="https://leetcode-cn.com/problems/climbing-stairs/" target="_blank" rel="noopener">Climbing Stairs</a></p><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p><p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p>注意：给定 n 是一个正整数。</p><p><strong>示例 ：</strong> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入： 3</span><br><span class="line">输出： 3</span><br><span class="line">解释： 有三种方法可以爬到楼顶。</span><br><span class="line">1.  1 阶 + 1 阶 + 1 阶</span><br><span class="line">2.  1 阶 + 2 阶</span><br><span class="line">3.  2 阶 + 1 阶</span><br></pre></td></tr></table></figure></p><h2 id="方法递归">方法：<del>递归</del></h2><p>当有n个台阶时，可供选择的走法可以分两类：1，先跨一阶再跨完剩下n-1阶；2，先跨2阶再跨完剩下n-2阶。所以n阶的不同走法的数目是n-1阶和n-2阶的走法数的和。 这和斐波那契数列的规律相同，可以用这个思路。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> n&lt;=<span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> n </span><br><span class="line">        <span class="keyword">return</span> self.climbStairs(n<span class="number">-1</span>) + self.climbStairs(n<span class="number">-2</span>)</span><br></pre></td></tr></table></figure></p><p>这个方法运行正常，但是因为超出时间限制，未能通过。</p><h2 id="方法动态规划">方法：动态规划</h2><p>动态规划来记录历史数据。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        prev, current = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            prev, current = current, prev + current</span><br><span class="line">        <span class="keyword">return</span> current</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python实现数据结构中的栈</title>
      <link href="/2019/03/01/python%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E6%A0%88/"/>
      <url>/2019/03/01/python%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<p>栈是一种数据呈线性排列的、后入先出（LIFO，last-in-first-out）的数据结构。不过在这种结构中，我们只能访问最新添加的数据。添加移除新项总发生在同一端。这一端通常称为“顶部”。与顶部对应的端称为“底部”。</p><p>栈的底部很重要，因为在栈中靠近底部的项是存储时间最长的。最近添加的项是最先会被移除的。</p><p>对栈的两种主要操作是将一个元素压入栈和将一个元素弹出栈。入栈使用<code>push()</code>方法，出栈使用<code>pop()</code>方法。</p><p>在栈的应用上，比如深度优先搜索算法，通常会选择最新的数据作为候补顶点。在候补顶点的管理上就可以使用栈。</p><p>学习目标： - 用数组实现一个顺序栈 - 用链表实现一个链式栈 - 编程模拟实现一个浏览器的前进、后退功能</p><a id="more"></a><h1 id="用数组实现一个顺序栈">用数组实现一个顺序栈</h1><p>假定数组的结尾作为栈顶，后端插入和删除是 O(1) 操作。</p><p>栈有如下基本操作： - Stack() 创建一个空的新栈。 返回一个空栈。 - push(item)将一个新项添加到栈的顶部。它需要 item 做参数并不返回任何内容。 - pop() 从栈中删除顶部项。它返回 item 。栈被修改。 - top() 从栈返回顶部项，但不会删除它。不修改栈。 - isEmpty() 测试栈是否为空。返回布尔值。 - size() 返回栈中的 item 数量。返回一个整数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SStack</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.items = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isEmpty</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.items == []</span><br><span class="line">        <span class="comment"># return not self.items</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self,item)</span>:</span></span><br><span class="line">        self.items.append(item)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.items.pop()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.items:</span><br><span class="line">            <span class="keyword">return</span> self.items[<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">size</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self.items)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    s = SStack()</span><br><span class="line">    s.push(<span class="string">'a'</span>)</span><br><span class="line">    print(s.top())</span><br><span class="line">    s.push(<span class="string">'b'</span>)</span><br><span class="line">    s.push(<span class="string">'c'</span>)</span><br><span class="line">    print(s.pop())</span><br></pre></td></tr></table></figure><p>输出： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a</span><br><span class="line">c</span><br></pre></td></tr></table></figure></p><p>数组实现的缺点： - 需要完整的大块存储空间 - 扩大存储的操作代价高</p><p>而用链表实现就没有以上的问题。 # 用链表实现一个链式栈 对于链接表，将表头作为栈顶，在前端插入和删除都是 O(1) 操作。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span> <span class="comment"># 链表的结点</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x, next_=None)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = next_</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LStack</span>:</span> <span class="comment">#栈的链接表实现</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._top = <span class="keyword">None</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isEmpty</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._top <span class="keyword">is</span> <span class="keyword">None</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self,item)</span>:</span></span><br><span class="line">        self._top = Node(item, self._top)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        p = self._top</span><br><span class="line">        self._top = p.next</span><br><span class="line">        <span class="keyword">return</span> p.val</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self._top:</span><br><span class="line">            <span class="keyword">return</span> self._top.val</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    s = LStack()</span><br><span class="line">    s.push(<span class="string">'a'</span>)</span><br><span class="line">    print(s.top())</span><br><span class="line">    s.push(<span class="string">'b'</span>)</span><br><span class="line">    s.push(<span class="string">'c'</span>)</span><br><span class="line">    print(s.pop())</span><br></pre></td></tr></table></figure></p><p>输出： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a</span><br><span class="line">c</span><br></pre></td></tr></table></figure></p><h1 id="编程模拟实现一个浏览器的前进后退功能">编程模拟实现一个浏览器的前进、后退功能</h1><p>每个 web 浏览器都有一个返回按钮。当你浏览网页时，这些网页被放置在一个栈中（实际是网页的网址）。你现在查看的网页在顶部，你第一个查看的网页在底部。如果按‘返回’按钮，将按相反的顺序浏览刚才的页面。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Page</span>:</span> <span class="comment"># 一个网页</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, url, prev_=None, next_=None)</span>:</span></span><br><span class="line">        self.val = url</span><br><span class="line">        self.next = next_</span><br><span class="line">        self.prev = prev_</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">History</span>:</span> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span> </span><br><span class="line">        self._cur = Page(<span class="keyword">None</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">loadPage</span><span class="params">(self, newPage)</span>:</span> <span class="comment">#加载新的页面</span></span><br><span class="line">        p = Page(newPage,self._cur,<span class="keyword">None</span>)</span><br><span class="line">        self._cur.next = p</span><br><span class="line">        self._cur = self._cur.next</span><br><span class="line">        <span class="keyword">return</span> self._cur.val</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">back</span><span class="params">(self)</span>:</span> <span class="comment">#返回上一页面</span></span><br><span class="line">        <span class="keyword">if</span> self._cur.prev <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self._cur = self._cur.prev</span><br><span class="line">        <span class="keyword">return</span> self._cur.val</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self)</span>:</span> <span class="comment">#前进页面</span></span><br><span class="line">        <span class="keyword">if</span> self._cur.next <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self._cur = self._cur.next</span><br><span class="line">        <span class="keyword">return</span> self._cur.val</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    h = History()</span><br><span class="line">    print(<span class="string">'加载页面'</span>+ h.loadPage(<span class="string">'a'</span>)) </span><br><span class="line">    print(<span class="string">'加载页面'</span>+ h.loadPage(<span class="string">'b'</span>))</span><br><span class="line">    print(<span class="string">'返回到'</span>+ h.back())       </span><br><span class="line">    print(<span class="string">'加载页面'</span>+ h.loadPage(<span class="string">'c'</span>)) </span><br><span class="line">    print(<span class="string">'返回到'</span>+ h.back())</span><br><span class="line">    print(<span class="string">'前进到'</span>+ h.forward())</span><br></pre></td></tr></table></figure></p><p>输出： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">加载页面a</span><br><span class="line">加载页面b</span><br><span class="line">返回到a</span><br><span class="line">加载页面c</span><br><span class="line">返回到a</span><br><span class="line">前进到c</span><br></pre></td></tr></table></figure></p><h1 id="leetcode-20.-有效的括号">LeetCode 20. 有效的括号</h1><p><a href="https://leetcode-cn.com/problems/valid-parentheses/" target="_blank" rel="noopener">Valid Parentheses</a></p><p>给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。</p><p>有效字符串需满足：</p><ul><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li><li>注意空字符串可被认为是有效字符串。</li></ul><p>示例 1:</p><blockquote><p>输入: &quot;()<span></span>&quot;</p></blockquote><p>输出: true</p><p>示例 2:</p><blockquote><p>输入: &quot;([)]&quot;</p></blockquote><blockquote><p>输出: false</p></blockquote><p>示例 3:</p><blockquote><p>输入: &quot;{[]}&quot;</p></blockquote><blockquote><p>输出: true</p></blockquote><h2 id="方法">方法</h2><ul><li>先建立一个map</li><li>遍历字符串，对输入的字符串入栈操作（如果入栈的元素是key的话）</li><li>依次比较，直到出现不匹配或者栈里所有元素都比较结束(栈空)。</li><li>还要注意这样的问题：如果最后多余了’key‘，比如()<span></span>(，所以最后还要判断一下<code>len(stack)==0</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValid</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        stack = list()</span><br><span class="line">        match = &#123;<span class="string">'&#123;'</span>:<span class="string">'&#125;'</span>, <span class="string">'['</span>:<span class="string">']'</span>, <span class="string">'('</span>:<span class="string">')'</span>&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">in</span> match:</span><br><span class="line">                stack.append(i)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> len(stack) == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> match[stack[<span class="number">-1</span>]] != i:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">                </span><br><span class="line">                stack.pop()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> len(stack) != <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure><h1 id="leetcode-32.-最长有效的括号">LeetCode 32. 最长有效的括号</h1><p><a href="https://leetcode-cn.com/problems/longest-valid-parentheses/" target="_blank" rel="noopener">Longest Valid Parentheses</a></p><p>给定一个只包含 '(' 和 ')' 的字符串，找出最长的包含有效括号的子串的长度。</p><p>示例 1: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;(()&quot;</span><br><span class="line">输出: 2</span><br><span class="line">解释: 最长有效括号子串为 &quot;()&quot;</span><br></pre></td></tr></table></figure></p><p>示例 2: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;)()())&quot;</span><br><span class="line">输出: 4</span><br><span class="line">解释: 最长有效括号子串为 &quot;()()&quot;</span><br></pre></td></tr></table></figure></p><h2 id="方法-1">方法</h2><ul><li>用一个栈来存储左括号的索引.</li><li>遇到正确匹配的括号则弹出匹配的索引，所以栈中存储的是未匹配上的左括号。</li><li>新匹配上的括号位置减去前一段未匹配到的括号的索引的差，是当前有效子串的大小。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestValidParentheses</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        maxlen = <span class="number">0</span>  <span class="comment"># 最长的字串长度</span></span><br><span class="line">        last = <span class="number">-1</span>   <span class="comment"># 上一段有效子串的结尾位置</span></span><br><span class="line">        stack = []  <span class="comment"># 栈里存放左括号的位置序号</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            <span class="keyword">if</span> s[i] == <span class="string">'('</span>:</span><br><span class="line">                stack.append(i) <span class="comment"># 存入左括号的位置序号</span></span><br><span class="line">            <span class="keyword">else</span>:<span class="comment"># 右括号</span></span><br><span class="line">                <span class="keyword">if</span> stack == []: <span class="comment"># 栈空</span></span><br><span class="line">                    last = i <span class="comment"># 配对失败，一段有效子串结尾</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    stack.pop() <span class="comment">#取出配对左括号</span></span><br><span class="line">                    <span class="keyword">if</span> stack == []: <span class="comment"># 配对完，栈空</span></span><br><span class="line">                    <span class="comment">#当前位置i减去上一段结尾last，是这一段有效子串的长度</span></span><br><span class="line">                        maxlen = max(maxlen, i-last) </span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="comment"># stack剩余的左括号未必能配对成功，先比较当前的有效子串</span></span><br><span class="line">                        maxlen= max(maxlen, i - stack[<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">return</span> maxlen</span><br></pre></td></tr></table></figure><h1 id="leetcode-150.-逆波兰表达式求值">LeetCode 150. 逆波兰表达式求值</h1><p><a href="https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/" target="_blank" rel="noopener">Evaluate Reverse Polish Notatio</a></p><p>根据<a href="https://baike.baidu.com/item/%E9%80%86%E6%B3%A2%E5%85%B0%E5%BC%8F/128437" target="_blank" rel="noopener">逆波兰表示法</a>，求表达式的值。</p><p>有效的运算符包括 +, -, *, / 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。</p><p>说明：</p><ul><li>整数除法只保留整数部分。</li><li>给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。</li></ul><p>示例 1： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [&quot;2&quot;, &quot;1&quot;, &quot;+&quot;, &quot;3&quot;, &quot;*&quot;]</span><br><span class="line">输出: 9</span><br><span class="line">解释: ((2 + 1) * 3) = 9</span><br></pre></td></tr></table></figure></p><p>示例 2： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [&quot;4&quot;, &quot;13&quot;, &quot;5&quot;, &quot;/&quot;, &quot;+&quot;]</span><br><span class="line">输出: 6</span><br><span class="line">解释: (4 + (13 / 5)) = 6</span><br></pre></td></tr></table></figure></p><h2 id="方法-2">方法</h2><ul><li>逆波兰式（Reverse Polish notation，RPN，或逆波兰记法），也叫后缀表达式（将运算符写在操作数之后）</li><li>python 有个函数eval()，可以给它一个运算表达式，直接给你求值。中缀表达式转正常表达式很简单了，直接用栈就行。</li><li>但需要注意的是，python中的’/’负数除法和c语言不太一样。在python中，(-1)/2=-1，而在c语言中，(-1)/2=0。也就是c语言中，除法是向零取整，即舍弃小数点后的数。而在python中，是向下取整的。而这道题的oj是默认的c语言中的语法，所以需要在遇到’/’的时候注意一下。</li><li>可采用的方式是使用operator.truediv(int(a), int(b))变成和c相同的方式。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">evalRPN</span><span class="params">(self, tokens: List[str])</span> -&gt; int:</span></span><br><span class="line">        stack = []</span><br><span class="line">        operators = [<span class="string">'+'</span>, <span class="string">'-'</span>,<span class="string">'*'</span>,<span class="string">'/'</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> token <span class="keyword">in</span> tokens:</span><br><span class="line">            <span class="keyword">if</span> token <span class="keyword">not</span> <span class="keyword">in</span> operators:</span><br><span class="line">                stack.append(token)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                b = stack.pop()</span><br><span class="line">                a = stack.pop()</span><br><span class="line">                <span class="keyword">if</span> token == <span class="string">'/'</span>:</span><br><span class="line">                    res = int(operator.truediv(int(a), int(b)))</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    res = eval(a+token+b)</span><br><span class="line">                stack.append(str(res))</span><br><span class="line">        <span class="keyword">return</span> int(stack.pop())</span><br></pre></td></tr></table></figure><h1 id="参考">参考</h1><ul><li><a href="https://facert.gitbooks.io/python-data-structure-cn/content/" target="_blank" rel="noopener">problem-solving-with-algorithms-and-data-structure-using-python</a></li><li><a href="https://stackoverflow.com/questions/1313788/how-does-the-back-button-in-a-web-browser-work" target="_blank" rel="noopener">How does the Back button in a web browser work?</a></li><li><a href="https://blog.csdn.net/fuxuemingzhu/article/details/79559703" target="_blank" rel="noopener">【LeetCode】150. Evaluate Reverse Polish Notation 解题报告（Python）</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python实现数据结构中的队列</title>
      <link href="/2019/03/01/python%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E9%98%9F%E5%88%97/"/>
      <url>/2019/03/01/python%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<p>队列中的数据呈线性排列。与栈类似，队列中可以操作数据的位置也有一定的限制。在栈中，数据的添加和删除都在同一端进行，而在队列中则分别是在两端进行的。队列也不能直接访问位于中间的数据，必须通过出队操作将目标数据变成首位后才能访问。</p><p>像队列这种最先进去的数据最先被取来，即“先进先出”的结构，我们称为 First In First Out，简称 FIFO。</p><p>“先来的数据先处理”是一种很常见的思路，所以队列的应用范围非常广泛。比如广度优先搜索算法，通常就会从搜索候补中选择最早的数据作为下一个顶点。此时，在候补顶点的管理上就可以使用队列。</p><p>学习目标： - 用数组实现一个顺序队列 - 用链表实现一个链式队列 - 实现一个循环队列 - LeetCode 641. 设计循环双端队列 - LeetCode 239. 滑动窗口最大值</p><a id="more"></a><h1 id="用数组实现一个顺序队列">用数组实现一个顺序队列</h1><p>list表头入队，表尾出队。反过来也可以。</p><p>实现的基本操作有： - enqueue 入队，要把表中其余元素全部后移，再插入首元素，需要 <span class="math inline">\(O(n)\)</span>时间 - dequeue 出队,<span class="math inline">\(O(1)\)</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.items = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">enqueue</span><span class="params">(self, item)</span>:</span> <span class="comment"># 入队</span></span><br><span class="line">        self.items.insert(<span class="number">0</span>,item)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dequeue</span><span class="params">(self)</span>:</span> <span class="comment"># 出队</span></span><br><span class="line">        <span class="keyword">return</span> self.items.pop()</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    q = Queue()</span><br><span class="line">    q.enqueue(<span class="number">4</span>)</span><br><span class="line">    q.enqueue(<span class="number">5</span>)</span><br><span class="line">    q.enqueue(<span class="number">6</span>)</span><br><span class="line">    print(q.dequeue())</span><br></pre></td></tr></table></figure><p>输出： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure></p><h1 id="用链表实现一个链式队列">用链表实现一个链式队列</h1><p>等同于用带表尾指针的单链表。链尾入队，链首出队。</p><p>实现的基本操作有： - enqueue 入队 <span class="math inline">\(O(1)\)</span> - dequeue 出队 <span class="math inline">\(O(1)\)</span> - peek 查看队首元素 <span class="math inline">\(O(1)\)</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span> <span class="comment"># 链表的结点</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x, next_=None)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = next_</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LQueue</span>:</span> <span class="comment"># </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span> <span class="comment"># 空表</span></span><br><span class="line">        self._head = <span class="keyword">None</span></span><br><span class="line">        self._rear = <span class="keyword">None</span> <span class="comment"># 尾结点</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">enqueue</span><span class="params">(self, x)</span>:</span> <span class="comment"># 入队</span></span><br><span class="line">        <span class="keyword">if</span> self._head <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            self._head = Node(x, self._head)</span><br><span class="line">            self._rear = self._head</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self._rear.next = Node(x)</span><br><span class="line">            self._rear = self._rear.next</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dequeue</span><span class="params">(self)</span>:</span> <span class="comment"># 出队</span></span><br><span class="line">        <span class="keyword">if</span> self._head <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        x = self._head.val</span><br><span class="line">        self._head = self._head.next</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">peek</span><span class="params">(self)</span>:</span> <span class="comment"># 查看最早入队的元素</span></span><br><span class="line">        <span class="keyword">if</span> self._head <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">return</span> self._head.val </span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    l = LQueue()</span><br><span class="line">    l.enqueue(<span class="number">4</span>)</span><br><span class="line">    l.enqueue(<span class="number">5</span>)</span><br><span class="line">    print(l.peek())</span><br><span class="line">    l.enqueue(<span class="number">6</span>)</span><br><span class="line">    l.dequeue()</span><br><span class="line">    print(l.peek())</span><br></pre></td></tr></table></figure><p>输出： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">5</span><br></pre></td></tr></table></figure></p><h1 id="实现一个循环队列">实现一个循环队列</h1><p><a href="https://leetcode-cn.com/problems/design-circular-queue/" target="_blank" rel="noopener">LeetCode 622</a></p><p>队头变量<code>_head</code>记录当前队列的第一个元素位置 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QueueUnderflow</span><span class="params">(ValueError)</span>:</span><span class="comment"># 空队列无法 dequeue的异常错误</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SQueue</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, init_len=<span class="number">8</span>)</span>:</span></span><br><span class="line">        self._elems = [<span class="number">0</span>]*init_len  <span class="comment"># 队列元素</span></span><br><span class="line">        self._head = <span class="number">0</span> <span class="comment"># 队列首元素位置的下标</span></span><br><span class="line">        self._num = <span class="number">0</span>  <span class="comment"># 表中元素个数</span></span><br><span class="line">        self._len = init_len   <span class="comment"># 当前表的长度，表满了的话，要换一个存储表</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">peek</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self._num == <span class="number">0</span>: <span class="comment"># 队空状态</span></span><br><span class="line">            <span class="keyword">raise</span> QueueUnderflow</span><br><span class="line">        <span class="keyword">return</span> self._elems[self._head]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dequeue</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self._num == <span class="number">0</span>:  <span class="comment"># 队空状态</span></span><br><span class="line">            <span class="keyword">raise</span> QueueUnderflow</span><br><span class="line">        e = self._elems[self._head]</span><br><span class="line">        self._head = (self._head+<span class="number">1</span>) % self._len </span><br><span class="line">        self._num -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> e</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">enqueue</span><span class="params">(self, e)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self._num == self._len: <span class="comment"># 队满状态</span></span><br><span class="line">            self.__extend() <span class="comment"># 扩大存储区</span></span><br><span class="line">        <span class="comment"># 新元素的入队位置</span></span><br><span class="line">        self._elems[(self._head + self._num) % self._len]=e</span><br><span class="line">        self._num += <span class="number">1</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__extend</span><span class="params">(self)</span>:</span>  <span class="comment"># 扩容</span></span><br><span class="line">        old_len = self._len</span><br><span class="line">        self._len *= <span class="number">2</span></span><br><span class="line">        new_elems = [<span class="number">0</span>] * self._len</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(old_len):</span><br><span class="line">            new_elems[i] = self._elems[(self._head + i)%old_len]</span><br><span class="line">        self._elems, self._head = new_elems, <span class="number">0</span></span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    l = SQueue()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        l.enqueue(i+<span class="number">1</span>)</span><br><span class="line">    print(l.peek())</span><br><span class="line">    l.dequeue()</span><br><span class="line">    print(l.peek())</span><br></pre></td></tr></table></figure></p><h1 id="leetcode-641.-设计循环双端队列">LeetCode 641. 设计循环双端队列</h1><p><a href="https://leetcode-cn.com/problems/design-circular-deque/" target="_blank" rel="noopener">Design Circular Deque</a> 设计实现双端队列。 你的实现需要支持以下操作：</p><ul><li>MyCircularDeque(k)：构造函数,双端队列的大小为k。</li><li>insertFront()：将一个元素添加到双端队列头部。 如果操作成功返回 true。</li><li>insertLast()：将一个元素添加到双端队列尾部。如果操作成功返回 true。</li><li>deleteFront()：从双端队列头部删除一个元素。 如果操作成功返回 true。</li><li>deleteLast()：从双端队列尾部删除一个元素。如果操作成功返回 true。</li><li>getFront()：从双端队列头部获得一个元素。如果双端队列为空，返回 -1。</li><li>getRear()：获得双端队列的最后一个元素。 如果双端队列为空，返回 -1。</li><li>isEmpty()：检查双端队列是否为空。</li><li>isFull()：检查双端队列是否满了。</li></ul><p>示例： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">MyCircularDeque circularDeque = new MycircularDeque(3); // 设置容量大小为3</span><br><span class="line">circularDeque.insertLast(1);        // 返回 true</span><br><span class="line">circularDeque.insertLast(2);        // 返回 true</span><br><span class="line">circularDeque.insertFront(3);        // 返回 true</span><br><span class="line">circularDeque.insertFront(4);        // 已经满了，返回 false</span><br><span class="line">circularDeque.getRear();  // 返回 2</span><br><span class="line">circularDeque.isFull();        // 返回 true</span><br><span class="line">circularDeque.deleteLast();        // 返回 true</span><br><span class="line">circularDeque.insertFront(4);        // 返回 true</span><br><span class="line">circularDeque.getFront();// 返回 4</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li>所有值的范围为 [1, 1000]</li><li>操作次数的范围为 [1, 1000]</li><li>请不要使用内置的双端队列库。</li></ul><h2 id="方法">方法</h2><p>和上一题思路相同，用一个list实现类似的环形列表。 双向链表可以从头尾插入元素，对应了list的insert和append方法。注意，无论是在头尾插入，要移动的指针都是rear。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCircularDeque</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, k: int)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Initialize your data structure here. Set the size of the deque to be k.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self._elems = [<span class="number">0</span>]*k  <span class="comment"># 队列元素</span></span><br><span class="line">        self._head = <span class="number">0</span> <span class="comment"># 队列首元素位置的下标</span></span><br><span class="line">        self._num = <span class="number">0</span>  <span class="comment"># 表中元素个数</span></span><br><span class="line">        self._len = k   <span class="comment"># 表的长度</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insertFront</span><span class="params">(self, value: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Adds an item at the front of Deque. Return true if the operation is successful.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> self._num == self._len: <span class="comment"># 队满状态</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="comment"># 新元素的入队位置</span></span><br><span class="line">        self._head = (self._head + self._len - <span class="number">1</span>) % self._len</span><br><span class="line">        self._elems[self._head]= value</span><br><span class="line">        self._num += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insertLast</span><span class="params">(self, value: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Adds an item at the rear of Deque. Return true if the operation is successful.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> self._num == self._len: <span class="comment"># 队满状态</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="comment"># 新元素的入队位置</span></span><br><span class="line">        self._elems[(self._head + self._num) % self._len]= value</span><br><span class="line">        self._num += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteFront</span><span class="params">(self)</span> -&gt; bool:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Deletes an item from the front of Deque. Return true if the operation is successful.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> self._num == <span class="number">0</span>:  <span class="comment"># 队空状态</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="comment"># e = self._elems[self._head]</span></span><br><span class="line">        self._head = (self._head+<span class="number">1</span>) % self._len </span><br><span class="line">        self._num -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteLast</span><span class="params">(self)</span> -&gt; bool:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Deletes an item from the rear of Deque. Return true if the operation is successful.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> self._num == <span class="number">0</span>:  <span class="comment"># 队空状态</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="comment"># e = self._elems[(self._head + self._num-1) % self._len]</span></span><br><span class="line">        self._num -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getFront</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Get the front item from the deque.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> self._num == <span class="number">0</span>: <span class="comment"># 队空状态</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span> self._elems[self._head]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getRear</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Get the last item from the deque.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> self._num == <span class="number">0</span>: <span class="comment"># 队空状态</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span> self._elems[(self._head + self._num<span class="number">-1</span>) % self._len]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isEmpty</span><span class="params">(self)</span> -&gt; bool:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Checks whether the circular deque is empty or not.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span>  self._num == <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isFull</span><span class="params">(self)</span> -&gt; bool:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Checks whether the circular deque is full or not.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span>  self._len == self._num</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your MyCircularDeque object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = MyCircularDeque(k)</span></span><br><span class="line"><span class="comment"># param_1 = obj.insertFront(value)</span></span><br><span class="line"><span class="comment"># param_2 = obj.insertLast(value)</span></span><br><span class="line"><span class="comment"># param_3 = obj.deleteFront()</span></span><br><span class="line"><span class="comment"># param_4 = obj.deleteLast()</span></span><br><span class="line"><span class="comment"># param_5 = obj.getFront()</span></span><br><span class="line"><span class="comment"># param_6 = obj.getRear()</span></span><br><span class="line"><span class="comment"># param_7 = obj.isEmpty()</span></span><br><span class="line"><span class="comment"># param_8 = obj.isFull()</span></span><br></pre></td></tr></table></figure><h1 id="leetcode-239.-滑动窗口最大值">LeetCode 239. 滑动窗口最大值</h1><p><a href="https://leetcode-cn.com/problems/sliding-window-maximum/" target="_blank" rel="noopener">Sliding Window Maximum</a></p><h2 id="方法deque双端队列">方法：deque（双端队列）</h2><p>遍历数组nums，使用双端队列deque维护滑动窗口内有可能成为最大值元素的数组下标。</p><p>当下标i从队尾入队时，顺次弹出队列尾值<code>&lt;=nums[i]</code>的数组下标。</p><p>当前下标为i，则滑动窗口的有效下标范围为[i - (k - 1), i] ,所以当队头元素<code>dq[0] == i-k</code>，就要从队头出队。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSlidingWindow</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; List[int]:</span></span><br><span class="line">        dq = collections.deque() <span class="comment"># 队列</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">while</span> dq <span class="keyword">and</span> nums[dq[<span class="number">-1</span>]] &lt;= nums[i]:<span class="comment">#(循环)当dq队尾值小于新元素nums[i]</span></span><br><span class="line">                dq.pop() <span class="comment">#队尾值出队(直到dq中的值都大于新元素nums[i])</span></span><br><span class="line">            dq.append(i) <span class="comment">#新元素入队</span></span><br><span class="line">            <span class="keyword">if</span> dq[<span class="number">0</span>] == i-k: <span class="comment"># 窗口滑出，队头元素不在窗口区域内</span></span><br><span class="line">                dq.popleft() <span class="comment"># 队头值出队</span></span><br><span class="line">            <span class="keyword">if</span> i &gt;= k<span class="number">-1</span>: <span class="comment"># i遍历到一个窗口大小之后，每轮都能执行此行。</span></span><br><span class="line">                res.append(nums[dq[<span class="number">0</span>]]) <span class="comment">#窗口最大元素</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h1 id="参考">参考</h1><ul><li>《我的第一本算法书》</li><li><a href="http://bookshadow.com/weblog/2015/07/18/leetcode-sliding-window-maximum/" target="_blank" rel="noopener">[LeetCode]Sliding Window Maximum</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python实现数据结构中的链表</title>
      <link href="/2019/02/28/python%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E9%93%BE%E8%A1%A8/"/>
      <url>/2019/02/28/python%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p>链表是数据结构之一，其中的数据呈线性排列。在链表中，数据的添加和删除都较为方便， 就是访问比较耗费时间。</p><p>链表在前一结点里用链接的方式显示地记录与下一结点的关系。不同于数组，链表的元素的物理地址可以任意。</p><p>学习目标： - 实现单链表、循环链表、双向链表，支持增删操作。</p><a id="more"></a><h1 id="实现单链表">实现单链表</h1><p>只需要掌握这个表的首结点，从它出发可以找到这个表里的下一结点，以至于找到表里的所有数据元素。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span> <span class="comment"># 链表的结点</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x, next_=None)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = next_</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleLinkList</span>:</span> <span class="comment"># 单链表</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span> <span class="comment"># 空表</span></span><br><span class="line">        self.head = <span class="keyword">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#增</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insertAsFirst</span><span class="params">(self, x)</span>:</span> <span class="comment">#x在首位插入</span></span><br><span class="line">        node = Node(x)</span><br><span class="line">        node.next = self.head</span><br><span class="line">        self.head = node</span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insertAsLast</span><span class="params">(self, x)</span>:</span> <span class="comment">#x在尾部插入</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.head:</span><br><span class="line">            self.head = Node(x)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        cur = self.head</span><br><span class="line">        <span class="keyword">while</span> cur.next != <span class="keyword">None</span>:</span><br><span class="line">            cur = cur.next</span><br><span class="line">        node = Node(x)</span><br><span class="line">        cur.next = node</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#删</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove</span><span class="params">(self, p)</span>:</span><span class="comment">#删除在位置p处的结点，返回其数值</span></span><br><span class="line">        k = self.head</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(p<span class="number">-1</span>):</span><br><span class="line">            k = k.next</span><br><span class="line">        x = k.next.val</span><br><span class="line">        k.next = k.next.next</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove_last</span><span class="params">(self)</span>:</span> <span class="comment">#删除表尾的结点</span></span><br><span class="line">        p = self.head</span><br><span class="line">        <span class="keyword">if</span> p.next <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            x = p.val</span><br><span class="line">            self.head = <span class="keyword">None</span></span><br><span class="line">            <span class="keyword">return</span> x</span><br><span class="line">        <span class="keyword">while</span> p.next.next <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:  <span class="comment"># 直到 p.next 是最后结点</span></span><br><span class="line">            p = p.next</span><br><span class="line">        x = p.next.val</span><br><span class="line">        p.next = <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(self)</span>:</span></span><br><span class="line">        cur = self.head</span><br><span class="line">        <span class="keyword">while</span> cur != <span class="keyword">None</span>:</span><br><span class="line">            <span class="comment"># cur是一个有效的节点</span></span><br><span class="line">            print(cur.val, end=<span class="string">' --&gt; '</span>)</span><br><span class="line">            cur = cur.next</span><br><span class="line">        print()</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    l = SingleLinkList()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        l.insertAsLast(i)</span><br><span class="line">    l.show()</span><br><span class="line">    l.remove_last()</span><br><span class="line">    l.show()</span><br></pre></td></tr></table></figure></p><p>输出： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 --&gt; 1 --&gt; 2 --&gt; 3 --&gt; 4 --&gt; 5 --&gt; 6 --&gt; 7 --&gt; 8 --&gt; 9 --&gt;</span><br></pre></td></tr></table></figure></p><h1 id="双向链表">双向链表</h1><p>增加了反向的链接，结点操作更加方便。但是每个结点都需要增加一个链接域，增加的空间开销与结点数成正比，<code>O(n)</code> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DLNode</span>:</span> <span class="comment"># 链表的结点</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x, prev=None, next_=None)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = next_</span><br><span class="line">        self.prev = prev</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoubleLinkList</span>:</span> <span class="comment"># 双链表</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span> <span class="comment"># 空表</span></span><br><span class="line">        self.head = <span class="keyword">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#增</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insertAsFirst</span><span class="params">(self, x)</span>:</span> <span class="comment">#x在首位插入               </span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.head:</span><br><span class="line">            self.head = DLNode(x)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            node = DLNode(x,<span class="keyword">None</span>,self.head)</span><br><span class="line">            self.head.prev = node </span><br><span class="line">            self.head = node   <span class="comment"># node 作为新的头结点</span></span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insertAsLast</span><span class="params">(self, x)</span>:</span> <span class="comment">#x在尾部插入</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.head:</span><br><span class="line">            self.head = DLNode(x)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cur = self.head</span><br><span class="line">            <span class="keyword">while</span> cur.next != <span class="keyword">None</span>: <span class="comment"># 移动到链表尾部</span></span><br><span class="line">                cur = cur.next</span><br><span class="line">            node = DLNode(x)</span><br><span class="line">            cur.next = node</span><br><span class="line">            node.prev = cur</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#删</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove</span><span class="params">(self, p)</span>:</span><span class="comment">#删除在位置p处的结点，返回其数值</span></span><br><span class="line">        k = self.head</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(p<span class="number">-1</span>):</span><br><span class="line">            k = k.next</span><br><span class="line">        x = k.next.val</span><br><span class="line">        k.next = k.next.next</span><br><span class="line">        k.next.prev = k</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(self)</span>:</span></span><br><span class="line">        cur = self.head</span><br><span class="line">        <span class="keyword">while</span> cur != <span class="keyword">None</span>:</span><br><span class="line">            <span class="comment"># cur是一个有效的节点</span></span><br><span class="line">            print(cur.val, end=<span class="string">' -- '</span>)</span><br><span class="line">            cur = cur.next</span><br><span class="line">        print()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show_reverse</span><span class="params">(self)</span>:</span></span><br><span class="line">        cur = self.head</span><br><span class="line">        <span class="keyword">while</span> cur.next != <span class="keyword">None</span>:</span><br><span class="line">            cur = cur.next</span><br><span class="line">        <span class="keyword">while</span> cur != <span class="keyword">None</span>:</span><br><span class="line">            print(cur.val, end=<span class="string">' -- '</span>)</span><br><span class="line">            cur = cur.prev</span><br><span class="line">        print()    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    l = DoubleLinkList()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        l.insertAsLast(i)</span><br><span class="line">    l.show()</span><br><span class="line">    l.remove(<span class="number">2</span>)</span><br><span class="line">    l.show()</span><br><span class="line">    l.show_reverse()</span><br></pre></td></tr></table></figure></p><p>输出： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0 -- 1 -- 2 -- 3 -- 4 -- 5 -- 6 -- 7 -- 8 -- 9 -- </span><br><span class="line">0 -- 1 -- 3 -- 4 -- 5 -- 6 -- 7 -- 8 -- 9 -- </span><br><span class="line">9 -- 8 -- 7 -- 6 -- 5 -- 4 -- 3 -- 1 -- 0 --</span><br></pre></td></tr></table></figure></p><h1 id="leetcode习题">Leetcode习题</h1><h2 id="反转链表">206. 反转链表</h2><p><a href="https://leetcode-cn.com/problems/reverse-linked-list/" target="_blank" rel="noopener">Reverse Linked List</a></p><p>反转一个单链表。</p><p><strong>示例:</strong></p><blockquote><p>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</p></blockquote><blockquote><p>输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL ### 方法：两个指针，头插法 - 用两个指针，p指针记录的是每次的队头元素，q指针指向下一个要插入队头的元素。 - head帮忙指向下轮要头插的元素，待本轮指针翻转完之后要把该元素赋给q</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        p = head  <span class="comment"># p是指向每次的队头元素</span></span><br><span class="line">        q = head.next  <span class="comment"># q是指下一个要插入队头的元素</span></span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            head.next = q.next <span class="comment"># 保留后一个要插入的元素地址</span></span><br><span class="line">            q.next = p <span class="comment"># 指针反转，next为队头元素</span></span><br><span class="line">            p = q <span class="comment">#q插入，作为新的队头</span></span><br><span class="line">            q = head.next <span class="comment"># 重新指定下一个要插入队头的元素</span></span><br><span class="line">        <span class="keyword">return</span> p</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python实现数据结构中的数组</title>
      <link href="/2019/02/28/python%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E6%95%B0%E7%BB%84/"/>
      <url>/2019/02/28/python%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<p>在数组中，访问数据十分简单，而添加和删除数据比较耗工夫。</p><p>由于数组中的数据是存储在连续空间内的，所以每个数据的内存地址（在内存上的位置）都可以通过数组下标算出，我们也就可以借此直接访问目标数据（这叫作“随机访问”），需要的运行时间仅为恒定的 <code>O(1)</code>。</p><p>向数组中添加新数据时，必须把目标位置后面的数据一个个移开。所以，如果在数组头部添加数据，就需要<code>O(n)</code>的时间。删除操作同理。</p><p>学习目标： - 实现一个支持动态扩容的数组 - 实现一个大小固定的有序数组，支持动态增删改操作</p><a id="more"></a><h1 id="支持动态扩容的数组">支持动态扩容的数组</h1><p>类似于Python的简化版list <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ctypes</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DynamicArray</span>:</span>   </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">""" Create an empty array."""</span></span><br><span class="line">        self._n = <span class="number">0</span> <span class="comment">#count actual elements</span></span><br><span class="line">        self._capacity = <span class="number">1</span> <span class="comment">#default array capacity</span></span><br><span class="line">        self._A = self._make_array(self._capacity)  <span class="comment">#low-level array</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Return number of elements stored in the array."""</span></span><br><span class="line">        <span class="keyword">return</span> self._n</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self,k)</span>:</span></span><br><span class="line">        <span class="string">"""Return element at index k."""</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="number">0</span> &lt;= k &lt; self._n:</span><br><span class="line">            <span class="keyword">raise</span> IndexError(<span class="string">'invalid index'</span>)</span><br><span class="line">        <span class="keyword">return</span> self._A[k]  <span class="comment">#retrieve from array</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">append</span><span class="params">(self, obj)</span>:</span></span><br><span class="line">        <span class="string">"""Add object to end of the array."""</span></span><br><span class="line">        <span class="keyword">if</span> self._n == self._capacity:  <span class="comment"># not enough room</span></span><br><span class="line">            self._resize(<span class="number">2</span>*self._capacity) <span class="comment">#so double capacity</span></span><br><span class="line">        self._A[self._n] = obj</span><br><span class="line">        self._n += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_resize</span><span class="params">(self, c)</span>:</span>  <span class="comment"># nonpublic utitity</span></span><br><span class="line">        <span class="string">"""Resize internal array to capacity c."""</span></span><br><span class="line">        B = self._make_array(c)   <span class="comment"># new (bigger) array</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(self._n):  <span class="comment"># for each existing value</span></span><br><span class="line">            B[k] = self._A[k]</span><br><span class="line">        self._A = B</span><br><span class="line">        self._capacity = c</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_make_array</span><span class="params">(self, c)</span>:</span>  <span class="comment"># nonpublic utitity   </span></span><br><span class="line">        <span class="string">"""Return new array with capacity c."""</span></span><br><span class="line">        <span class="keyword">return</span> (c * ctypes.py_object)() <span class="comment"># see ctypes documentation</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    </span><br><span class="line">    da = DynamicArray()</span><br><span class="line">    da.append(<span class="number">6</span>)</span><br><span class="line">    da.append(<span class="number">2</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> o <span class="keyword">in</span> da:</span><br><span class="line">        print(o)</span><br></pre></td></tr></table></figure></p><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">6</span><br><span class="line">2</span><br></pre></td></tr></table></figure><h1 id="大小固定的有序数组支持动态增删改操作">大小固定的有序数组，支持动态增删改操作</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NewArray</span>:</span></span><br><span class="line">    <span class="string">""" A dynamic array class akin to a simplified Python list."""</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,capacity=<span class="number">10</span>)</span>:</span></span><br><span class="line">        <span class="string">""" Create an empty array."""</span></span><br><span class="line">        self._n = <span class="number">0</span>  <span class="comment">#数组大小</span></span><br><span class="line">        self._A = [<span class="keyword">None</span>] * capacity</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self,k)</span>:</span></span><br><span class="line">        <span class="string">"""Return element at index k."""</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="number">0</span> &lt;= k &lt; self._n:</span><br><span class="line">            <span class="keyword">raise</span> IndexError(<span class="string">'invalid index'</span>)</span><br><span class="line">        <span class="keyword">return</span> self._A[k] <span class="comment">#retrieve from array</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self,k,v)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> k &gt;= len(self._A):</span><br><span class="line">            <span class="keyword">raise</span> IndexError(<span class="string">'Index out of range!'</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(self._n, k<span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            self._A[i+<span class="number">1</span>] = self._A[i]</span><br><span class="line">        self._A[k] = v</span><br><span class="line">        self._n += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(self,k)</span>:</span></span><br><span class="line">        v = self._A[k]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(k+<span class="number">1</span>,self._n):</span><br><span class="line">            self._A[i<span class="number">-1</span>] = self._A[i]</span><br><span class="line">        self._n -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> v</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setitem__</span><span class="params">(self,k,v)</span>:</span></span><br><span class="line">        self._A[k] = v</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    </span><br><span class="line">    A = NewArray()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        A.insert(i, i) <span class="comment"># 增</span></span><br><span class="line">    print(A[<span class="number">2</span>]) </span><br><span class="line">    A.delete(<span class="number">0</span>) <span class="comment"># 删</span></span><br><span class="line">    print(A[<span class="number">2</span>])</span><br><span class="line">    A[<span class="number">0</span>] = <span class="number">10</span> <span class="comment"># 改</span></span><br><span class="line">    print(A[<span class="number">0</span>]) <span class="comment"># 查</span></span><br></pre></td></tr></table></figure><p>输出： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">3</span><br><span class="line">10</span><br></pre></td></tr></table></figure></p><h1 id="leetcode习题">Leetcode习题</h1><h2 id="合并两个有序数组">88. 合并两个有序数组</h2><p><a href="https://leetcode-cn.com/problems/merge-sorted-array/" target="_blank" rel="noopener">Merge Sorted Array</a></p><p>给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。</p><p>说明: - 初始化 nums1 和 nums2 的元素数量分别为 m 和 n。 - 你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。</p><p><strong>示例:</strong></p><blockquote><p>输入:</p></blockquote><blockquote><p>nums1 = [1,2,3,0,0,0], m = 3</p></blockquote><blockquote><p>nums2 = [2,5,6], n = 3</p></blockquote><blockquote><p>输出: [1,2,2,3,5,6]</p></blockquote><h3 id="方法遍历比较大的放最后">方法：遍历比较，大的放最后</h3><p>从后往前遍历两个数组，然后把对应的元素放在数组1对应的位置，</p><p>注意：最后我们只需判断数组2有没有遍历完即可，因为数组1没有遍历完的话，它已经是按顺序放在前面的了 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, nums1, m, nums2, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums1: List[int]</span></span><br><span class="line"><span class="string">        :type m: int</span></span><br><span class="line"><span class="string">        :type nums2: List[int]</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: void Do not return anything, modify nums1 in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> m&gt;<span class="number">0</span> <span class="keyword">and</span> n&gt;<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> nums1[m<span class="number">-1</span>] &gt; nums2[n<span class="number">-1</span>]:</span><br><span class="line">                nums1[m+n<span class="number">-1</span>] = nums1[m<span class="number">-1</span>]</span><br><span class="line">                m -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nums1[m+n<span class="number">-1</span>] = nums2[n<span class="number">-1</span>]</span><br><span class="line">                n -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> n&gt;<span class="number">0</span>:</span><br><span class="line">            nums1[:n] = nums2[:n]</span><br></pre></td></tr></table></figure></p><h2 id="两数之和">1. 两数之和</h2><p><a href="https://leetcode-cn.com/problems/two-sum/" target="_blank" rel="noopener">Two Sum</a> 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那<strong>两个</strong>整数，并返回他们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p><p><strong>示例:</strong></p><blockquote><p>给定 nums = [2, 7, 11, 15], target = 9</p></blockquote><blockquote><p>因为 nums[0] + nums[1] = 2 + 7 = 9</p></blockquote><blockquote><p>所以返回 [0, 1]</p></blockquote><h3 id="方法哈希表">方法：哈希表</h3><p>利用python中的字典记录记录下每个元素出现的位置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        </span><br><span class="line">        dic = dict()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> index,value <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            sub = target - value</span><br><span class="line">            <span class="keyword">if</span> sub <span class="keyword">in</span> dic:</span><br><span class="line">                <span class="keyword">return</span> [dic[sub], index]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dic[value]=index</span><br></pre></td></tr></table></figure><h1 id="参考">参考</h1><ul><li><a href="https://www.geeksforgeeks.org/implementation-of-dynamic-array-in-python/" target="_blank" rel="noopener">mplementation of Dynamic Array in Python</a></li><li><a href="https://note.youdao.com/ynoteshare1/index.html?id=6b47b08c91b05db6c33fe92b88b53192&amp;type=note#/" target="_blank" rel="noopener">任务1-数组与链表</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用python刷LeetCode数组题(简单级)(二)</title>
      <link href="/2019/02/26/%E7%94%A8python%E5%88%B7LeetCode%E6%95%B0%E7%BB%84%E9%A2%98(%E7%AE%80%E5%8D%95)(%E4%BA%8C)/"/>
      <url>/2019/02/26/%E7%94%A8python%E5%88%B7LeetCode%E6%95%B0%E7%BB%84%E9%A2%98(%E7%AE%80%E5%8D%95)(%E4%BA%8C)/</url>
      
        <content type="html"><![CDATA[<h1 id="求众数">169. 求众数</h1><p>Majority Element ## 题目描述 给定一个大小为 n 的数组，找到其中的众数。众数是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。</p><p>你可以假设数组是非空的，并且给定的数组总是存在众数。</p><p><strong>示例 1:</strong></p><blockquote><p>输入: [3,2,3]</p></blockquote><blockquote><p>输出: 3</p></blockquote><a id="more"></a><h2 id="方法-遍历">方法： 遍历</h2><p>最多的元素出现的次数大于数组长度的一半，在最极端的情况下，最后的count都会大于0 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        count = <span class="number">1</span></span><br><span class="line">        res = nums[<span class="number">0</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i] == res:</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                count -= <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> count == <span class="number">0</span>:</span><br><span class="line">                res = nums[i]</span><br><span class="line">                count = <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p><h1 id="旋转数组">189. 旋转数组</h1><p>Rotate Array ## 题目描述 给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。</p><p>示例 1:</p><p>输入: [1,2,3,4,5,6,7] 和 k = 3</p><p>输出: [5,6,7,1,2,3,4]</p><p>解释:</p><p>向右旋转 1 步: [7,1,2,3,4,5,6]</p><p>向右旋转 2 步: [6,7,1,2,3,4,5]</p><p>向右旋转 3 步: [5,6,7,1,2,3,4]</p><h2 id="方法直接拼接数组">方法：直接拼接数组</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotate</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: None Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        nums[:] = nums[n-k:] + nums[:n-k]</span><br></pre></td></tr></table></figure><h1 id="存在重复元素">217. 存在重复元素</h1><p>Contains Duplicate ## 题目描述 给定一个整数数组，判断是否存在重复元素。</p><p>如果任何值在数组中出现至少两次，函数返回 true。如果数组中每个元素都不相同，则返回 false。</p><p>示例 1:</p><p>输入: [1,2,3,1] 输出: true</p><p>示例 2:</p><p>输入: [1,2,3,4] 输出: false</p><h2 id="方法set">方法：set()</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">containsDuplicate</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> len(nums) != len(set(nums))</span><br></pre></td></tr></table></figure><h1 id="存在重复元素-ii">219. 存在重复元素 II</h1><p>Contains Duplicate II ## 题目描述 给定一个整数数组和一个整数 k，判断数组中是否存在两个不同的索引 i 和 j，使得 nums [i] = nums [j]，并且 i 和 j 的差的绝对值最大为 k。</p><p><strong>示例 1:</strong></p><blockquote><p>输入: nums = [1,0,1,1], k = 1</p></blockquote><blockquote><p>输出: true</p></blockquote><p><strong>示例 2:</strong></p><blockquote><p>输入: nums = [1,2,3,1,2,3], k = 2</p></blockquote><blockquote><p>输出: false</p></blockquote><h2 id="方法">方法</h2><p>用dict保存数组元素出现的位置，两种情况下更新 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">containsNearbyDuplicate</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        dic = dict()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> index,value <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            <span class="keyword">if</span> value <span class="keyword">in</span> dic <span class="keyword">and</span> index - dic[value] &lt;= k:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            dic[value] = index</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure></p><h1 id="缺失数字">268. 缺失数字</h1><p>Missing Number ## 题目描述 给定一个包含 0, 1, 2, ..., n 中 n 个数的序列，找出 0 .. n 中没有出现在序列中的那个数。</p><p><strong>示例 1:</strong></p><blockquote><p>输入: [3,0,1] 输出: 2</p></blockquote><p><strong>示例 2:</strong></p><blockquote><p>输入: [9,6,4,2,3,5,7,0,1]</p></blockquote><blockquote><p>输出: 8</p></blockquote><h2 id="方法数学公式">方法：数学公式</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">missingNumber</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> n* (n+<span class="number">1</span>)/<span class="number">2</span> - sum(nums)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用python刷LeetCode数组题(简单级)(一)</title>
      <link href="/2019/02/22/%E7%94%A8python%E5%88%B7LeetCode%E6%95%B0%E7%BB%84%E9%A2%98(%E7%AE%80%E5%8D%95%E7%BA%A7)(%E4%B8%80)/"/>
      <url>/2019/02/22/%E7%94%A8python%E5%88%B7LeetCode%E6%95%B0%E7%BB%84%E9%A2%98(%E7%AE%80%E5%8D%95%E7%BA%A7)(%E4%B8%80)/</url>
      
        <content type="html"><![CDATA[<h1 id="两数之和">1. 两数之和</h1><p><a href="https://leetcode-cn.com/problems/two-sum/" target="_blank" rel="noopener">Two Sum</a></p><h2 id="题目描述">题目描述</h2><p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那<strong>两个</strong>整数，并返回他们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p><a id="more"></a><p><strong>示例:</strong> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定 nums = [2, 7, 11, 15], target = 9</span><br><span class="line">因为 nums[0] + nums[1] = 2 + 7 = 9</span><br><span class="line">所以返回 [0, 1]</span><br></pre></td></tr></table></figure></p><h2 id="方法字典">方法：字典</h2><p>利用python中的字典记录记录下每个元素出现的位置。key记差值，value记已有数值的位置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        </span><br><span class="line">        dic = dict()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> index,value <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            sub = target - value</span><br><span class="line">            <span class="keyword">if</span> sub <span class="keyword">in</span> dic:</span><br><span class="line">                <span class="keyword">return</span> [dic[sub], index]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dic[value]=index</span><br></pre></td></tr></table></figure><h1 id="删除排序数组中的重复项">26. 删除排序数组中的重复项</h1><p><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/" target="_blank" rel="noopener">Remove Duplicates from Sorted Array</a></p><h2 id="题目描述-1">题目描述</h2><p>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</p><p><strong>示例 1:</strong></p><blockquote><p>给定数组 nums = [1,1,2],</p></blockquote><blockquote><p>函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。</p></blockquote><blockquote><p>你不需要考虑数组中超出新长度后面的元素。</p></blockquote><p><strong>示例 2:</strong></p><blockquote><p>给定 nums = [0,0,1,1,1,2,2,3,3,4],</p></blockquote><blockquote><p>函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。</p></blockquote><blockquote><p>你不需要考虑数组中超出新长度后面的元素。</p></blockquote><p><strong>说明:</strong></p><blockquote><p>为什么返回数值是整数，但输出的答案是数组呢?</p></blockquote><blockquote><p>请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p></blockquote><blockquote><p>你可以想象内部操作如下: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝</span><br><span class="line">int len = removeDuplicates(nums);</span><br><span class="line"></span><br><span class="line">// 在函数里修改输入数组对于调用者是可见的。</span><br><span class="line">// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。</span><br><span class="line">for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">    print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><h2 id="方法遍历一次">方法：遍历一次</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i] != nums[index]:</span><br><span class="line">                index += <span class="number">1</span></span><br><span class="line">                nums[index] = nums[i]</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> index+<span class="number">1</span></span><br></pre></td></tr></table></figure><h1 id="移除元素">27. 移除元素</h1><p><a href="https://leetcode-cn.com/problems/remove-element/" target="_blank" rel="noopener">Remove Element</a></p><h2 id="题目描述-2">题目描述</h2><p>给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</p><p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p><p><strong>示例 1:</strong></p><blockquote><p>给定 nums = [3,2,2,3], val = 3,</p></blockquote><blockquote><p>函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。</p></blockquote><blockquote><p>你不需要考虑数组中超出新长度后面的元素。</p></blockquote><p><strong>示例 2:</strong></p><blockquote><p>给定 nums = [0,1,2,2,3,0,4,2], val = 2,</p></blockquote><blockquote><p>函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。</p></blockquote><blockquote><p>注意这五个元素可为任意顺序。</p></blockquote><blockquote><p>你不需要考虑数组中超出新长度后面的元素。</p></blockquote><h2 id="方法遍历一次-1">方法：遍历一次</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeElement</span><span class="params">(self, nums, val)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type val: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        index = <span class="number">0</span> </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i]!=val:</span><br><span class="line">                nums[index] = nums[i]</span><br><span class="line">                index += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> index</span><br></pre></td></tr></table></figure><h1 id="搜索插入位置">35. 搜索插入位置</h1><p><a href="https://leetcode-cn.com/problems/search-insert-position/" target="_blank" rel="noopener">Search Insert Position</a> ## 题目描述 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><p>你可以假设数组中无重复元素。</p><p><strong>示例 1:</strong></p><blockquote><p>输入: [1,3,5,6], 5</p></blockquote><blockquote><p>输出: 2</p></blockquote><p><strong>示例 2:</strong></p><blockquote><p>输入: [1,3,5,6], 2</p></blockquote><blockquote><p>输出: 1</p></blockquote><p><strong>示例 3:</strong></p><blockquote><p>输入: [1,3,5,6], 7</p></blockquote><blockquote><p>输出: 4</p></blockquote><h2 id="方法一顺序查找">方法一：顺序查找</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchInsert</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> target &gt; nums[<span class="number">-1</span>]:</span><br><span class="line">            <span class="keyword">return</span> len(nums)</span><br><span class="line">        <span class="keyword">for</span> index, value <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            <span class="keyword">if</span> value &gt;= target:</span><br><span class="line">                <span class="keyword">return</span> index</span><br></pre></td></tr></table></figure><h2 id="方法二二分查找">方法二：二分查找</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchInsert</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        </span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = len(nums)<span class="number">-1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = (right-left)/<span class="number">2</span> + left</span><br><span class="line">            <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            <span class="keyword">elif</span> nums[mid] &gt; target:</span><br><span class="line">                right = mid<span class="number">-1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left = mid+<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure><p>理论上应该比前一个方法快，实际测评结果较慢。 # 53. 最大子序和 <a href="https://leetcode-cn.com/problems/maximum-subarray/" target="_blank" rel="noopener">Maximum Subarray</a></p><h2 id="题目描述-3">题目描述</h2><p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p><strong>示例:</strong></p><blockquote><p>输入: [-2,1,-3,4,-1,2,1,-5,4],</p></blockquote><blockquote><p>输出: 6</p></blockquote><blockquote><p>解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</p></blockquote><h2 id="方法kadanes-algorithm">方法：Kadane's algorithm</h2><ul><li>用两个指针：max_so_far 指针记录此前所有碰到的最大和，max_ending_here 指针记录循环到当前元素的最大和。</li><li>当循环到元素i时，<ul><li>如果 max_ending_here &lt; 0 的话，说明此前的和是负的，需要舍弃，所以将 max_ending_here 的值变为 i。</li><li>反之，表明当前的和还是正值， 将 max_ending_here 的值变为 i + max_ending_here,可以继续向前探索。</li><li>max_so_far 和 max_ending_here 比较，取较大值。</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        max_so_far = max_ending_here = nums[<span class="number">0</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(nums)):</span><br><span class="line">            <span class="keyword">if</span> max_ending_here &lt; <span class="number">0</span>:</span><br><span class="line">                max_ending_here = nums[i]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                max_ending_here += nums[i]</span><br><span class="line">            <span class="keyword">if</span> max_ending_here &gt; max_so_far:</span><br><span class="line">                max_so_far = max_ending_here</span><br><span class="line">        <span class="keyword">return</span> max_so_far</span><br></pre></td></tr></table></figure><h1 id="加一">66. 加一</h1><p><a href="https://leetcode-cn.com/problems/plus-one/" target="_blank" rel="noopener">Plus One</a></p><h2 id="题目描述-4">题目描述</h2><p>给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。</p><p>最高位数字存放在数组的首位， 数组中每个元素只存储一个数字。</p><p>你可以假设除了整数 0 之外，这个整数不会以零开头。</p><p><strong>示例 1:</strong> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3]</span><br><span class="line">输出: [1,2,4]</span><br><span class="line">解释: 输入数组表示数字 123。</span><br></pre></td></tr></table></figure></p><p><strong>示例 2:</strong> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [4,3,2,1]</span><br><span class="line">输出: [4,3,2,2]</span><br><span class="line">解释: 输入数组表示数字 4321。</span><br></pre></td></tr></table></figure></p><h2 id="方法一反过来遍历">方法一：反过来遍历</h2><p>从最后一位，找一个记录当前进位的变量，然后遍历一遍数组 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">plusOne</span><span class="params">(self, digits)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type digits: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> reversed(range(len(digits))):</span><br><span class="line">            <span class="keyword">if</span> digits[i] == <span class="number">9</span>:</span><br><span class="line">                digits[i] = <span class="number">0</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                digits[i] += <span class="number">1</span></span><br><span class="line">                <span class="keyword">return</span> digits</span><br><span class="line">        digits[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        digits.append(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> digits</span><br></pre></td></tr></table></figure></p><h2 id="方法二转数字字符串int">方法二：转数字→字符串→int</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">plusOne</span><span class="params">(self, digits)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type digits: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> digits:</span><br><span class="line">            sum = sum*<span class="number">10</span>+i</span><br><span class="line">        <span class="keyword">return</span> [int(i) <span class="keyword">for</span> i <span class="keyword">in</span> str(sum+<span class="number">1</span>)]</span><br></pre></td></tr></table></figure><h1 id="合并两个有序数组">88. 合并两个有序数组</h1><p><a href="https://leetcode-cn.com/problems/merge-sorted-array/" target="_blank" rel="noopener">Merge Sorted Array</a> ## 题目描述 给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。</p><p>说明: - 初始化 nums1 和 nums2 的元素数量分别为 m 和 n。 - 你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。</p><p><strong>示例:</strong></p><blockquote><p>输入:</p></blockquote><blockquote><p>nums1 = [1,2,3,0,0,0], m = 3</p></blockquote><blockquote><p>nums2 = [2,5,6], n = 3</p></blockquote><blockquote><p>输出: [1,2,2,3,5,6]</p></blockquote><h2 id="方法遍历比较大的放最后">方法：遍历比较，大的放最后</h2><p>从后往前遍历两个数组，然后把对应的元素放在数组1对应的位置，</p><p>注意：最后我们只需判断数组2有没有遍历完即可，因为数组1没有遍历完的话，它已经是按顺序放在前面的了 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, nums1, m, nums2, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums1: List[int]</span></span><br><span class="line"><span class="string">        :type m: int</span></span><br><span class="line"><span class="string">        :type nums2: List[int]</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: void Do not return anything, modify nums1 in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> m&gt;<span class="number">0</span> <span class="keyword">and</span> n&gt;<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> nums1[m<span class="number">-1</span>] &gt; nums2[n<span class="number">-1</span>]:</span><br><span class="line">                nums1[m+n<span class="number">-1</span>] = nums1[m<span class="number">-1</span>]</span><br><span class="line">                m -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nums1[m+n<span class="number">-1</span>] = nums2[n<span class="number">-1</span>]</span><br><span class="line">                n -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> n&gt;<span class="number">0</span>:</span><br><span class="line">            nums1[:n] = nums2[:n]</span><br></pre></td></tr></table></figure></p><h1 id="杨辉三角">118. 杨辉三角</h1><p><a href="https://leetcode-cn.com/problems/pascals-triangle/" target="_blank" rel="noopener">Pascal's Triangle</a> ## 题目描述 给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。</p><p>在杨辉三角中，每个数是它左上方和右上方的数的和。</p><p><strong>示例:</strong></p><blockquote><p>输入: 5</p></blockquote><blockquote><p>输出:</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">     [1],</span><br><span class="line">    [1,1],</span><br><span class="line">   [1,2,1],</span><br><span class="line">  [1,3,3,1],</span><br><span class="line"> [1,4,6,4,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="方法">方法</h2><p>每一行前补0，后补0，相加求和即为下一行的数。</p><blockquote><p>1 3 3 1 0</p></blockquote><blockquote><p>+ 0 1 3 3 1</p></blockquote><blockquote><p>= 1 4 6 4 1</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generate</span><span class="params">(self, numRows)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type numRows: int</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> numRows == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        </span><br><span class="line">        res = [[<span class="number">1</span>]]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, numRows):</span><br><span class="line">            res.append(map(<span class="keyword">lambda</span> x,y:x+y, res[<span class="number">-1</span>]+[<span class="number">0</span>], [<span class="number">0</span>]+res[<span class="number">-1</span>]))</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h1 id="杨辉三角-ii">119. 杨辉三角 II</h1><p><a href="https://leetcode-cn.com/problems/pascals-triangle-ii/" target="_blank" rel="noopener">Pascal's Triangle II</a></p><h2 id="题目描述-5">题目描述</h2><p>给定一个非负索引 k，其中 k ≤ 33，返回杨辉三角的第 k 行。</p><p>在杨辉三角中，每个数是它左上方和右上方的数的和。</p><p><strong>示例:</strong></p><blockquote><p>输入: 3 输出: [1,3,3,1]</p></blockquote><h2 id="方法-1">方法</h2><p>思路同上一题 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getRow</span><span class="params">(self, rowIndex)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type rowIndex: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res = [<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, rowIndex+<span class="number">1</span>):</span><br><span class="line">            res = list(map(<span class="keyword">lambda</span> x,y:x+y, res+[<span class="number">0</span>], [<span class="number">0</span>]+res))</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p><h1 id="买卖股票的最佳时机">121. 买卖股票的最佳时机</h1><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/" target="_blank" rel="noopener">Best Time to Buy and Sell Stock</a> ## 题目描述 给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p><p>如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。</p><p>注意你不能在买入股票前卖出股票。</p><p><strong>示例 1:</strong></p><blockquote><p>输入: [7,1,5,3,6,4] 输出: 5 解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。</p></blockquote><p><strong>示例 2:</strong></p><blockquote><p>输入: [7,6,4,3,1] 输出: 0 解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</p></blockquote><h2 id="方法一遍历">方法一：遍历</h2><p>根据题意，我们只需要找出数组中最大的差值即可，即 <code>max(prices[j] – prices[i]) ，i &lt; j</code> 。 如何得到最大的差值，只需要一次遍历即可，在遍历的用一个变量记录遍历到当前时的最小值即可。时间复杂度为 <code>O(n)</code>. <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type prices: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> prices <span class="keyword">is</span> <span class="keyword">None</span> <span class="keyword">or</span> len(prices)&lt;<span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        buy = prices[<span class="number">0</span>] <span class="comment"># 买入</span></span><br><span class="line">        profit = <span class="number">0</span> <span class="comment"># 利润</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(prices)):</span><br><span class="line">            <span class="keyword">if</span> prices[i] &lt; buy:</span><br><span class="line">                buy = prices[i]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> prices[i] - buy &gt; profit:</span><br><span class="line">                    profit = prices[i] - buy</span><br><span class="line">        <span class="keyword">return</span> profit</span><br></pre></td></tr></table></figure></p><h2 id="方法二kadanes-algorithm">方法二：Kadane's algorithm</h2><ul><li>方法同上面的53题-求数组中和最大的连续子数组序列。</li><li>如何转化为求数组中的和最大的连续子序列？相邻两个数作差即可，这样的话子序列的和就是我们在子序列开始卖出股票，在子序列最后买回股票所能得到的收益。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type prices: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        </span><br><span class="line">        max_so_far = max_ending_here = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(prices)):</span><br><span class="line">            max_ending_here = max(<span class="number">0</span>, max_ending_here + prices[i] - prices[i<span class="number">-1</span>])</span><br><span class="line">            max_so_far = max(max_so_far, max_ending_here)</span><br><span class="line">        <span class="keyword">return</span> max_so_far</span><br></pre></td></tr></table></figure></li></ul><p>测试结果比前一个方法慢</p><h1 id="买卖股票的最佳时机-ii">122. 买卖股票的最佳时机 II</h1><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/" target="_blank" rel="noopener">Best Time to Buy and Sell Stock II</a> ## 题目描述 给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p><p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p><strong>示例 1:</strong></p><p>输入: [7,1,5,3,6,4] 输出: 7 解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。</p><p><strong>示例 2:</strong></p><p>输入: [1,2,3,4,5] 输出: 4 解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。 因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</p><p><strong>示例 3:</strong></p><p>输入: [7,6,4,3,1] 输出: 0 解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</p><h2 id="方法遍历">方法：遍历</h2><p>如果后面的股价比前面的大，我们就买卖 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type prices: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> sum(max(prices[i+<span class="number">1</span>]-prices[i], <span class="number">0</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(len(prices)<span class="number">-1</span>))</span><br></pre></td></tr></table></figure></p><h1 id="两数之和-ii---输入有序数组">167. 两数之和 II - 输入有序数组</h1><h2 id="题目描述-6">题目描述</h2><p>给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。</p><p>函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。</p><p>说明:</p><p>返回的下标值（index1 和 index2）不是从零开始的。 你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。</p><p><strong>示例:</strong></p><blockquote><p>输入: numbers = [2, 7, 11, 15], target = 9</p></blockquote><blockquote><p>输出: [1,2]</p></blockquote><blockquote><p>解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。</p></blockquote><h2 id="方法-2">方法</h2><p>思路同第1题 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, numbers, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type numbers: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        dic = dict()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> index, value <span class="keyword">in</span> enumerate(numbers):</span><br><span class="line">            sub = target - value</span><br><span class="line">            <span class="keyword">if</span> sub <span class="keyword">in</span> dic:</span><br><span class="line">                <span class="keyword">return</span> (dic[sub]+<span class="number">1</span>, index+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dic[value] = index</span><br></pre></td></tr></table></figure></p><h1 id="参考">参考</h1><ul><li><a href="https://ask.hellobi.com/blog/wenwen/8617" target="_blank" rel="noopener">3个月用python刷完leetcode600题!-数组简单题（一）</a></li><li><a href="https://www.geeksforgeeks.org/largest-sum-contiguous-subarray/" target="_blank" rel="noopener">Largest Sum Contiguous Subarray</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用python刷LeetCode链表题(简单级)</title>
      <link href="/2019/02/20/%E7%94%A8python%E5%88%B7LeetCode%E4%B8%AD%E9%93%BE%E8%A1%A8%E9%A2%98(%E7%AE%80%E5%8D%95%E7%BA%A7)/"/>
      <url>/2019/02/20/%E7%94%A8python%E5%88%B7LeetCode%E4%B8%AD%E9%93%BE%E8%A1%A8%E9%A2%98(%E7%AE%80%E5%8D%95%E7%BA%A7)/</url>
      
        <content type="html"><![CDATA[<p><strong>练习题目：</strong></p><ul><li><ol start="21" style="list-style-type: decimal"><li>合并两个有序链表</li></ol></li><li><ol start="83" style="list-style-type: decimal"><li>删除排序链表中的重复元素</li></ol></li><li><ol start="141" style="list-style-type: decimal"><li>环形链表</li></ol></li><li><ol start="160" style="list-style-type: decimal"><li>相交链表</li></ol></li><li><ol start="203" style="list-style-type: decimal"><li>移除链表元素</li></ol></li><li><ol start="206" style="list-style-type: decimal"><li>反转链表</li></ol></li><li><ol start="234" style="list-style-type: decimal"><li>回文链表</li></ol></li><li><ol start="237" style="list-style-type: decimal"><li>删除链表中的节点</li></ol></li></ul><a id="more"></a><h1 id="合并两个有序链表">21. 合并两个有序链表</h1><p><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/" target="_blank" rel="noopener">Merge Two Sorted Lists</a></p><h2 id="题目描述">题目描述</h2><p>将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p><p><strong>示例：</strong></p><blockquote><p>输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4</p></blockquote><blockquote><p>输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</p></blockquote><h2 id="方法">方法</h2><p>同时遍历两个链表，每次选取两个链表中较小值的节点，依次连接起来，就能得到最终的链表。</p><p>注意： 1. 返回值要返回head.next 2. 无需判断循环后哪个不为空，or返回第一个为真的值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span><span class="params">(self, l1, l2)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type l1: ListNode</span></span><br><span class="line"><span class="string">        :type l2: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        head = cur = ListNode(<span class="number">0</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">and</span> l2:</span><br><span class="line">            <span class="keyword">if</span> l1.val &lt; l2.val:</span><br><span class="line">                cur.next = l1</span><br><span class="line">                l1 = l1.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur.next = l2</span><br><span class="line">                l2 = l2.next</span><br><span class="line">            cur = cur.next</span><br><span class="line">        cur.next = l1 <span class="keyword">or</span> l2</span><br><span class="line">        <span class="keyword">return</span> head.next</span><br></pre></td></tr></table></figure><h1 id="删除排序链表中的重复元素">83. 删除排序链表中的重复元素</h1><p><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/" target="_blank" rel="noopener">Remove Duplicates from Sorted List</a></p><h2 id="题目描述-1">题目描述</h2><p>给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。</p><p><strong>示例 1:</strong></p><blockquote><p>输入: 1-&gt;1-&gt;2</p></blockquote><blockquote><p>输出: 1-&gt;2</p></blockquote><p><strong>示例 2:</strong></p><blockquote><p>输入: 1-&gt;1-&gt;2-&gt;3-&gt;3</p></blockquote><blockquote><p>输出: 1-&gt;2-&gt;3</p></blockquote><h2 id="方法一两个指针">方法一：两个指针</h2><p>用两个指针来完成，分别记录要删除的链表元素和上一个元素。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteDuplicates</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        p = head</span><br><span class="line">        q = head.next</span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            <span class="keyword">if</span> p.val == q.val:</span><br><span class="line">                p.next = q.next</span><br><span class="line">                q = q.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                p = p.next</span><br><span class="line">                q = q.next</span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure></p><h2 id="方法二-一个指针">方法二： 一个指针</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteDuplicates</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        cur = head</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            <span class="keyword">while</span> cur.next <span class="keyword">and</span> cur.val == cur.next.val:</span><br><span class="line">                cur.next = cur.next.next</span><br><span class="line">            cur = cur.next</span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure><h1 id="环形链表">141. 环形链表</h1><p><a href="https://leetcode-cn.com/problems/linked-list-cycle/" target="_blank" rel="noopener">Linked List Cycle</a></p><h2 id="题目描述-2">题目描述</h2><p>给定一个链表，判断链表中是否有环。</p><h2 id="方法快慢双指针">方法：快慢双指针</h2><ul><li>通过使用具有<strong>不同速度</strong>的快、慢两个指针遍历链表，空间复杂度可以被降低至 <code>O(1)</code>。慢指针每次移动一步，而快指针每次移动两步。</li><li>如果列表中不存在环，最终快指针将会最先到达尾部，此时我们可以返回 false。</li><li>考虑一个环形链表，把慢指针和快指针想象成两个在环形赛道上跑步的运动员（分别称之为walker与runner）。而runner最终一定会追上walker。这是为什么呢？考虑下面这种情况（记作情况 A） - 假如runner只落后walker一步，在下一次迭代中，它们就会分别跑了一步或两步并相遇。</li><li>其他情况又会怎样呢？例如，我们没有考虑快跑者在慢跑者之后两步或三步的情况。但其实不难想到，因为在下一次或者下下次迭代后，又会变成上面提到的情况 A。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasCycle</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        walker = head</span><br><span class="line">        runner = head.next</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">while</span> walker != runner:</span><br><span class="line">                walker = walker.next</span><br><span class="line">                runner = runner.next.next</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure><p>略微改变语法形式，思路没有区别：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasCycle</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.next :</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        walker = head</span><br><span class="line">        runner = head.next</span><br><span class="line">        <span class="keyword">while</span> walker != runner:  </span><br><span class="line">            <span class="comment"># 改成判断快指针先到达尾部</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> runner <span class="keyword">or</span> <span class="keyword">not</span> runner.next:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span> </span><br><span class="line">            walker = walker.next</span><br><span class="line">            runner = runner.next.next</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure><p>更简洁的写法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasCycle</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        fast = slow = head</span><br><span class="line">        <span class="keyword">while</span> slow <span class="keyword">and</span> fast <span class="keyword">and</span> fast.next:</span><br><span class="line">            slow = slow.next</span><br><span class="line">            fast = fast.next.next</span><br><span class="line">            <span class="keyword">if</span> slow <span class="keyword">is</span> fast:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure><h1 id="相交链表">160. 相交链表</h1><p><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/solution/" target="_blank" rel="noopener">Intersection of Two Linked Lists</a></p><h2 id="题目描述-3">题目描述</h2><p>编写一个程序，找到两个单链表相交的起始节点。</p><p>如下面的两个链表：</p><div class="figure"><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png" alt="avatar"><p class="caption">avatar</p></div><p>在节点 c1 开始相交。</p><p>注意：</p><ul><li>如果两个链表没有交点，返回 null.</li><li>在返回结果后，两个链表仍须保持原有的结构。</li><li>可假定整个链表结构中没有循环。</li><li>程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。</li></ul><h2 id="方法两指针">方法：两指针</h2><ul><li>判断链表是否有交集，可以设置两个指针，一个指针从第一个链表开始遍历，遍历完第一个链表再遍历第二个链表，另一个指针从第二个链表开始遍历，遍历完第二个链表再遍历第一个链表.</li><li>不管两个链表在交集前的长度如何，遍历两个链表长度总和相同。</li><li>如果有交集的话，两个指针肯定会同时遍历到最后的交集部分。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getIntersectionNode</span><span class="params">(self, headA, headB)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head1, head1: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> headA <span class="keyword">or</span> <span class="keyword">not</span> headB:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        pa = headA</span><br><span class="line">        pb = headB</span><br><span class="line">        <span class="keyword">while</span> pa <span class="keyword">is</span> <span class="keyword">not</span> pb:</span><br><span class="line">            pa = headB <span class="keyword">if</span> pa == <span class="keyword">None</span> <span class="keyword">else</span> pa.next</span><br><span class="line">            pb = headA <span class="keyword">if</span> pb == <span class="keyword">None</span> <span class="keyword">else</span> pb.next</span><br><span class="line">        <span class="keyword">return</span> pa</span><br></pre></td></tr></table></figure><h1 id="移除链表元素">203. 移除链表元素</h1><h2 id="题目描述-4">题目描述</h2><p>删除链表中等于给定值 val 的所有节点。</p><p><strong>示例:</strong></p><blockquote><p>输入: 1-&gt;2-&gt;6-&gt;3-&gt;4-&gt;5-&gt;6, val = 6</p></blockquote><blockquote><p>输出: 1-&gt;2-&gt;3-&gt;4-&gt;5</p></blockquote><h2 id="方法dummy-node">方法：dummy node</h2><ul><li>有了第83题的思路，我们这里可以用一个指针来进行链表的遍历，</li><li>但是这里需要注意的是，头节点也需要进行判断，如果头节点的值等于val的话，我们不能返回头节点，所以这里很巧妙的重新生成了一个无关的头节点dummy node。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeElements</span><span class="params">(self, head, val)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :type val: int</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        dummy = ListNode(<span class="number">-1</span>)</span><br><span class="line">        dummy.next = head</span><br><span class="line">        cur = dummy</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            <span class="keyword">while</span> cur.next <span class="keyword">and</span> cur.next.val == val:</span><br><span class="line">                cur.next = cur.next.next</span><br><span class="line">            cur = cur.next</span><br><span class="line">        <span class="keyword">return</span> dummy.next</span><br></pre></td></tr></table></figure><h1 id="反转链表">206. 反转链表</h1><p><a href="https://leetcode-cn.com/problems/reverse-linked-list/" target="_blank" rel="noopener">Reverse Linked List</a></p><h2 id="题目描述-5">题目描述</h2><p>反转一个单链表。</p><p><strong>示例:</strong></p><blockquote><p>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</p></blockquote><blockquote><p>输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</p></blockquote><h2 id="方法两个指针头插法">方法：两个指针，头插法</h2><ul><li>用两个指针，p指针记录的是每次的队头元素，q指针指向下一个要插入队头的元素。</li><li>head帮忙指向下轮要头插的元素，待本轮指针翻转完之后要把该元素赋给q</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        p = head  <span class="comment"># p是指向每次的队头元素</span></span><br><span class="line">        q = head.next  <span class="comment"># q是指下一个要插入队头的元素</span></span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            head.next = q.next <span class="comment"># 保留后一个要插入的元素地址</span></span><br><span class="line">            q.next = p <span class="comment"># 指针反转，next为队头元素</span></span><br><span class="line">            p = q <span class="comment">#q插入，作为新的队头</span></span><br><span class="line">            q = head.next <span class="comment"># 重新指定下一个要插入队头的元素</span></span><br><span class="line">        <span class="keyword">return</span> p</span><br></pre></td></tr></table></figure><h2 id="较简洁的写法">较简洁的写法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        cur, prev = head, <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            cur.next, prev, cur = prev, cur, cur.next</span><br><span class="line">        <span class="keyword">return</span> prev</span><br></pre></td></tr></table></figure><h1 id="回文链表">234. 回文链表</h1><p><a href="https://leetcode-cn.com/problems/palindrome-linked-list/" target="_blank" rel="noopener">Palindrome Linked List</a></p><h2 id="题目描述-6">题目描述</h2><p>请判断一个链表是否为回文链表。</p><p><strong>示例 1:</strong></p><blockquote><p>输入: 1-&gt;2</p></blockquote><blockquote><p>输出: false</p></blockquote><p><strong>示例 2:</strong></p><blockquote><p>输入: 1-&gt;2-&gt;2-&gt;1</p></blockquote><blockquote><p>输出: true</p></blockquote><h2 id="方法两个指针">方法：两个指针</h2><p>两个指针，一个指针从前往后走，一个指针从后往前走，判断元素值是否相同，这里要分几个步骤来进行求解： 1、找到链表长度的一半，用追赶法，一个指针一次走两步，一个指针一次走一步 2、将后一半数组反转 3、比较两边元素是否相同，判断链表是否是回文链表 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        slow = fast = head</span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.next:</span><br><span class="line">            slow = slow.next</span><br><span class="line">            fast = fast.next.next</span><br><span class="line">        </span><br><span class="line">        node = <span class="keyword">None</span> <span class="comment">#反转后一半链表</span></span><br><span class="line">        <span class="keyword">while</span> slow:</span><br><span class="line">            nxt = slow.next </span><br><span class="line">            slow.next = node </span><br><span class="line">            node = slow <span class="comment"># node是反转后的第一个元素</span></span><br><span class="line">            slow = nxt </span><br><span class="line">            </span><br><span class="line">        <span class="keyword">while</span> node <span class="keyword">and</span> head:</span><br><span class="line">            <span class="keyword">if</span> node.val != head.val:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            node = node.next</span><br><span class="line">            head = head.next</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure></p><h1 id="删除链表中的节点">237. 删除链表中的节点</h1><p><a href="https://leetcode-cn.com/problems/delete-node-in-a-linked-list/" target="_blank" rel="noopener">Delete Node in a Linked List</a></p><h2 id="题目描述-7">题目描述</h2><p>输入：要求被删除的（非末尾）节点</p><p>函数功能：删除某个链表中的这个节点。无返回。</p><p><strong>示例 1:</strong></p><blockquote><p>输入: head = [4,5,1,9], node = 5</p></blockquote><blockquote><p>输出: [4,1,9]</p></blockquote><blockquote><p>解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.</p></blockquote><p><strong>示例 2:</strong></p><blockquote><p>输入: head = [4,5,1,9], node = 1</p></blockquote><blockquote><p>输出: [4,5,9]</p></blockquote><blockquote><p>解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.</p></blockquote><p><strong>说明:</strong></p><ul><li>链表至少包含两个节点。</li><li>链表中所有节点的值都是唯一的。</li><li>给定的节点为非末尾节点并且一定是链表中的一个有效节点。</li><li>不要从你的函数中返回任何结果。</li></ul><h2 id="方法替换值">方法:替换值</h2><ul><li>关键是理解题意，不给你整个链表，只给你一个节点，如何把这个节点删除。</li><li>其实我们没必要真的把这个节点删除，而是把这个节点对应的val值删除即可，</li><li>所以我们可以偷天换日，把下一个节点的值赋给这个节点，再把下一个节点删除。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteNode</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type node: ListNode</span></span><br><span class="line"><span class="string">        :rtype: void Do not return anything, modify node in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        node.val = node.next.val</span><br><span class="line">        node.next = node.next.next</span><br></pre></td></tr></table></figure><h1 id="参考">参考</h1><ul><li><a href="https://ask.hellobi.com/blog/wenwen/8653" target="_blank" rel="noopener">3个月用python刷完leetcode600题!-linked_list简单题</a></li><li><a href="https://blog.csdn.net/coder_orz/article/details/51529359" target="_blank" rel="noopener">21. Merge Two Sorted Lists [easy] (Python)</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>week3-贪心算法</title>
      <link href="/2018/10/24/week3-Greedy%20Algorithms/"/>
      <url>/2018/10/24/week3-Greedy%20Algorithms/</url>
      
        <content type="html"><![CDATA[<h1 id="概述">概述</h1><p>贪心算法是指，在对问题求解时，每一步选择中总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的是在某种意义上的局部最优解。</p><h2 id="实现过程">实现过程</h2><p>从问题的某一初始解出发；while 能朝给定总目标前进一步 do，求出可行解的一个解元素； 最后，由所有解元素组合成问题的一个可行解。</p><ol style="list-style-type: decimal"><li>创建数学模型来描述问题。</li><li>把求解的问题分成若干个子问题。</li><li>对每一子问题求解，得到子问题的局部最优解。</li><li>把子问题的解局部最优解合成原来解问题的一个解。</li></ol><p>注意： - 贪心算法与动态规划的不同在于它对每个子问题的解决方案都做出选择，不能回退。动态规划则会保存以前的运算结果，并根据以前的结果对当前进行选择，有回退功能。 - 贪心法可以解决一些最优化问题，如：求图中的最小生成树、求哈夫曼编码…… - 对于大部分的问题，贪心法通常都不能找出最佳解（不过也有例外），因为他们一般没有测试所有可能的解。贪心法容易过早做决定，因而没法达到最佳解。例如，所有对图着色问题。</p><h2 id="学习目标">学习目标</h2><ul><li>Practice implementing greedy solutions</li><li>Build greedy algorithms</li><li>Create a program for changing money optimally</li><li>Create a program for maximizing the value of a loot</li><li>Create a program for maximizing the number of prize places in a competition</li></ul><a id="more"></a><ol style="list-style-type: decimal"><li>Apply greedy strategy to solve various computational problems. This will usually require you to design an algorithm that repeatedly makes the most profitable move to construct a solution. You will then need to show that the moves of your algorithm are safe, meaning that they are consistent with at least one optimal solution.</li><li>Design and implement an eficient greedy algorithm for the following problems:</li></ol><ol style="list-style-type: lower-alpha"><li>changing money with a minimum number of coins;</li><li>maximizing the total value of a loot;</li><li>maximizing revenue in online ad placement;</li><li>minimizing work while collecting signatures;</li><li>maximizing the number of prize places in a competition;</li><li>finally, maximizing your salary!</li></ol><h1 id="兑换零钱money-change">兑换零钱(Money Change)</h1><p><strong>Task.</strong> 根据输入值，找到需要兑换 1, 5, 10面额硬币的最少个数.</p><p><strong>Input Format.</strong> 输入一个整数<span class="math inline">\(m\)</span>.</p><p><strong>Constraints.</strong> <span class="math inline">\(1 ≤ n ≤ 10^3\)</span>.</p><p><strong>Output Format.</strong> Output the minimum number of coins with denominations 1, 5, 10 that changes <span class="math inline">\(m\)</span>.</p><p><strong>Sample 1.</strong> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">28</span><br><span class="line">Output:</span><br><span class="line">6</span><br></pre></td></tr></table></figure></p><p>28 = 10 + 10 + 5 + 1 + 1 + 1.</p><h2 id="方法一">方法一</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_change</span><span class="params">(m)</span>:</span></span><br><span class="line">    coins = [<span class="number">10</span>, <span class="number">5</span>, <span class="number">1</span>]</span><br><span class="line">    n = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> a <span class="keyword">in</span> coins:        </span><br><span class="line">        <span class="keyword">while</span> m &gt;= a:</span><br><span class="line">            n += <span class="number">1</span></span><br><span class="line">            m -= a</span><br><span class="line">        <span class="keyword">if</span> m == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> n</span><br><span class="line">print(get_change(<span class="number">2</span>))</span><br><span class="line">print(get_change(<span class="number">28</span>))</span><br><span class="line">print(get_change(<span class="number">999</span>))</span><br></pre></td></tr></table></figure><pre><code>26104</code></pre><h2 id="方法二">方法二</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_changeC</span><span class="params">(m)</span>:</span></span><br><span class="line">    coins = [<span class="number">10</span>, <span class="number">5</span>, <span class="number">1</span>]</span><br><span class="line">    n = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> a <span class="keyword">in</span> coins:</span><br><span class="line">        <span class="comment"># Update the the number of coins 'held' in the amount.</span></span><br><span class="line">        n += m // a</span><br><span class="line">        <span class="comment"># Put remainder to the residuary amount.</span></span><br><span class="line">        m %= a</span><br><span class="line">    <span class="keyword">return</span> n</span><br><span class="line">print(get_changeC(<span class="number">2</span>))</span><br><span class="line">print(get_changeC(<span class="number">28</span>))</span><br><span class="line">print(get_changeC(<span class="number">999</span>))</span><br></pre></td></tr></table></figure><pre><code>26104</code></pre><h1 id="背包问题maximum-value-of-the-loot">背包问题(Maximum Value of the Loot )</h1><p><strong>Task.</strong> A thief finds much more loot than his bag can fit. Help him to find the most valuable combination of items assuming that any fraction of a loot item can be put into his bag.</p><p><strong>Input Format.</strong> 输入包可承受的重量(capacity)<span class="math inline">\(W\)</span>，<span class="math inline">\(n\)</span>件掠夺品的重量weights和价值values分别是<span class="math inline">\(w_i,v_i\)</span></p><p><strong>Constraints.</strong> <span class="math inline">\(1 ≤ n ≤ 10^3, 0 ≤W≤ 2·10^6, 0 ≤v_i≤ 2·10^6, 0 ≤ w_i ≤ 2·10^6\)</span> 所有数字都是整数.</p><p><strong>Output Format.</strong> Output the maximal value of fractions of items that fit into the knapsack.</p><p><strong>Sample 1.</strong> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">50, [20,50,30], [60,100,120]</span><br><span class="line">Output:</span><br><span class="line">180.0000</span><br></pre></td></tr></table></figure></p><p>选了第1件和第3件东西。</p><h2 id="方法一-1">方法一</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_optimal_value</span><span class="params">(capacity, weights, values)</span>:</span></span><br><span class="line">    value = <span class="number">0</span></span><br><span class="line">    n = len(weights)</span><br><span class="line">    <span class="comment"># A = [None] * n</span></span><br><span class="line">    pers = [<span class="keyword">None</span>] * n</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        pers[i] = values[i] / weights[i]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="keyword">if</span> capacity == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> value</span><br><span class="line">        m = pers.index(max(pers))</span><br><span class="line">        a = min(weights[m], capacity)</span><br><span class="line">        value += a*pers[m]</span><br><span class="line">        </span><br><span class="line">        weights[m] -= a</span><br><span class="line">        <span class="keyword">if</span> weights[m] == <span class="number">0</span>:</span><br><span class="line">            pers[m] = <span class="number">0</span></span><br><span class="line">        <span class="comment"># A[m] += a</span></span><br><span class="line">        capacity -= a</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line"></span><br><span class="line">print(<span class="string">"&#123;:.10f&#125;"</span>.format(get_optimal_value(<span class="number">10</span>, [<span class="number">30</span>], [<span class="number">500</span>])))</span><br><span class="line">print(<span class="string">"&#123;:.10f&#125;"</span>.format(get_optimal_value(<span class="number">50</span>, [<span class="number">20</span>,<span class="number">50</span>,<span class="number">30</span>], [<span class="number">60</span>,<span class="number">100</span>,<span class="number">120</span>])))</span><br></pre></td></tr></table></figure><pre><code>166.6666666667180.0000000000</code></pre><h2 id="方法二-optimization">方法二 Optimization</h2><p>首先按降序将 <span class="math inline">\(\frac{v}{w}\)</span> 排序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_optimal_value</span><span class="params">(capacity, weights, values)</span>:</span></span><br><span class="line">    value = <span class="number">0</span></span><br><span class="line">    weight_value_pairs = sorted(list(zip(weights, values)), </span><br><span class="line">                                key = <span class="keyword">lambda</span> x:x[<span class="number">1</span>]/x[<span class="number">0</span>],</span><br><span class="line">                                reverse=<span class="keyword">True</span>)</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">for</span> (w, v) <span class="keyword">in</span> weight_value_pairs:</span><br><span class="line">        <span class="comment"># If the item fit into the knapsack, put it and recalculate space left.</span></span><br><span class="line">        <span class="keyword">if</span> capacity - w &gt;= <span class="number">0</span>:</span><br><span class="line">            value += v</span><br><span class="line">            capacity -= w</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># Otherwise calculate weight of unit of the item and fill</span></span><br><span class="line">            <span class="comment"># the knapsack's left space.</span></span><br><span class="line">            value += (v / w) * capacity</span><br><span class="line">            capacity = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> capacity:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">            </span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line"></span><br><span class="line">print(<span class="string">"&#123;:.10f&#125;"</span>.format(get_optimal_value(<span class="number">10</span>, [<span class="number">30</span>], [<span class="number">500</span>])))</span><br><span class="line">print(<span class="string">"&#123;:.10f&#125;"</span>.format(get_optimal_value(<span class="number">50</span>, [<span class="number">20</span>,<span class="number">50</span>,<span class="number">30</span>], [<span class="number">60</span>,<span class="number">100</span>,<span class="number">120</span>])))</span><br></pre></td></tr></table></figure><pre><code>166.6666666667180.0000000000</code></pre><h1 id="广告点击最大收益">广告点击最大收益</h1><p>（Maximum Advertisement Revenue）</p><p><strong>Task.</strong> You have <span class="math inline">\(n\)</span> ads to place on a popular Internet page. For each ad, you know how much is the advertiser willing to pay for one click on this ad. You have set up <span class="math inline">\(n\)</span> slots on your page and estimated the expected number of clicks per day for each slot. Now, your goal is to distribute the ads among the slots to maximize the total revenue.</p><p><strong>Input Format.</strong> 给定两组序列<span class="math inline">\(a_1,a_2,...,a_n\)</span>(<span class="math inline">\(a_i\)</span> 是第 <span class="math inline">\(i\)</span> 条广告的点击利润)，<span class="math inline">\(b_1,b_2,...,b_n\)</span>(<span class="math inline">\(b_i\)</span> 是第 <span class="math inline">\(i\)</span> 个位置的平均每天点击数)，把它们对应分成<span class="math inline">\(n\)</span>组<span class="math inline">\((a_i,b_j)\)</span>使他们乘积的总和最大。</p><p><strong>Constraints.</strong> <span class="math inline">\(1 ≤ n ≤ 10^3, -10^5 ≤a_i,b_i≤ 10^5\)</span></p><p><strong>Output Format.</strong> 输出 <span class="math inline">\(\sum^n_{i=1}a_ic_i\)</span> 的最大值。<span class="math inline">\(c_1,c_2,...,c_n\)</span>是<span class="math inline">\(b_1,b_2,...,b_n\)</span>的重排列</p><p><strong>Sample 1.</strong> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[1,3,-5], [-2,4,1]</span><br><span class="line">Output:</span><br><span class="line">23</span><br></pre></td></tr></table></figure></p><p><span class="math inline">\(23 = 3 · 4 + 1 · 1 + (−5) · (−2).\)</span></p><p>先排好序，最大的在前，最大的两个乘积，随后循环,这样得到的乘积和最大。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">max_dot_product</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    a = sorted(a, reverse=<span class="keyword">True</span>)</span><br><span class="line">    b = sorted(b, reverse=<span class="keyword">True</span>)</span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(a)):</span><br><span class="line">        res += a[i] * b[i]</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(max_dot_product([<span class="number">23</span>], [<span class="number">39</span>]))</span><br><span class="line">print(max_dot_product([<span class="number">1</span>,<span class="number">3</span>,<span class="number">-5</span>], [<span class="number">-2</span>,<span class="number">4</span>,<span class="number">1</span>]))</span><br></pre></td></tr></table></figure><pre><code>89723</code></pre><h1 id="找房客签字的最佳时间点">找房客签字的最佳时间点</h1><p>Collecting Signatures</p><p><strong>Task.</strong> You are responsible for collecting signatures from all tenants of a certain building. For each tenant, you know a period of time when he or she is at home. You would like to collect all signatures by visiting the building as few times as possible.Your goal is to mark as few points on a line as possible so that each segment contains at least one marked point.找最少的标记时间点数<span class="math inline">\(m\)</span>，使每个时间段内都有标记时间点。</p><p><strong>Input Format.</strong> <span class="math inline">\(n\)</span>段时间 <span class="math inline">\(\{[a_0,b_0],[a_1,b_1],...,[a_{n-1},b_{n-1}]\}\)</span></p><p><strong>Constraints.</strong> <span class="math inline">\(1 ≤ n ≤ 100, -0≤a_i ≤b_i≤ 10^9\)</span></p><p><strong>Output Format.</strong> 标记的位置点</p><p><strong>Sample 1.</strong> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[(4,7), (1,3), (2,5), (5,6)]</span><br><span class="line">Output:</span><br><span class="line">3 6</span><br></pre></td></tr></table></figure></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">optimal_points</span><span class="params">(segments)</span>:</span></span><br><span class="line">    <span class="comment"># 按结束时间先后排序</span></span><br><span class="line">    segments.sort(key = <span class="keyword">lambda</span> x:x[<span class="number">1</span>]) </span><br><span class="line">    points = []</span><br><span class="line">    <span class="keyword">for</span> s <span class="keyword">in</span> segments:</span><br><span class="line">        points.append(s[<span class="number">0</span>])</span><br><span class="line">        points.append(s[<span class="number">1</span>])    </span><br><span class="line">    </span><br><span class="line">    result = []</span><br><span class="line">    n = len(segments)       </span><br><span class="line">    c = <span class="number">1</span></span><br><span class="line">    i = <span class="number">1</span></span><br><span class="line">    result.append(points[c])   <span class="comment"># 加入第一个结束时间点为标记点</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; n:</span><br><span class="line">        <span class="keyword">if</span> points[i*<span class="number">2</span>] &gt; points[c]: <span class="comment"># 如果下一段起始时间点晚于标记点</span></span><br><span class="line">            c = i*<span class="number">2</span>+<span class="number">1</span>               <span class="comment"># 则把这段的结束时间点加入标记点</span></span><br><span class="line">            result.append(points[c])            </span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">points1 = optimal_points([(<span class="number">1</span>,<span class="number">3</span>), (<span class="number">2</span>,<span class="number">5</span>), (<span class="number">3</span>,<span class="number">6</span>)])</span><br><span class="line"><span class="comment">#print(len(points1))</span></span><br><span class="line"><span class="keyword">for</span> p <span class="keyword">in</span> points1:</span><br><span class="line">    print(p, end=<span class="string">' '</span>)</span><br><span class="line">print(<span class="string">"\n"</span>)    </span><br><span class="line">points2 = optimal_points([(<span class="number">4</span>,<span class="number">7</span>), (<span class="number">1</span>,<span class="number">3</span>), (<span class="number">2</span>,<span class="number">5</span>), (<span class="number">5</span>,<span class="number">6</span>)])</span><br><span class="line"><span class="comment">#print(len(points2))</span></span><br><span class="line"><span class="keyword">for</span> p <span class="keyword">in</span> points2:</span><br><span class="line">    print(p, end=<span class="string">' '</span>)</span><br></pre></td></tr></table></figure><pre><code>3 3 6 </code></pre><h1 id="分不同数量的奖品">分不同数量的奖品</h1><p><strong>Task.</strong> 你在给孩子们组织一场有趣的竞赛。你有<span class="math inline">\(n\)</span> 个糖果作为奖品.你想把这些奖品给比赛前 <span class="math inline">\(k\)</span> 名的孩子。名次越高，获奖糖果应该越多。为了使尽可能多孩子开心，你要找最多的获奖名额<span class="math inline">\(k\)</span>.</p><p><strong>Input Format.</strong> 整数 <span class="math inline">\(n\)</span></p><p><strong>Constraints.</strong> $1 ≤ n ≤ 10^9 $</p><p><strong>Output Format.</strong> 获奖名额 <span class="math inline">\(k\)</span> 和 分别获得的糖果数 (每个名次的获奖糖果数不应相同.)</p><p><strong>Sample 1.</strong> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">7</span><br><span class="line">Output:</span><br><span class="line">3</span><br><span class="line">1 2 4</span><br></pre></td></tr></table></figure></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">optimal_summands</span><span class="params">(n)</span>:</span></span><br><span class="line">    summands = [<span class="number">1</span>]   <span class="comment">#被加数</span></span><br><span class="line">    n -= <span class="number">1</span> <span class="comment"># 剩余糖果数</span></span><br><span class="line">    <span class="keyword">while</span> n:</span><br><span class="line">        last_element = summands[<span class="number">-1</span>] </span><br><span class="line">        <span class="comment"># Save move: check whether the incremented last element can be used as</span></span><br><span class="line">        <span class="comment"># the next summand.</span></span><br><span class="line">        <span class="keyword">if</span> (last_element + <span class="number">1</span>) * <span class="number">2</span> &lt;= n: <span class="comment"># 如果最后一个数比n的一半还小</span></span><br><span class="line">            n -= last_element + <span class="number">1</span></span><br><span class="line">            summands.append(last_element + <span class="number">1</span>) <span class="comment"># 添加获奖名额及获奖数</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> last_element &gt;= n:   <span class="comment"># 如果最后一个数大于n</span></span><br><span class="line">                n += summands.pop()</span><br><span class="line">            summands.append(n) <span class="comment"># 添加获奖名额及获奖数</span></span><br><span class="line">            n = <span class="number">0</span>    </span><br><span class="line">    <span class="keyword">return</span> summands</span><br><span class="line"></span><br><span class="line">summands = optimal_summands(<span class="number">2</span>)</span><br><span class="line">print(len(summands))</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> summands:</span><br><span class="line">    print(x, end=<span class="string">' '</span>)</span><br><span class="line">print(<span class="string">"\n"</span>)</span><br><span class="line">summands = optimal_summands(<span class="number">6</span>)</span><br><span class="line">print(len(summands))</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> summands:</span><br><span class="line">    print(x, end=<span class="string">' '</span>)</span><br><span class="line">print(<span class="string">"\n"</span>)</span><br><span class="line">summands = optimal_summands(<span class="number">7</span>)</span><br><span class="line">print(len(summands))</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> summands:</span><br><span class="line">    print(x, end=<span class="string">' '</span>)</span><br><span class="line">print(<span class="string">"\n"</span>)</span><br></pre></td></tr></table></figure><pre><code>12 31 2 3 31 2 4 </code></pre><p>这里设置<code>&lt;=n</code> 而不是<code>&lt;n</code> 是要考虑要奖品数为2的情况，必须把之前的1退回去。</p><h1 id="最大薪水">最大薪水</h1><p>Maximum Salary</p><p><strong>Task.</strong> As the last question of a successful interview, your boss gives you a few pieces of paper with numbers on it and asks you to compose a largest number from these numbers. The resulting number is going to be your salary, so you are very much interested in maximizing this number. How can you do this?不同的数拼成一个最大数(这些数未必只是一位数。(比如23和3，应该拼成323最大)</p><p><strong>Input Format.</strong> <span class="math inline">\(n\)</span>个数 <span class="math inline">\(a_0,a_1,...,a_n\)</span></p><p><strong>Constraints.</strong> <span class="math inline">\(1 ≤ n ≤ 100, 1≤a_i ≤ 10^3\)</span></p><p><strong>Output Format.</strong> 可组成的最大数</p><p><strong>Sample 1.</strong> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[21,2]</span><br><span class="line">Output:</span><br><span class="line">221</span><br></pre></td></tr></table></figure></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isGreaterOrEqual</span><span class="params">(digit,maxDigit)</span>:</span></span><br><span class="line">    d = int(str(digit)+str(maxDigit))</span><br><span class="line">    m = int(str(maxDigit)+str(digit))            </span><br><span class="line">    <span class="keyword">return</span> (d &gt;= m)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">largest_number</span><span class="params">(a)</span>:</span></span><br><span class="line">    res = <span class="string">""</span></span><br><span class="line">    r=[]</span><br><span class="line">    <span class="keyword">while</span> a != []:</span><br><span class="line">        maxDigit = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> digit <span class="keyword">in</span> a:</span><br><span class="line">            <span class="keyword">if</span> isGreaterOrEqual(digit,maxDigit):</span><br><span class="line">                maxDigit = digit</span><br><span class="line">        r.append(maxDigit)</span><br><span class="line">        a.remove(maxDigit)              </span><br><span class="line">    <span class="keyword">for</span> rr <span class="keyword">in</span> r:</span><br><span class="line">        res += str(rr)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">print(largest_number([<span class="number">21</span>,<span class="number">2</span>]))</span><br><span class="line">print(largest_number([<span class="number">23</span>,<span class="number">39</span>,<span class="number">92</span>]))</span><br><span class="line">print(largest_number([<span class="number">9</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">9</span>]))</span><br></pre></td></tr></table></figure><pre><code>22192392399641</code></pre><p>参考： - <a href="https://www.coursera.org/learn/algorithmic-toolbox/home/week/3" target="_blank" rel="noopener">Coursera：algorithmic toolbox(week3)</a></p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> Algorithm - 背包问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>week2-Algorithm Warmup</title>
      <link href="/2018/09/28/week2-algorithm_warmup/"/>
      <url>/2018/09/28/week2-algorithm_warmup/</url>
      
        <content type="html"><![CDATA[<ul><li>Estimate the running time of an algorithm</li><li>Practice implementing efficient solutions</li><li>Practice solving programming challenges</li><li>Implement programs that are several orders of magnitude faster than straightforward programs</li></ul><h1 id="fibonacci-numbers">Fibonacci Numbers</h1><h2 id="斐波那契数列">斐波那契数列</h2><p><strong>Task.</strong> Given an integer <span class="math inline">\(n\)</span>, find the last digit of the nth Fibonacci number <span class="math inline">\(F_n\)</span>.</p><a id="more"></a><p><strong>Input Format.</strong> The input consists of a single integer <span class="math inline">\(n\)</span>.</p><p><strong>Constraints.</strong> $0 ≤ n ≤ 45 $.</p><p><strong>Output Format.</strong> Output <span class="math inline">\(F_n\)</span>.</p><p><strong>Sample 1.</strong> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">10</span><br><span class="line">Output:</span><br><span class="line">55</span><br></pre></td></tr></table></figure></p><p><span class="math inline">\(F_{10} = 55\)</span></p><p>0 1 1 2 3 5 8 13</p><h2 id="naive-algorithm">Naive Algorithm</h2><p>递归 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc_fib</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> calc_fib(n - <span class="number">1</span>) + calc_fib(n - <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">print(calc_fib(<span class="number">6</span>))</span><br><span class="line">print(calc_fib(<span class="number">20</span>))</span><br><span class="line">print(calc_fib(<span class="number">34</span>))</span><br></pre></td></tr></table></figure></p><pre><code>867655702887</code></pre><p>时间复杂度：<span class="math inline">\(O(2^n)\)</span></p><h2 id="fast-algorithm">Fast Algorithm</h2><p>动态规划 - 递归 + 记忆化 -&gt; 递推 - 递推公式：A[i] = A[i-1] + A[i-2]</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc_fibFast</span><span class="params">(n)</span>:</span></span><br><span class="line">    A = [<span class="keyword">None</span>]* (n+<span class="number">1</span>)</span><br><span class="line">    A[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">    A[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n+<span class="number">1</span>):</span><br><span class="line">        A[i] = A[i<span class="number">-1</span>] + A[i<span class="number">-2</span>]</span><br><span class="line">    <span class="keyword">return</span> A[n]</span><br><span class="line"></span><br><span class="line">print(calc_fibFast(<span class="number">6</span>))</span><br><span class="line">print(calc_fibFast(<span class="number">20</span>))</span><br><span class="line">print(calc_fibFast(<span class="number">34</span>))</span><br></pre></td></tr></table></figure><pre><code>867655702887</code></pre><p>时间复杂度：<span class="math inline">\(O(n)\)</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc_fibFast</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line"></span><br><span class="line">    previous = <span class="number">0</span></span><br><span class="line">    current  = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(n - <span class="number">1</span>):</span><br><span class="line">        previous, current = current, previous + current</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> current</span><br><span class="line"></span><br><span class="line">print(calc_fibFast(<span class="number">6</span>))</span><br><span class="line">print(calc_fibFast(<span class="number">20</span>))</span><br><span class="line">print(calc_fibFast(<span class="number">34</span>))</span><br></pre></td></tr></table></figure><pre><code>867655702887</code></pre><h1 id="last-digit-of-a-large-fibonacci-number">Last Digit of a Large Fibonacci Number</h1><h2 id="求斐波那契数的个位数">求斐波那契数的个位数</h2><p><strong>Task.</strong> Given an integer <span class="math inline">\(n\)</span>, fnd the last digit of the nth Fibonacci number <span class="math inline">\(F_n\)</span> mod <span class="math inline">\(m\)</span> (that is, <span class="math inline">\(F_n\)</span> mod 10).</p><p><strong>Input Format.</strong> The input consists of a single integer <span class="math inline">\(n\)</span>.</p><p><strong>Constraints.</strong> $0 ≤ n ≤ 10^{7} $.</p><p><strong>Output Format.</strong> Output the last digit of <span class="math inline">\(F_n\)</span>.</p><p><strong>Sample 1.</strong> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">3</span><br><span class="line">Output:</span><br><span class="line">2</span><br></pre></td></tr></table></figure></p><p><span class="math inline">\(F_3 = 2\)</span>. ## Naive Algorithm</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_fibonacci_last_digit_naive</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line"></span><br><span class="line">    previous = <span class="number">0</span></span><br><span class="line">    current  = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(n - <span class="number">1</span>):</span><br><span class="line">        previous, current = current, previous + current</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> current % <span class="number">10</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(get_fibonacci_last_digit_naive(<span class="number">6</span>))</span><br><span class="line">print(get_fibonacci_last_digit_naive(<span class="number">20</span>))</span><br><span class="line">print(get_fibonacci_last_digit_naive(<span class="number">34</span>))</span><br><span class="line">print(get_fibonacci_last_digit_naive(<span class="number">331</span>))</span><br></pre></td></tr></table></figure><pre><code>8579</code></pre><h2 id="fast-algorithm-1">Fast Algorithm</h2><p>每次只保留斐波那契数的个位数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_fibonacci_last_digit_Fast</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line"></span><br><span class="line">    previous = <span class="number">0</span></span><br><span class="line">    current  = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(n - <span class="number">1</span>):</span><br><span class="line">        previous, current = current, (previous + current) % <span class="number">10</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> current</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(get_fibonacci_last_digit_Fast(<span class="number">6</span>))</span><br><span class="line">print(get_fibonacci_last_digit_Fast(<span class="number">20</span>))</span><br><span class="line">print(get_fibonacci_last_digit_Fast(<span class="number">34</span>))</span><br><span class="line">print(get_fibonacci_last_digit_Fast(<span class="number">331</span>))</span><br></pre></td></tr></table></figure><pre><code>8579</code></pre><h1 id="greatest-common-divisor">Greatest Common Divisor</h1><h2 id="最大公约数">最大公约数</h2><p><strong>Task.</strong> Given two integers <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span>, find their greatest common divisor.</p><p><strong>Input Format.</strong> The two integers <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> are given in the same line separated by space..</p><p><strong>Constraints.</strong> <span class="math inline">\(1 ≤ a, b ≤ 2·10^{9}\)</span>.</p><p><strong>Output Format.</strong> Output GCD(a, b).</p><p><strong>Sample 1.</strong> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">18 35</span><br><span class="line">Output:</span><br><span class="line">1</span><br></pre></td></tr></table></figure></p><p>18 and 35 do not have common non-trivial divisors. ## Naive Algorithm 同时能整除a和b的最大的数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gcd_naive</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    current_gcd = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> d <span class="keyword">in</span> range(<span class="number">2</span>, min(a, b) + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> a % d == <span class="number">0</span> <span class="keyword">and</span> b % d == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> d &gt; current_gcd:</span><br><span class="line">                current_gcd = d</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> current_gcd</span><br><span class="line">print(gcd_naive(<span class="number">12</span>, <span class="number">4</span>))</span><br><span class="line">print(gcd_naive(<span class="number">18</span>, <span class="number">35</span>))</span><br><span class="line">print(gcd_naive(<span class="number">28851538</span>, <span class="number">1183019</span>))</span><br></pre></td></tr></table></figure><pre><code>4117657</code></pre><h2 id="fast-algorithm-2">Fast Algorithm</h2><p>辗转相除法， 又名欧几里德算法（Euclidean algorithm）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gcd_Euclid</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> b == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    r = a % b</span><br><span class="line">    <span class="keyword">return</span> gcd_Euclid(b, r)</span><br><span class="line">    </span><br><span class="line">print(gcd_Euclid(<span class="number">12</span>, <span class="number">4</span>))</span><br><span class="line">print(gcd_Euclid(<span class="number">18</span>, <span class="number">35</span>))</span><br><span class="line">print(gcd_Euclid(<span class="number">28851538</span>, <span class="number">1183019</span>))</span><br></pre></td></tr></table></figure><pre><code>4117657</code></pre><h1 id="least-common-multiple">Least Common Multiple</h1><h2 id="最小公倍数">最小公倍数</h2><p><strong>Task.</strong> Given two integers <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span>, fnd their least common multiple.</p><p><strong>Input Format.</strong> The two integers <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> are given in the same line separated by space..</p><p><strong>Constraints.</strong> <span class="math inline">\(1 ≤ a, b ≤ 2·10^{9}\)</span>.</p><p><strong>Output Format.</strong> Output the least common multiple of <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span>.</p><p><strong>Sample 1.</strong> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">6 8</span><br><span class="line">Output:</span><br><span class="line">24</span><br></pre></td></tr></table></figure></p><p>Among all the positive integers that are divisible by both 6 and 8 (e.g., 48, 480, 24), 24 is the smallest one. ## Naive Algorithm 同时是a和b的倍数的最小值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lcm_naive</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> l <span class="keyword">in</span> range(<span class="number">1</span>, a*b + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> l % a == <span class="number">0</span> <span class="keyword">and</span> l % b == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> l</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a*b</span><br><span class="line"></span><br><span class="line">print(lcm_naive(<span class="number">6</span>, <span class="number">8</span>))</span><br><span class="line">print(lcm_naive(<span class="number">28851538</span>, <span class="number">1183019</span>))</span><br></pre></td></tr></table></figure><pre><code>241933053046</code></pre><h2 id="fast-algorithm-3">Fast Algorithm</h2><p>性质：两个数的乘积等于这两个数的最大公约数与最小公倍数的积。用辗转相除法求出最大公约数，再求最小公倍数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gcd_Euclid</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> b == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    r = a % b</span><br><span class="line">    <span class="keyword">return</span> gcd_Euclid(b, r)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lcm_fast</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> a*b // gcd_Euclid(a, b)</span><br><span class="line"></span><br><span class="line">print(lcm_fast(<span class="number">6</span>, <span class="number">8</span>))</span><br><span class="line">print(lcm_fast(<span class="number">28851538</span>, <span class="number">1183019</span>))</span><br></pre></td></tr></table></figure><pre><code>241933053046</code></pre><h1 id="fibonacci-number-modulo-m">Fibonacci Number modulo m</h1><h2 id="斐波那契数取余">斐波那契数取余</h2><table><thead><tr class="header"><th><span class="math inline">\(i\)</span></th><th>0</th></tr></thead><tbody><tr class="odd"><td><span class="math inline">\(F_i\)</span></td><td>0</td></tr><tr class="even"><td><span class="math inline">\(F_i\)</span> mod 2</td><td>0</td></tr><tr class="odd"><td><span class="math inline">\(F_i\)</span> mod 3</td><td>0</td></tr></tbody></table><p>可以看出序列是有周期性的。模3以01120221循环，模2以011循环。此类循环都是以01开始，称为皮萨诺周期(pisano period)</p><p><span class="math inline">\(F_(2015)\)</span> mod 3 只需要找到2015被8除的余数. Since 2015 = 251 · 8 + 7, we conclude that <span class="math inline">\(F_(2015)\)</span> mod 3 = <span class="math inline">\(F_7\)</span> mod 3 = 1.</p><p><strong>Task.</strong> Given two integers <span class="math inline">\(m\)</span> and <span class="math inline">\(n\)</span>, output <span class="math inline">\(F_n\)</span> mod <span class="math inline">\(m\)</span> (that is, the remainder of <span class="math inline">\(F_n\)</span> when divided by <span class="math inline">\(m\)</span>).</p><p><strong>Input Format.</strong> The input consists of two integers <span class="math inline">\(m\)</span> and <span class="math inline">\(n\)</span> given on the same line (separated by a space).</p><p><strong>Constraints.</strong> <span class="math inline">\(1 ≤ n ≤ 10^{18},2 ≤ m ≤ 10^{3}\)</span>.</p><p><strong>Output Format.</strong> Output <span class="math inline">\(F_n\)</span> mod <span class="math inline">\(m\)</span>.</p><p><strong>Sample 1.</strong> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">239 1000</span><br><span class="line">Output:</span><br><span class="line">161</span><br></pre></td></tr></table></figure></p><p><span class="math inline">\(F_239 mod 1000 = 39 679 027 332 006 820 581 608 740 953 902 289 877 834 488 152 161 (mod 1 000) = 161\)</span>. ## Naive Algorithm</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_fibonacci_huge_naive</span><span class="params">(n, m)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line"></span><br><span class="line">    previous = <span class="number">0</span></span><br><span class="line">    current  = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(n - <span class="number">1</span>):</span><br><span class="line">        previous, current = current, previous + current</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> current % m</span><br><span class="line">print(get_fibonacci_huge_naive(<span class="number">239</span>, <span class="number">1000</span>))</span><br></pre></td></tr></table></figure><pre><code>161</code></pre><h2 id="fast-algorithm-4">Fast Algorithm</h2><p>计算Fibonacci数直到m平方，因为pisano period不可能大于这个数。</p><p>因为最后一个数的后面是下一周期的0和1，那假设最后两个数分别是x和y，则(x+y)%m=0, (y+0)%m=1，所以 y=1, x=m-1为判别式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_fibonacci_huge_fast</span><span class="params">(n, m)</span>:</span></span><br><span class="line">    A = [<span class="keyword">None</span>]* (m**<span class="number">2</span>)</span><br><span class="line">    A[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">    A[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, m**<span class="number">2</span>):</span><br><span class="line">        A[i] = (A[i<span class="number">-1</span>] + A[i<span class="number">-2</span>]) % m</span><br><span class="line">        <span class="keyword">if</span> A[i] == <span class="number">1</span> <span class="keyword">and</span> A[i<span class="number">-1</span>] == m<span class="number">-1</span>:</span><br><span class="line">            period = i+<span class="number">1</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    t = n % period</span><br><span class="line">    <span class="keyword">return</span> A[t] % m</span><br><span class="line"></span><br><span class="line">print(get_fibonacci_huge_fast(<span class="number">239</span>, <span class="number">1000</span>))</span><br><span class="line">print(get_fibonacci_huge_fast(<span class="number">2816213588</span>, <span class="number">239</span>))</span><br></pre></td></tr></table></figure><pre><code>161151</code></pre><h1 id="last-digit-of-the-sum-of-fibonacci-numbers">Last Digit of the Sum of Fibonacci Numbers</h1><h2 id="求斐波那契数之和的个位数">求斐波那契数之和的个位数</h2><p><strong>Task.</strong> Given an integer <span class="math inline">\(n\)</span>, fnd the last digit of the sum <span class="math inline">\(F_0 + F_1 + · · · + F_n\)</span>.</p><p><strong>Input Format.</strong> The input consists of a single integer <span class="math inline">\(n\)</span>.</p><p><strong>Constraints.</strong> <span class="math inline">\(0 ≤ n ≤ 10^{18}\)</span>.</p><p><strong>Output Format.</strong> Output the last digit of <span class="math inline">\(F_0 + F_1 + · · · + F_n\)</span>.</p><p><strong>Sample 1.</strong> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">3</span><br><span class="line">Output:</span><br><span class="line">4</span><br></pre></td></tr></table></figure></p><p><span class="math inline">\(F_0 + F_1 + F_2 + F_3 = 0 + 1 + 1 + 2= 4\)</span>. ## Naive Algorithm</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibonacci_sum_naive</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line"></span><br><span class="line">    previous = <span class="number">0</span></span><br><span class="line">    current  = <span class="number">1</span></span><br><span class="line">    sum      = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(n - <span class="number">1</span>):</span><br><span class="line">        previous, current = current, previous + current</span><br><span class="line">        sum += current</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sum % <span class="number">10</span></span><br><span class="line">print(fibonacci_sum_naive(<span class="number">3</span>))</span><br><span class="line">print(fibonacci_sum_naive(<span class="number">100</span>))</span><br><span class="line">print(fibonacci_sum_naive(<span class="number">240</span>))</span><br></pre></td></tr></table></figure><pre><code>450</code></pre><h2 id="fast-algorithm-5">Fast Algorithm</h2><p>斐波那契数列的递归定义形式如下：</p><p><span class="math display">\[a_n=     \begin{cases}    a_{n-1}+a_{n-2},\\    1,&amp; {n\leq 1}    \end{cases}\]</span></p><p>斐波那契数列求和公式：</p><p><span class="math display">\[S_n= 2a_n+a_{n-1}-1\]</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibonacci_sum_fast</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line"></span><br><span class="line">    previous = <span class="number">0</span></span><br><span class="line">    current  = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(n - <span class="number">1</span>):</span><br><span class="line">        previous, current = current, (previous + current)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="number">2</span>*current + previous - <span class="number">1</span>) % <span class="number">10</span></span><br><span class="line">print(fibonacci_sum_fast(<span class="number">3</span>))</span><br><span class="line">print(fibonacci_sum_fast(<span class="number">100</span>))</span><br><span class="line">print(fibonacci_sum_fast(<span class="number">240</span>))</span><br><span class="line">print(fibonacci_sum_fast(<span class="number">999999</span>))</span><br></pre></td></tr></table></figure><pre><code>4500</code></pre><h2 id="more-fast-algorithm">More Fast Algorithm</h2><p>去掉循环,用pisano period方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibonacci_sum_more_fast</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    A = [<span class="keyword">None</span>]* (<span class="number">100</span>)</span><br><span class="line">    A[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">    A[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, <span class="number">100</span>):</span><br><span class="line">        A[i] = (A[i<span class="number">-1</span>] + A[i<span class="number">-2</span>]) % <span class="number">10</span></span><br><span class="line">        <span class="keyword">if</span> A[i] == <span class="number">1</span> <span class="keyword">and</span> A[i<span class="number">-1</span>] == <span class="number">9</span>:</span><br><span class="line">            period = i+<span class="number">1</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    t = n % period</span><br><span class="line">    <span class="keyword">if</span> t == <span class="number">0</span>: </span><br><span class="line">        t = period<span class="number">-1</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="number">2</span>*A[t] + A[t<span class="number">-1</span>] - <span class="number">1</span>) % <span class="number">10</span></span><br><span class="line">print(fibonacci_sum_more_fast(<span class="number">0</span>))</span><br><span class="line">print(fibonacci_sum_more_fast(<span class="number">3</span>))</span><br><span class="line">print(fibonacci_sum_more_fast(<span class="number">100</span>))</span><br><span class="line">print(fibonacci_sum_more_fast(<span class="number">240</span>))</span><br><span class="line">print(fibonacci_sum_more_fast(<span class="number">999999</span>))</span><br><span class="line">print(fibonacci_sum_more_fast(<span class="number">832564823476</span>))</span><br></pre></td></tr></table></figure><pre><code>045003</code></pre><p>考虑到余数t==0的情况，A[t-1]值会出问题，因为是新一周期循环，值为0，所以，可以令t=period-1</p><h1 id="last-digit-of-the-sum-of-fibonacci-numbers-again">Last Digit of the Sum of Fibonacci Numbers Again</h1><h2 id="求斐波那契数之部分和的个位数">求斐波那契数之部分和的个位数</h2><p><strong>Task.</strong> Given two non-negative integers <span class="math inline">\(m\)</span> and <span class="math inline">\(n\)</span>, where <span class="math inline">\(m≤n\)</span>, fnd the last digit of the sum <span class="math inline">\(F_m + F_{m+1} + · · · + F_n\)</span>.</p><p><strong>Input Format.</strong> The input consists of two non-negative integers <span class="math inline">\(m\)</span> and <span class="math inline">\(n\)</span> separated by a space.</p><p><strong>Constraints.</strong> <span class="math inline">\(0 ≤m≤ n ≤ 10^{18}\)</span>.</p><p><strong>Output Format.</strong> Output the last digit of <span class="math inline">\(F_m + F_{m+1} + · · · + F_n\)</span>.</p><p><strong>Sample 1.</strong> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">3 7</span><br><span class="line">Output:</span><br><span class="line">1</span><br></pre></td></tr></table></figure></p><p><span class="math inline">\(F_3 + F_4 + F_5 + F_6 + F_7 = 2 + 3 + 5 + 8 + 13 = 31\)</span>. ## Naive Algorithm</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibonacci_partial_sum_naive</span><span class="params">(from_, to)</span>:</span></span><br><span class="line">    sum = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    current = <span class="number">0</span></span><br><span class="line">    next  = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(to + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> i &gt;= from_:</span><br><span class="line">            sum += current</span><br><span class="line"></span><br><span class="line">        current, next = next, current + next</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sum % <span class="number">10</span></span><br><span class="line">print(fibonacci_partial_sum_naive(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">print(fibonacci_partial_sum_naive(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">print(fibonacci_partial_sum_naive(<span class="number">3</span>, <span class="number">7</span>))</span><br><span class="line">print(fibonacci_partial_sum_naive(<span class="number">5</span>, <span class="number">7</span>))</span><br><span class="line">print(fibonacci_partial_sum_naive(<span class="number">10</span>, <span class="number">10</span>))</span><br><span class="line">print(fibonacci_partial_sum_naive(<span class="number">10</span>, <span class="number">200</span>))</span><br></pre></td></tr></table></figure><pre><code>121652</code></pre><h2 id="fast-algorithm-6">Fast Algorithm</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibonacci_partial_sum_fast</span><span class="params">(from_, to)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> to == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    A = [<span class="keyword">None</span>]* (<span class="number">100</span>)</span><br><span class="line">    A[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">    A[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, <span class="number">100</span>):</span><br><span class="line">        A[i] = (A[i<span class="number">-1</span>] + A[i<span class="number">-2</span>])%<span class="number">10</span></span><br><span class="line">        <span class="keyword">if</span> A[i] == <span class="number">1</span> <span class="keyword">and</span> A[i<span class="number">-1</span>] == <span class="number">9</span>:</span><br><span class="line">            period = i+<span class="number">1</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">            </span><br><span class="line">    t = to % period</span><br><span class="line">    f = (from_ - <span class="number">1</span>) % period</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> from_ == (<span class="number">0</span> <span class="keyword">or</span> <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">2</span>*A[t] + A[t<span class="number">-1</span>] - <span class="number">1</span>) % <span class="number">10</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (<span class="number">2</span>*(A[t]-A[f]) + A[t<span class="number">-1</span>] - A[f<span class="number">-1</span>]) % <span class="number">10</span></span><br><span class="line"></span><br><span class="line">print(fibonacci_partial_sum_fast(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">print(fibonacci_partial_sum_fast(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">print(fibonacci_partial_sum_fast(<span class="number">3</span>, <span class="number">7</span>))</span><br><span class="line">print(fibonacci_partial_sum_fast(<span class="number">5</span>, <span class="number">7</span>))</span><br><span class="line">print(fibonacci_partial_sum_fast(<span class="number">10</span>, <span class="number">10</span>))</span><br><span class="line">print(fibonacci_partial_sum_fast(<span class="number">10</span>, <span class="number">200</span>))</span><br></pre></td></tr></table></figure><pre><code>121652</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">A = [<span class="keyword">None</span>]* (<span class="number">100</span>)</span><br><span class="line">A[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">A[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, to<span class="number">-1</span>):</span><br><span class="line">    A[i] = (A[i<span class="number">-1</span>] + A[i<span class="number">-2</span>]) % <span class="number">10</span> </span><br><span class="line">    <span class="keyword">if</span> A[i] == <span class="number">1</span> <span class="keyword">and</span> A[i<span class="number">-1</span>] == <span class="number">9</span>:</span><br><span class="line">        period = i+<span class="number">1</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">t = (to<span class="number">-1</span>) % period</span><br><span class="line"><span class="keyword">return</span> (<span class="number">2</span>*(A[t]-A[] + A[t<span class="number">-1</span>] - <span class="number">1</span>) % <span class="number">10</span></span><br></pre></td></tr></table></figure><h1 id="last-digit-of-the-sum-of-squares-of-fibonacci-numbers">Last Digit of the Sum of Squares of Fibonacci Numbers</h1><h2 id="求斐波那契数平方之和的个位数">求斐波那契数平方之和的个位数</h2><p><strong>Task.</strong> Compute the last digit of <span class="math inline">\(F_0^2 + F_1^2 + · · · + F_n^2\)</span>.</p><p><strong>Input Format.</strong> Integer n.</p><p><strong>Constraints.</strong> <span class="math inline">\(0 ≤ n ≤ 10^{18}\)</span>.</p><p><strong>Output Format.</strong> The last digit of <span class="math inline">\(F_0^2 + F_1^2 + · · · + F_n^2\)</span>.</p><p><strong>Sample 1.</strong> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">7</span><br><span class="line">Output:</span><br><span class="line">3</span><br></pre></td></tr></table></figure></p><p><span class="math inline">\(F_0^2 + F_1^2 + · · · + F_7^2 = 0 + 1 + 1 + 4 + 9 + 25 + 64 + 169 = 273\)</span>.</p><h2 id="naive-algorithm-1">Naive Algorithm</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibonacci_sum_squares_naive</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line"></span><br><span class="line">    previous = <span class="number">0</span></span><br><span class="line">    current  = <span class="number">1</span></span><br><span class="line">    sum      = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(n - <span class="number">1</span>):</span><br><span class="line">        previous, current = current, previous + current</span><br><span class="line">        sum += current * current</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sum % <span class="number">10</span></span><br><span class="line">print(fibonacci_sum_squares_naive(<span class="number">7</span>))</span><br><span class="line">print(fibonacci_sum_squares_naive(<span class="number">73</span>))</span><br><span class="line">print(fibonacci_sum_squares_naive(<span class="number">211</span>))</span><br><span class="line">print(fibonacci_sum_squares_naive(<span class="number">239</span>))</span><br></pre></td></tr></table></figure><pre><code>3110</code></pre><h2 id="fast-algorithm-7">Fast Algorithm</h2><p>斐波那契数列各项相加的平方和为：</p><p><span class="math display">\[\sum_{n}a_n^2=a_1^2+a_2^2+\ldots + a_n^2=a_{n}a_{n+1}\]</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibonacci_sum_squares_fast</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    A = [<span class="keyword">None</span>]* (<span class="number">100</span>)</span><br><span class="line">    A[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">    A[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, <span class="number">100</span>):</span><br><span class="line">        A[i] = (A[i<span class="number">-1</span>] + A[i<span class="number">-2</span>])%<span class="number">10</span></span><br><span class="line">        <span class="keyword">if</span> A[i] == <span class="number">1</span> <span class="keyword">and</span> A[i<span class="number">-1</span>] == <span class="number">9</span>:</span><br><span class="line">            period = i+<span class="number">1</span></span><br><span class="line">            A[i+<span class="number">1</span>] = (A[i<span class="number">-1</span>] + A[i])%<span class="number">10</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">            </span><br><span class="line">    t = n % period</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (A[t] * A[t+<span class="number">1</span>]) % <span class="number">10</span></span><br><span class="line">print(fibonacci_sum_squares_fast(<span class="number">0</span>))</span><br><span class="line">print(fibonacci_sum_squares_fast(<span class="number">7</span>))</span><br><span class="line">print(fibonacci_sum_squares_fast(<span class="number">73</span>))</span><br><span class="line">print(fibonacci_sum_squares_fast(<span class="number">211</span>))</span><br><span class="line">print(fibonacci_sum_squares_fast(<span class="number">239</span>))</span><br><span class="line">print(fibonacci_sum_squares_fast(<span class="number">832564823476</span>))</span><br></pre></td></tr></table></figure><pre><code>031109</code></pre><p><code>break</code> 前面加了一行 <code>A[i+1] = (A[i-1] + A[i])%10</code> 的原因是，当余数为边界值period-1时，还要计算A[t+1]</p><p>参考： - <a href="https://www.coursera.org/learn/algorithmic-toolbox/home/week/2" target="_blank" rel="noopener">Coursera：algorithmic toolbox(week2)</a></p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> Algorithm - Fibonacci </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maximum Pairwise Product Problem</title>
      <link href="/2018/09/25/Maximum_Pairwise/"/>
      <url>/2018/09/25/Maximum_Pairwise/</url>
      
        <content type="html"><![CDATA[<h1 id="问题两数最大乘积">问题：两数最大乘积</h1><p>Find the maximum product of two distinct numbers in a sequence of non-negative integers.</p><p><strong>Input:</strong> A sequence of non-negative integers.</p><p><strong>Output:</strong> The maximum value that can be obtained by multiplying two different elements from the sequence.</p><p><strong>Constraints:</strong> $ 2 ≤ n ≤ 2 · 10^5; 0 ≤ a_1,...,a_n ≤ 2 · 10^5 $.</p><p>Sample: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">1 2 3</span><br><span class="line">Output:</span><br><span class="line">6</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>这个问题其实就是要找到列表中最大的两个数。</p><h1 id="naive-algorithm">Naive Algorithm</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">max_pairwise_productNaive</span><span class="params">(A)</span>:</span></span><br><span class="line">    n = len(A)</span><br><span class="line">    max_product = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> i != j:</span><br><span class="line">                <span class="keyword">if</span> max_product &lt; A[i] * A[j]:</span><br><span class="line">                    max_product = A[i] * A[j]</span><br><span class="line">    <span class="keyword">return</span> max_product</span><br><span class="line"></span><br><span class="line">max_pairwise_productNaive([<span class="number">9</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>])</span><br></pre></td></tr></table></figure><pre><code>63</code></pre><p>代码可以优化为如下形式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">max_pairwise_productNaive</span><span class="params">(A)</span>:</span></span><br><span class="line">    n = len(A)</span><br><span class="line">    max_product = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>, n):</span><br><span class="line">            max_product = max(max_product, A[i]*A[j])</span><br><span class="line">    <span class="keyword">return</span> max_product</span><br><span class="line"></span><br><span class="line">max_pairwise_productNaive([<span class="number">9</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>])</span><br></pre></td></tr></table></figure><pre><code>63</code></pre><p>这样的代码在数值很大时会超过运行时间限制。</p><h1 id="fast-algorithm">Fast Algorithm</h1><p>第一次循环找到最大值，第二次循环找到除此之外的最大值。经过 2n 次比较,运行时间 O(n)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">max_pairwise_productFast</span><span class="params">(A)</span>:</span></span><br><span class="line">    n = len(A)</span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">        <span class="keyword">if</span> A[i] &gt; A[j]:</span><br><span class="line">            j = i</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> j == <span class="number">0</span>:</span><br><span class="line">        h = <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        h = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">        <span class="keyword">if</span> i!=j <span class="keyword">and</span> A[i] &gt; A[h]:</span><br><span class="line">            h = i</span><br><span class="line">    <span class="keyword">return</span> A[j]*A[h]</span><br><span class="line"></span><br><span class="line">max_pairwise_productFast([<span class="number">9</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>])</span><br></pre></td></tr></table></figure><pre><code>63</code></pre><h2 id="压力测试">压力测试</h2><p>是一种test和debug的方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">StressTest</span><span class="params">(N, M)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        n = random.randint(<span class="number">2</span>, N)</span><br><span class="line">        A=[random.randint(<span class="number">0</span>,M) <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">        print(A)</span><br><span class="line">        result_1 = max_pairwise_productNaive(A)</span><br><span class="line">        result_2 = max_pairwise_productFast(A)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> result_1 == result_2:</span><br><span class="line">            print(<span class="string">"OK"</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">"Wrong answer:"</span>,result_1,result_2)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">StressTest(<span class="number">10</span>,<span class="number">100000</span>)</span><br></pre></td></tr></table></figure><h1 id="找出列表中最大的两个数">找出列表中最大的两个数</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">max_pairwise</span><span class="params">(A)</span>:</span></span><br><span class="line">    n = len(A)</span><br><span class="line">    </span><br><span class="line">    max1 = A[<span class="number">0</span>] </span><br><span class="line">    max2 = A[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">if</span> A[<span class="number">0</span>] &lt; A[<span class="number">1</span>]:</span><br><span class="line">        max1, max2 = max2, max1</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,n):</span><br><span class="line">        <span class="keyword">if</span> A[i] &gt;= max1:</span><br><span class="line">            max2 = max1</span><br><span class="line">            max1 = A[i]</span><br><span class="line">        <span class="keyword">elif</span>(A[i] &lt; max1 <span class="keyword">and</span> A[i] &gt; max2):</span><br><span class="line">            max2 = A[i]</span><br><span class="line">    <span class="keyword">return</span> max1, max2</span><br><span class="line"></span><br><span class="line">max_pairwise([<span class="number">20</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">11</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">10</span>])</span><br></pre></td></tr></table></figure><pre><code>(20, 11)</code></pre><h1 id="更简洁的写法">更简洁的写法</h1><p>但运行时间较长，为 O(nlogn)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">max_pairwise_productSort</span><span class="params">(A)</span>:</span></span><br><span class="line">    n = len(A)</span><br><span class="line">    A.sort()</span><br><span class="line">    <span class="keyword">return</span> A[n<span class="number">-1</span>] * A[n<span class="number">-2</span>]</span><br><span class="line"></span><br><span class="line">max_pairwise_productSort([<span class="number">9</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>])</span><br></pre></td></tr></table></figure><pre><code>63</code></pre><h1 id="参考">参考</h1><ul><li><a href="https://www.coursera.org/learn/algorithmic-toolbox/home/week/1" target="_blank" rel="noopener">Coursera_algorithmic-toolbox_week1</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python -   Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>贝尔曼方程(The Bellman Equation)</title>
      <link href="/2018/09/10/The%20Bellman%20Equation/"/>
      <url>/2018/09/10/The%20Bellman%20Equation/</url>
      
        <content type="html"><![CDATA[<h1 id="基本原理">基本原理</h1><p>Logistic回归是统计学习中的经典分类方法。其实仅在线性回归的基础上，套用了一个逻辑函数。本文主要详述逻辑回归模型的基础。</p><h1 id="马尔可夫决策过程-markov-decision-processes-mdps">马尔可夫决策过程 Markov Decision Processes (MDPs)</h1><h1 id="参考">参考</h1><ul><li><a href="http://incompleteideas.net/book/the-book-2nd.html" target="_blank" rel="noopener">Reinforcement Learning: an introduction” by Sutton and Barto (freely downloadable)</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 强化学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 强化学习 </tag>
            
            <tag> 原理 </tag>
            
            <tag> Reinforcement Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LogisticRegression的sklearn参数说明</title>
      <link href="/2018/08/24/LogisticRegression%E7%9A%84sklearn%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E/"/>
      <url>/2018/08/24/LogisticRegression%E7%9A%84sklearn%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<blockquote><p><em>class</em> sklearn.linear_model.<strong>LogisticRegression</strong>(penalty=’l2’, dual=False, tol=0.0001, C=1.0, fit_intercept=True, intercept_scaling=1, class_weight=None, random_state=None, solver=’liblinear’, max_iter=100, multi_class=’ovr’, verbose=0, warm_start=False, n_jobs=1)</p></blockquote><p>在scikit-learn中，主要是基于LogisticRegression模型来解决Logistic回归算法，其中，有两种不同的代价函数(cost function)：<br>L1:</p><p><span class="math display">\[ \min _ { w,c }\|w\| _ 1+C\sum _ { i=1 }^n log ( exp ( -y_ i(X _ { i }^ \mathrm { T }w+c))+1)\]</span></p><p>L2：</p><p><span class="math display">\[ \min _{ w, c } \frac { 1 }{ 2 }w^ \mathrm { T }w +C \sum _{ i=1 }^nlog(exp(-y _i (X _{i}^ \mathrm { T }w+c))+1)\]</span></p><p>每个式子中前一项是<strong>正则化项（Regularizer）</strong>（包含w的范数），后一项是<strong>损失函数（loss function）</strong>，参数 <strong>C</strong> 控制了两者在最终的损失函数中所占的比重。<br>求解w参数的方法根据L1/L2代价函数的不同，也存在不同的求解拟合参数的方法：</p><a id="more"></a><table><thead><tr class="header"><th>Case</th><th>Solver</th></tr></thead><tbody><tr class="odd"><td>L2 penalty</td><td>“saga”, “liblinear” , “lbfgs”, “sag”, “newton-cg”</td></tr><tr class="even"><td>L1 penalty</td><td>“saga”, “liblinear”</td></tr><tr class="odd"><td>Multinomial loss</td><td>“saga”, “lbfgs”, “sag”, “newton-cg”</td></tr><tr class="even"><td>Very Large dataset (n_samples)</td><td>“saga”, “sag”</td></tr></tbody></table><ul><li><strong>penalty：</strong>惩罚项，str类型，可选参数为l1和l2，默认为l2。<ul><li>用于指定惩罚项中使用的规范。加上约束，使得模型更不会过拟合(overfit)，可以获得泛化能力更强的结果</li><li>newton-cg、sag和lbfgs求解算法只支持L2规范。</li><li>L1规范假设的是模型的参数满足拉普拉斯分布，L2假设的模型参数满足高斯分布，</li></ul></li><li><strong>dual：</strong>对偶或原始方法，bool类型，默认为False。<ul><li>对偶方法只用在求解线性多核(liblinear)的<strong>L2惩罚项</strong>上。</li><li>当样本数量&gt;样本特征的时候，dual通常设置为False。</li></ul></li><li><strong>tol：</strong>停止求解的标准，float类型，默认为1e-4。<ul><li>就是求解到多少的时候，停止，认为已经求出最优解。</li></ul></li><li><strong>c：</strong>正则化系数λ的倒数，float类型，默认为1.0。必须是正浮点型数。<ul><li>像SVM一样，越小的数值表示越强的正则化。</li></ul></li><li><strong>fit_intercept：</strong>是否存在截距或偏差，bool类型，默认为True。</li><li><strong>intercept_scaling：</strong> float类型，默认为1。<ul><li>仅在正则化项为&quot;liblinear&quot;，且fit_intercept设置为True时有用。</li></ul></li><li><strong>class_weight：</strong>用于标示分类模型中各种类型的权重.<ul><li>默认为None，也就是不考虑权重。可以输入一个字典或者'balanced'字符串。</li><li>可以<code>{class_label:weight}</code>形式自己输入各个类型的权重。举个例子，比如对于0,1的二元模型，我们可以定义class_weight={0:0.9,1:0.1}，这样类型0的权重为90%，而类型1的权重为10%。</li><li>也可以选择<strong>balanced</strong>，那么类库会根据训练样本量来计算权重。某种类型样本量越多，则权重越低，样本量越少，则权重越高。类权重计算方法如下：<code>n_samples/(n_classes *np.bincount(y))</code>。</li><li><code>n_samples</code>为样本数，<code>n_classes</code>为类别数量，<code>np.bincount(y)</code>会输出每个类的样本数，例如 y=[1,0,0,1,1], 则 np.bincount(y)=[2,3]。 那么class_weight有什么作用呢？ 在分类模型中，我们经常会遇到两类问题： <strong>第一种是误分类的代价很高。</strong>比如对合法用户和非法用户进行分类，将非法用户分类为合法用户的代价很高，我们宁愿将合法用户分类为非法用户，这时可以人工再甄别，但是却不愿将非法用户分类为合法用户。这时，我们可以适当提高非法用户的权重。 <strong>第二种是样本是高度失衡的</strong>。比如我们有合法用户和非法用户的二元样本数据10000条，里面合法用户有9995条，非法用户只有5条，如果我们不考虑权重，则我们可以将所有的测试集都预测为合法用户，这样预测准确率理论上有99.95%，但是却没有任何意义。这时，我们可以选择balanced，让类库自动提高非法用户样本的权重。提高了某种分类的权重，相比不考虑权重，会有更多的样本分类划分到高权重的类别，从而可以解决上面两类问题。</li></ul></li><li><strong>random_state：</strong>随机数种子，int类型，可选参数，默认为None。<ul><li>仅在正则化优化算法为 sag, liblinear 时有用。</li></ul></li><li><strong>solver：</strong>优化方法选择。默认为liblinear。<ul><li>有五个可选参数，即newton-cg, lbfgs, liblinear, sag, saga。</li><li><strong>liblinear：</strong>使用了开源的liblinear库实现，内部使用了坐标轴下降法来迭代优化损失函数。</li><li><strong>lbfgs：</strong>L-BFGS算法，拟牛顿法的一种，利用损失函数二阶导数矩阵即海森矩阵来迭代优化损失函数。</li><li><strong>newton-cg：</strong>也是牛顿法家族的一种，利用损失函数二阶导数矩阵即海森矩阵来迭代优化损失函数。</li><li><strong>sag：</strong>即随机平均梯度下降(Stochastic Average Gradient descent)，是梯度下降法的变种，和普通梯度下降法的区别是每次迭代仅仅用一部分的样本来计算梯度，适合于样本数据多的时候。</li><li><strong>saga：</strong>线性收敛的随机优化算法的的变重。</li><li><strong>总结：</strong><ul><li><strong>liblinear适用于小数据集</strong>，而sag和saga适用于大数据集因为速度更快。</li><li>对于多分类问题，<strong>只有newton-cg,sag,saga和lbfgs能够处理多项损失</strong>，而<strong>liblinear受限于一对剩余(OvR)</strong>。意思就是用liblinear的时候，如果是多分类问题，得先把一种类别作为一个类别，剩余的所有类别作为另外一个类别。一次类推，遍历所有类别，进行分类。</li><li><strong>newton-cg, sag 和 lbfgs</strong> 这三种优化算法时都需要损失函数的一阶或者二阶连续导数，因此不能用于没有连续导数的L1正则化，<strong>只能用于L2正则化</strong>。而 <strong>liblinear 和 saga</strong> <strong>通吃L1正则化和L2正则化</strong>。</li><li>同时，sag每次仅仅使用了部分样本进行梯度迭代，所以当样本量少的时候不要选择它，而<strong>如果样本量非常大，比如大于10万，sag是第一选择</strong>。但是<strong>sag不能用于L1正则化</strong>，所以当你有大量的样本，又需要L1正则化的话就要自己做取舍了。要么通过对样本采样来降低样本量，要么回到L2正则化。</li><li>逻辑回归有二元逻辑回归和多元逻辑回归。对于多元逻辑回归常见的有one-vs-rest(OvR)和many-vs-many(MvM)两种。而MvM一般比OvR分类相对准确一些。而liblinear只支持OvR，不支持MvM，这样<strong>如果我们需要相对精确的多元逻辑回归时，就不能选择liblinear了</strong>。也意味着如果我们需要相对精确的多元逻辑回归<strong>不能使用L1正则化了</strong>。</li></ul></li></ul></li><li><strong>max_iter：</strong>算法收敛最大迭代次数，int类型，默认为10。<ul><li>仅在正则化优化算法为newton-cg, sag 和lbfgs才有用。</li></ul></li><li><strong>multi_class：</strong>分类方式选择参数，str类型，可选参数为ovr和multinomial，<strong>默认为ovr</strong>。<ul><li>如果是二元逻辑回归，ovr和multinomial并没有任何区别，区别主要在多元逻辑回归上。</li><li><strong>ovr</strong>即前面提到的one-vs-rest(OvR)。OvR的思想是无论你是多少元逻辑回归，我们都可以看做二元逻辑回归。具体做法是，对于第K类的分类决策，我们把所有第K类的样本作为正例，除了第K类样本以外的所有样本都作为负例，然后在上面做二元逻辑回归，得到第K类的分类模型。其他类的分类模型获得以此类推。</li><li>而<strong>multinomial</strong>即前面提到的many-vs-many(MvM)。MvM相对复杂，这里举MvM的特例one-vs-one(OvO)作讲解。如果模型有T类，我们每次在所有的T类样本里面选择两类样本出来，不妨记为T1类和T2类，把所有的输出为T1和T2的样本放在一起，把T1作为正例，T2作为负例，进行二元逻辑回归，得到模型参数。我们一共需要T(T-1)/2次分类。</li><li>可以看出OvR相对简单，但分类效果相对略差（这里指大多数样本分布情况，某些样本分布下OvR可能更好）。而MvM分类相对精确，但是分类速度没有OvR快。</li><li>如果选择了ovr，则4种损失函数的优化方法liblinear，newton-cg,lbfgs和sag都可以选择。<strong>但是如果选择了multinomial,则只能选择 newton-cg, lbfgs 和 sag 了</strong>。</li></ul></li><li><strong>verbose:</strong>日志冗长度，int类型。默认为0。就是不输出训练过程。<ul><li>1的时候偶尔输出结果，大于1，对于每个子模型都输出。</li></ul></li><li><strong>warm_start：</strong>热启动参数，bool类型。默认为False。<ul><li>如果为True，则下一次训练是以追加树的形式进行（重新使用上一次的调用作为初始化）。</li></ul></li><li><strong>n_jobs：</strong>并行数。int类型，默认为1。<ul><li>1的时候，用CPU的一个内核运行程序，</li><li>2的时候，用CPU的2个内核运行程序。</li><li>为-1的时候，用所有CPU的内核运行程序。</li></ul></li></ul><h1 id="参考">参考</h1><ul><li><a href="http://scikit-learn.org/stable/modules/generated/sklearn.linear_model.LogisticRegression.html#sklearn.linear_model.LogisticRegression.decision_function%20%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92" target="_blank" rel="noopener">sklearn.linear_model.LogisticRegression-scikit-learn 0.19.2 documentation</a></li><li><a href="https://www.jianshu.com/p/bbdeb356057e" target="_blank" rel="noopener">Logistic回归(Logistic Regression)算法笔记(二)-scikit learn</a></li><li><a href="https://blog.csdn.net/jark_/article/details/78342644" target="_blank" rel="noopener">LogisticRegression - 参数说明</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 逻辑回归 </tag>
            
            <tag> sklearn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python3 zip(), lambda, map()</title>
      <link href="/2018/08/19/python3%20zip(),%20lambda,%20map()/"/>
      <url>/2018/08/19/python3%20zip(),%20lambda,%20map()/</url>
      
        <content type="html"><![CDATA[<h1 id="zip-函数">zip() 函数</h1><p>函数用于将<em>可迭代的对象</em>作为参数，将对象中对应的元素打包成一个个<em>元组</em>，然后返回由这些元组组成的对象，这样做的好处是节约了不少的内存。简单来说，就是<strong>将序列合并打包</strong>。</p><p>我们可以使用<code>list()</code>转换来输出列表。</p><p>如果各个迭代器的元素个数不一致，则返回列表长度与最短的对象相同，利用 * 号操作符，可以将元组解压为列表。</p><a id="more"></a><p><strong>语法 :</strong></p><pre><code>zip(*iterables)</code></pre><p><strong>参数说明：</strong></p><p>iterables -- 一个或多个迭代器,可以内置的迭代器（比如<code>list</code>, <code>string</code>, <code>dict</code>）也可以是用户自定义的迭代器(有<code>__iter__</code>方法的对象).</p><h2 id="例1-基本用法">例1 基本用法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">numberList = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">strList = [<span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'three'</span>]</span><br><span class="line"></span><br><span class="line">result = zip() <span class="comment"># 没有传入可迭代量</span></span><br><span class="line"></span><br><span class="line">resultList = list(result) <span class="comment"># 转为列表</span></span><br><span class="line">print(resultList)</span><br><span class="line"></span><br><span class="line">result = zip(numberList, strList) <span class="comment"># 传入两个可迭代量</span></span><br><span class="line"></span><br><span class="line">resultSet = set(result) <span class="comment"># 转为集合</span></span><br><span class="line">print(resultSet)</span><br></pre></td></tr></table></figure><pre><code>[]{(1, &#39;one&#39;), (3, &#39;three&#39;), (2, &#39;two&#39;)}</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a1, a2 = zip(*zip(a,b))          <span class="comment"># 与 zip 相反，*zip 可理解为解压，返回二维矩阵式</span></span><br><span class="line">list(a1),list(a2)</span><br></pre></td></tr></table></figure><pre><code>([1, 2, 3], [4, 5, 6])</code></pre><h2 id="例2-传入个数不同的可迭代量">例2 传入个数不同的可迭代量</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">numbersList = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">strList = [<span class="string">'one'</span>, <span class="string">'two'</span>]</span><br><span class="line">numbersTuple = (<span class="string">'ONE'</span>, <span class="string">'TWO'</span>, <span class="string">'THREE'</span>, <span class="string">'FOUR'</span>)</span><br><span class="line"></span><br><span class="line">result = zip(numbersList, numbersTuple) <span class="comment"># 元素个数与最短的列表一致，3个</span></span><br><span class="line">resultSet = set(result)</span><br><span class="line">print(resultSet)</span><br><span class="line"></span><br><span class="line">result = zip(numbersList, strList, numbersTuple)<span class="comment"># 2个元素</span></span><br><span class="line">resultSet = set(result)</span><br><span class="line">print(resultSet)</span><br></pre></td></tr></table></figure><pre><code>{(2, &#39;TWO&#39;), (1, &#39;ONE&#39;), (3, &#39;THREE&#39;)}{(2, &#39;two&#39;, &#39;TWO&#39;), (1, &#39;one&#39;, &#39;ONE&#39;)}</code></pre><h2 id="例3-用和zip来解压列表">例3 用*和zip()来解压列表</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">y = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">unzipped_x, unzipped_y = zip(*zip(x,y))</span><br><span class="line">print(unzipped_x, unzipped_y)</span><br></pre></td></tr></table></figure><pre><code>(1, 2, 3) (4, 5, 6)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">zipper_list = [(<span class="number">1</span>, <span class="string">'a'</span>), (<span class="number">2</span>, <span class="string">'b'</span>), (<span class="number">3</span>, <span class="string">'c'</span>)]</span><br><span class="line"> </span><br><span class="line">l_a, l_b = zip(*zipper_list)</span><br><span class="line">print(l_a, l_b)</span><br><span class="line">print(list(l_a), list(l_b))</span><br></pre></td></tr></table></figure><pre><code>(1, 2, 3) (&#39;a&#39;, &#39;b&#39;, &#39;c&#39;)[1, 2, 3] [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</code></pre><h1 id="lambda匿名函数">lambda匿名函数</h1><p>lambda表达式是一行函数。 它们在其他语言中也被称为<strong>匿名函数</strong>。如果你不想在程序中对一个函数使用两次，你也许会想用lambda表达式，它们和普通的函数完全一样。</p><p><strong>语法</strong></p><pre><code>lambda 参数:操作(参数)</code></pre><h2 id="例1-基本用法-1">例1 基本用法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">add = <span class="keyword">lambda</span> x, y: x + y</span><br><span class="line">print(add(<span class="number">3</span>, <span class="number">5</span>))</span><br></pre></td></tr></table></figure><pre><code>8</code></pre><h2 id="例2-列表排序">例2 列表排序</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = [(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">4</span>, <span class="number">1</span>), (<span class="number">9</span>, <span class="number">10</span>), (<span class="number">13</span>, <span class="number">-3</span>)]</span><br><span class="line">a.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">print(a)</span><br><span class="line">    <span class="comment"># Output: [(13, -3), (4, 1), (1, 2), (9, 10)]</span></span><br></pre></td></tr></table></figure><pre><code>[(13, -3), (4, 1), (1, 2), (9, 10)]</code></pre><h2 id="例3-在lambda中嵌套逻辑">例3 在lambda中嵌套逻辑</h2><p>可以使用if/else三元表达式，或者对等的但需要些技巧的and/or组合。正如我们前面所了解到的，如下语句： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if a:</span><br><span class="line">    b</span><br><span class="line">else:</span><br><span class="line">    c</span><br></pre></td></tr></table></figure></p><p>能够由以下的概括等效的表达式来模拟：</p><pre><code>b if a else c((a and b) or c)</code></pre><p>因为这样类似的表达式能够放在lambda中，所以它们能够在lambda函数中来实现选择逻辑。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lower = (<span class="keyword">lambda</span> x, y: x <span class="keyword">if</span> x &lt; y <span class="keyword">else</span> y)</span><br><span class="line">lower(<span class="string">'bb'</span>, <span class="string">'aa'</span>)</span><br></pre></td></tr></table></figure><pre><code>&#39;aa&#39;</code></pre><h2 id="例4-在lambda中执行循环">例4 在lambda中执行循环</h2><p>嵌入map调用或列表解析表达式这样的工具来实现。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">showall = <span class="keyword">lambda</span> x: list(map(sys.stdout.write, x))  <span class="comment"># map</span></span><br><span class="line">showall([<span class="string">'spam\n'</span>, <span class="string">'toast\n'</span>, <span class="string">'eggs\n'</span>])</span><br><span class="line"></span><br><span class="line">showall = <span class="keyword">lambda</span> x: [sys.stdout.write(line) <span class="keyword">for</span> line <span class="keyword">in</span> x]  <span class="comment"># 列表解析</span></span><br><span class="line">showall([<span class="string">'music '</span>, <span class="string">'song '</span>, <span class="string">'sing'</span>])</span><br></pre></td></tr></table></figure><pre><code>spamtoasteggsmusic song sing[None, None, None]</code></pre><h1 id="map函数">map()函数</h1><p><strong>map()</strong> 将一个序列中的每一个迭代元素应用于给定函数， 并返回一个包含所有函数调用结果的一个列表.</p><p><strong>语法 :</strong></p><pre><code>map(fun, iter)</code></pre><p><strong>参数 :</strong></p><p><code>fun</code> : 给定函数; <code>iter</code> : 可迭代序列(list, tuple 等等) 。</p><h2 id="例1-基本用法-2">例1 基本用法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addition</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> n + n</span><br><span class="line"></span><br><span class="line">numbers = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">result = map(addition, numbers)</span><br><span class="line">print(list(result))</span><br></pre></td></tr></table></figure><pre><code>[2, 4, 6, 8]</code></pre><h2 id="例2-在map中使用lambda函数">例2 在map()中使用lambda函数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">numbers = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">result = list(map(<span class="keyword">lambda</span> x: x + x, numbers))</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure><pre><code>[2, 4, 6, 8]</code></pre><h2 id="例3-传入多个迭代序列">例3 传入多个迭代序列</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">numbers1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">numbers2 = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"> </span><br><span class="line">result = list(map(<span class="keyword">lambda</span> x, y: x + y, numbers1, numbers2))</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure><pre><code>[5, 7, 9]</code></pre><h2 id="例4-列表中每个字符串分别序列化">例4 列表中每个字符串分别序列化</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">l = [<span class="string">'sat'</span>, <span class="string">'bat'</span>, <span class="string">'cat'</span>, <span class="string">'mat'</span>]</span><br><span class="line"></span><br><span class="line">test = list(map(list, l))</span><br><span class="line">print(test)</span><br></pre></td></tr></table></figure><pre><code>[[&#39;s&#39;, &#39;a&#39;, &#39;t&#39;], [&#39;b&#39;, &#39;a&#39;, &#39;t&#39;], [&#39;c&#39;, &#39;a&#39;, &#39;t&#39;], [&#39;m&#39;, &#39;a&#39;, &#39;t&#39;]]</code></pre><h1 id="参考">参考</h1><ul><li><a href="https://www.programiz.com/python-programming/methods/built-in/zip" target="_blank" rel="noopener">Python zip() - programiz</a></li><li><a href="http://www.runoob.com/python3/python3-func-zip.html" target="_blank" rel="noopener">Python3 zip() 函数 | 菜鸟教程</a></li><li><a href="https://eastlakeside.gitbooks.io/interpy-zh/content/Lambdas/" target="_blank" rel="noopener">lambda表达式 - python进阶</a></li><li><a href="http://blog.51cto.com/professor/1745109" target="_blank" rel="noopener">Python3之lambda匿名函数详解-Professor哥-51CTO博客</a></li><li><a href="https://www.geeksforgeeks.org/python-map-function/" target="_blank" rel="noopener">Python map() function - GeeksforGeeks</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 基础学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo常用命令</title>
      <link href="/2018/06/21/hexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2018/06/21/hexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<div align="life"><iframe frameborder="no" marginwidth="0" marginheight="0" width="400" height="140" src="https://music.163.com/outchain/player?type=2&amp;id=34341360&amp;auto=0&amp;height=66"></iframe></div><p><code>hexo init &lt;folder&gt;</code> 创建并初始化一个站点文件夹 <code>hexo new 'article title'</code> 新增一篇文章</p><p><code>hexo clean</code> 用于主题切换等涉及到站点整体布局效果改变时清除hexo原有缓存</p><h1 id="文章编辑完后">文章编辑完后</h1><ul><li>开启本地服务器，测试静态页面的效果： <code>hexo server</code> 或 <code>hexo s</code></li><li>为文章自动生成静态页面的文件：<code>hexo generate</code> 或 <code>hexo g</code></li><li>将本地页面部署到GitHub Pages上：<code>hexo deploy</code> 或 <code>hexo d</code></li><li>(合并替换前两项)生成静态页面的文件并直接部署：<code>hexo generate -d</code> 或<code>hexo deploy -g</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动词て形</title>
      <link href="/2018/06/20/%E5%8A%A8%E8%AF%8D%E3%81%A6%E5%BD%A2/"/>
      <url>/2018/06/20/%E5%8A%A8%E8%AF%8D%E3%81%A6%E5%BD%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="一类动词">一类动词</h1><table><thead><tr class="header"><th align="center">词尾</th><th align="center">替换</th><th align="center">基本形</th><th align="center">て形</th></tr></thead><tbody><tr class="odd"><td align="center">(あうお段)+る</td><td align="center"><strong>って</strong></td><td align="center">売る (うる)</td><td align="center">うって</td></tr><tr class="even"><td align="center">う</td><td align="center">って</td><td align="center">買う (かう)</td><td align="center">かって</td></tr><tr class="odd"><td align="center">つ</td><td align="center">って</td><td align="center">待つ (まつ)</td><td align="center">まって</td></tr><tr class="even"><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr class="odd"><td align="center">く</td><td align="center"><strong>いて</strong></td><td align="center">書く (かく)</td><td align="center">かいて</td></tr><tr class="even"><td align="center">ぐ</td><td align="center"><strong>いで</strong></td><td align="center">急ぐ (いそぐ)</td><td align="center">いそいで</td></tr><tr class="odd"><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr class="even"><td align="center">む</td><td align="center"><strong>んで</strong></td><td align="center">読む (よむ)</td><td align="center">よんで</td></tr><tr class="odd"><td align="center">ぶ</td><td align="center">んで</td><td align="center">飛ぶ (とぶ)</td><td align="center">とんで</td></tr><tr class="even"><td align="center">ぬ</td><td align="center">んで</td><td align="center">死ぬ (しぬ)</td><td align="center">しんで</td></tr><tr class="odd"><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr class="even"><td align="center">す</td><td align="center"><strong>して</strong></td><td align="center">話す (はなす)</td><td align="center">はなして</td></tr></tbody></table><p>只有“行(い)く”是例外，て形为“行(い)って”。</p><h1 id="二类动词">二类动词</h1><table><thead><tr class="header"><th>词尾</th><th align="center">替换</th><th align="center">基本形</th><th align="center">て形</th></tr></thead><tbody><tr class="odd"><td>(いえ段)+る</td><td align="center">て</td><td align="center">見る (みる)</td><td align="center">みて</td></tr></tbody></table><h1 id="三类动词">三类动词</h1><table><thead><tr class="header"><th>词尾</th><th align="center">替换</th><th align="center">基本形</th><th align="center">て形</th></tr></thead><tbody><tr class="odd"><td>する</td><td align="center">して</td><td align="center">する</td><td align="center">して</td></tr><tr class="even"><td>くる</td><td align="center">きて</td><td align="center">来る (くる)</td><td align="center">きて</td></tr></tbody></table><h1 id="用法">用法</h1><h2 id="请求对方做某事">1. 请求对方做某事</h2><p><strong>动词て形 + ください</strong> - 黒板（こくばん）を　見て　ください。 <code>请看黑板。</code> - 早（はや）く　来て　ください。 <code>请快点儿来。</code> - ちょっと　待って　ください。 <code>请等一下。</code></p>]]></content>
      
      
      <categories>
          
          <category> 日语学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动词 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模型选择</title>
      <link href="/2018/04/16/%E6%A8%A1%E5%9E%8B%E9%80%89%E6%8B%A9/"/>
      <url>/2018/04/16/%E6%A8%A1%E5%9E%8B%E9%80%89%E6%8B%A9/</url>
      
        <content type="html"><![CDATA[<h1 id="评估回归模型">评估回归模型</h1><p>这里将都使用波士顿房价的数据集，用10折交叉验证来分离数据，通过均方误差来评估模型性能。 在scikit-learn中用cross_val_score()函数来测试模型，选用负均方误差（neg_mean_squared_error）作为score，得分是负数，这里的neg_mean_squared_error是一种奖励函数，优化的目标是使其最大化。 ## 线性算法 ### 线性回归 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> KFold</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> cross_val_score</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LinearRegression</span><br><span class="line"><span class="comment">#导入数据</span></span><br><span class="line">data = pd.read_csv(<span class="string">'housing.csv'</span>)</span><br><span class="line"><span class="comment">#划分数据</span></span><br><span class="line">X = data.values[:,<span class="number">0</span>:<span class="number">13</span>]</span><br><span class="line">Y = data.values[:,<span class="number">13</span>]</span><br><span class="line"></span><br><span class="line">seed = <span class="number">7</span></span><br><span class="line">kfold = KFold(n_splits=<span class="number">10</span>, random_state = seed)</span><br><span class="line">model = LinearRegression()</span><br><span class="line">scoring = <span class="string">'neg_mean_squared_error'</span></span><br><span class="line">result = cross_val_score(model, X, Y, cv=kfold, scoring=scoring)</span><br><span class="line">print(<span class="string">'Linear Regression: %.3f'</span> %result.mean())</span><br></pre></td></tr></table></figure></p><p>执行结果如下： <a id="more"></a> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Linear Regression: -34.705</span><br></pre></td></tr></table></figure></p><h3 id="岭回归ridge-regression">岭回归(Ridge Regression)</h3><p>岭回归是加入L2正则的最小二乘，Sklearn库提供了函数Ridge(alpha)，alpha是超参数，是正则化项的系数，用来弱化变量参数共线性，限制变量权重（参数）过大，alpha越大，越不容易过拟合。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> KFold</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> cross_val_score</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> Ridge</span><br><span class="line"><span class="comment">#导入数据</span></span><br><span class="line">data = pd.read_csv(<span class="string">'housing.csv'</span>)</span><br><span class="line"><span class="comment">#划分数据</span></span><br><span class="line">X = data.values[:,<span class="number">0</span>:<span class="number">13</span>]</span><br><span class="line">Y = data.values[:,<span class="number">13</span>]</span><br><span class="line"></span><br><span class="line">seed = <span class="number">7</span></span><br><span class="line">kfold = KFold(n_splits=<span class="number">10</span>, random_state = seed)</span><br><span class="line">model = Ridge()</span><br><span class="line">scoring = <span class="string">'neg_mean_squared_error'</span></span><br><span class="line">result = cross_val_score(model, X, Y, cv=kfold, scoring=scoring)</span><br><span class="line">print(<span class="string">'Ridge Regression: %.3f'</span> %result.mean())</span><br></pre></td></tr></table></figure></p><p>执行结果如下： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ridge Regression: -34.078</span><br></pre></td></tr></table></figure></p><h3 id="lasso回归">LASSO回归</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> KFold</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> cross_val_score</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> Lasso</span><br><span class="line"><span class="comment">#导入数据</span></span><br><span class="line">data = pd.read_csv(<span class="string">'housing.csv'</span>)</span><br><span class="line"><span class="comment">#划分数据</span></span><br><span class="line">X = data.values[:,<span class="number">0</span>:<span class="number">13</span>]</span><br><span class="line">Y = data.values[:,<span class="number">13</span>]</span><br><span class="line"></span><br><span class="line">seed = <span class="number">7</span></span><br><span class="line">kfold = KFold(n_splits=<span class="number">10</span>, random_state = seed)</span><br><span class="line">model = Lasso()</span><br><span class="line">scoring = <span class="string">'neg_mean_squared_error'</span></span><br><span class="line">result = cross_val_score(model, X, Y, cv=kfold, scoring=scoring)</span><br><span class="line">print(<span class="string">'Lasso Regression: %.3f'</span> %result.mean())</span><br></pre></td></tr></table></figure><p>执行结果如下： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Lasso Regression: -34.464</span><br></pre></td></tr></table></figure></p><h3 id="弹性网络elastic-net回归">弹性网络(Elastic Net)回归</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> KFold</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> cross_val_score</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> ElasticNet</span><br><span class="line"><span class="comment">#导入数据</span></span><br><span class="line">data = pd.read_csv(<span class="string">'housing.csv'</span>)</span><br><span class="line"><span class="comment">#划分数据</span></span><br><span class="line">X = data.values[:,<span class="number">0</span>:<span class="number">13</span>]</span><br><span class="line">Y = data.values[:,<span class="number">13</span>]</span><br><span class="line"></span><br><span class="line">seed = <span class="number">7</span></span><br><span class="line">kfold = KFold(n_splits=<span class="number">10</span>, random_state = seed)</span><br><span class="line">scoring = <span class="string">'neg_mean_squared_error'</span></span><br><span class="line"></span><br><span class="line">model = ElasticNet()</span><br><span class="line">result = cross_val_score(model, X, Y, cv=kfold, scoring=scoring)</span><br><span class="line">print(<span class="string">'ElasticNet Regression: %.3f'</span> % result.mean())</span><br></pre></td></tr></table></figure><p>执行结果如下： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ElasticNet Regression: -31.165</span><br></pre></td></tr></table></figure></p><h2 id="非线性算法">非线性算法</h2><p>这里介绍在scikit-learn中的三种非线性的机器学习的回归算法。 - K近邻（KNN） - 决策树（CART） - 支持向量机（SVM） 这三个算法在分类算法中同样存在，代码类似于上面的算法，这里就写在一起。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> KFold</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> cross_val_score</span><br><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsRegressor</span><br><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeRegressor</span><br><span class="line"><span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> SVR</span><br><span class="line"><span class="comment">#导入数据</span></span><br><span class="line">data = pd.read_csv(<span class="string">'housing.csv'</span>)</span><br><span class="line"><span class="comment">#划分数据</span></span><br><span class="line">X = data.values[:,<span class="number">0</span>:<span class="number">13</span>]</span><br><span class="line">Y = data.values[:,<span class="number">13</span>]</span><br><span class="line"></span><br><span class="line">seed = <span class="number">7</span></span><br><span class="line">kfold = KFold(n_splits=<span class="number">10</span>, random_state = seed)</span><br><span class="line">scoring = <span class="string">'neg_mean_squared_error'</span></span><br><span class="line"></span><br><span class="line">models = &#123;&#125;</span><br><span class="line">models[<span class="string">'KNN'</span>] = KNeighborsRegressor()</span><br><span class="line">models[<span class="string">'DecisionTree'</span>] = DecisionTreeRegressor()</span><br><span class="line">models[<span class="string">'SVM'</span>] = SVR()</span><br><span class="line"></span><br><span class="line">results = []</span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> models:</span><br><span class="line">    result = cross_val_score(models[name], X, Y, cv=kfold, scoring=scoring)</span><br><span class="line">    results.append(result)</span><br><span class="line">    print(<span class="string">'%s: %.3f'</span> % (name, result.mean()))</span><br></pre></td></tr></table></figure></p><p>执行结果如下： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">KNN: -107.287</span><br><span class="line">DecisionTree: -44.421</span><br><span class="line">SVM: -91.048</span><br></pre></td></tr></table></figure></p><h1 id="评估分类模型">评估分类模型</h1><p>这里会介绍6种分类算法： 线性算法： - 逻辑回归 - 线性判别（LDA） 非线性算法： - K近邻（KNN） - 贝叶斯分类器 - 决策树 - 支持向量机（SVM） <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> KFold</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> cross_val_score</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LogisticRegression</span><br><span class="line"><span class="keyword">from</span> sklearn.discriminant_analysis <span class="keyword">import</span> LinearDiscriminantAnalysis</span><br><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> SVC</span><br><span class="line"><span class="keyword">from</span> sklearn.naive_bayes <span class="keyword">import</span> GaussianNB</span><br><span class="line"></span><br><span class="line"><span class="comment">#导入数据</span></span><br><span class="line">data = pd.read_csv(<span class="string">'pima_data.csv'</span>)</span><br><span class="line"><span class="comment">#划分数据</span></span><br><span class="line">X = data.values[:,<span class="number">0</span>:<span class="number">8</span>]</span><br><span class="line">Y = data.values[:,<span class="number">8</span>]</span><br><span class="line"></span><br><span class="line">seed = <span class="number">7</span></span><br><span class="line">kfold = KFold(n_splits=<span class="number">10</span>, random_state = seed)</span><br><span class="line"></span><br><span class="line">models = &#123;&#125;</span><br><span class="line">models[<span class="string">'LR'</span>] = LogisticRegression()</span><br><span class="line">models[<span class="string">'LDA'</span>] = LinearDiscriminantAnalysis()</span><br><span class="line">models[<span class="string">'KNN'</span>] = KNeighborsClassifier()</span><br><span class="line">models[<span class="string">'CART'</span>] = DecisionTreeClassifier()</span><br><span class="line">models[<span class="string">'SVM'</span>] = SVC()</span><br><span class="line">models[<span class="string">'NB'</span>] = GaussianNB()</span><br><span class="line"></span><br><span class="line">results = []</span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> models:</span><br><span class="line">    result = cross_val_score(models[name], X, Y, cv=kfold)</span><br><span class="line">    results.append(result)</span><br><span class="line">    print(<span class="string">'%s: %.3f(%.3f)'</span> % (name, result.mean(), result.std()))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 图表显示</span></span><br><span class="line">fig = pyplot.figure()</span><br><span class="line">fig.suptitle(<span class="string">'Algorithm Comparison'</span>)</span><br><span class="line">ax = fig.add_subplot(<span class="number">111</span>)</span><br><span class="line">pyplot.boxplot(results)</span><br><span class="line">ax.set_xticklabels(models.keys())</span><br><span class="line">pyplot.show()</span><br></pre></td></tr></table></figure></p><p>执行结果如下： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LR: 0.770(0.048)</span><br><span class="line">LDA: 0.773(0.052)</span><br><span class="line">KNN: 0.727(0.062)</span><br><span class="line">CART: 0.690(0.062)</span><br><span class="line">SVM: 0.651(0.072)</span><br><span class="line">NB: 0.755(0.043)</span><br></pre></td></tr></table></figure></p><div class="figure"><img src="http://wx3.sinaimg.cn/large/9b7d0c6fly1fqia3kgx3nj20al07p3yh.jpg" title="title" alt="alt text"><p class="caption">alt text</p></div><h1 id="参考">参考：</h1><p>1.<a href="https://read.douban.com/reader/column/6939417/chapter/35955529/" target="_blank" rel="noopener">《机器学习之python》</a></p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sklearn </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> 模型选择 </tag>
            
            <tag> 交叉验证法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Conda常用命令</title>
      <link href="/2018/02/14/Conda%E5%91%BD%E4%BB%A4/"/>
      <url>/2018/02/14/Conda%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="conda-环境">Conda 环境</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"># 创建一个名为python34的环境，指定Python版本是3.4</span><br><span class="line"> conda create --name python34 python=3.4</span><br><span class="line"></span><br><span class="line"># 激活某个环境</span><br><span class="line">activate python34 # for Windows</span><br><span class="line">source activate python34 # for Linux &amp; Mac</span><br><span class="line"></span><br><span class="line">deactivate python34 # for Windows</span><br><span class="line">source deactivate python34 # for Linux &amp; Mac</span><br><span class="line"></span><br><span class="line"># 删除一个已有的环境</span><br><span class="line">conda remove --name python34 --all</span><br><span class="line"></span><br><span class="line"># 创建制定python版本的环境</span><br><span class="line">conda create --name your_env_name python=2.7</span><br><span class="line">conda create --name your_env_name python=3</span><br><span class="line">conda create --name your_env_name python=3.5</span><br><span class="line"></span><br><span class="line"># 创建包含某些包的环境</span><br><span class="line">conda create --name your_env_name numpy scipy</span><br><span class="line"></span><br><span class="line"># 创建指定python版本下包含某些包的环境</span><br><span class="line">conda create --name your_env_name python=3.5 numpy scipy</span><br><span class="line"></span><br><span class="line"># 列举当前所有环境</span><br><span class="line">conda info --envs</span><br><span class="line">conda env list</span><br><span class="line"></span><br><span class="line"># 进入某个环境</span><br><span class="line">activate your_env_name</span><br><span class="line"></span><br><span class="line"># 退出当前环境</span><br><span class="line">deactivate </span><br><span class="line"></span><br><span class="line"># 复制某个环境</span><br><span class="line">conda create --name new_env_name --clone old_env_name</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="conda包管理">Conda包管理</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># 安装xxxx</span><br><span class="line">conda install xxxx</span><br><span class="line"></span><br><span class="line"># 查看当前环境下已安装的包</span><br><span class="line">conda list</span><br><span class="line"></span><br><span class="line"># 查看某个指定环境的已安装包</span><br><span class="line">conda list -n python34</span><br><span class="line"></span><br><span class="line"># 查找package信息</span><br><span class="line">conda search numpy</span><br><span class="line"></span><br><span class="line"># 安装package</span><br><span class="line"># 如果不用-n指定环境名称，则被安装在当前活跃环境 也可以通过-c指定通过某个channel安装</span><br><span class="line">conda install -n python34 numpy </span><br><span class="line"></span><br><span class="line"># 加一个-c表示从http://anaconda.org下载资源包</span><br><span class="line">conda install -c spyder-ide spyder=3.0.0</span><br><span class="line"></span><br><span class="line"># 更新所有库</span><br><span class="line">conda update --all</span><br></pre></td></tr></table></figure><p><a href="https://conda.io/docs/_downloads/conda-cheatsheet.pdf" target="_blank" rel="noopener">cheat-sheet下载</a></p>]]></content>
      
      
      <categories>
          
          <category> cheatsheet </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> basic </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Logistic回归</title>
      <link href="/2018/01/23/logistic%E5%9B%9E%E5%BD%92/"/>
      <url>/2018/01/23/logistic%E5%9B%9E%E5%BD%92/</url>
      
        <content type="html"><![CDATA[<h1 id="基本原理">基本原理</h1><p>Logistic回归是统计学习中的经典分类方法。其实仅在线性回归的基础上，套用了一个逻辑函数。本文主要详述逻辑回归模型的基础。</p><p>假设有输入向量 <span class="math inline">\(x=(x_1;x_2;...;x_n)\)</span>， 由线性回归模型产生的预测值</p><p><span class="math display">\[z=w ^ \mathrm{ T }x+b\tag{1}\]</span> 是实值，需要转换为 0/1 值才能进行分类。因此找一个单调可微函数来替代，将<span class="math inline">\(z\)</span> 的值映射到 (0,1) 之间，这里采用<a href="https://en.wikipedia.org/wiki/Logistic_function" target="_blank" rel="noopener">logistic函数</a>： <span class="math display">\[y=\frac{1}{1+e^{-z}}\tag{2}\]</span></p><a id="more"></a><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/8/88/Logistic-curve.svg/1200px-Logistic-curve.svg.png" alt="logistic function"> 从图中可以看出，对数几率函数是一种“Sigmoid函数”，当 <span class="math inline">\(z=0\)</span> 时，函数值为0.5。随着 <span class="math inline">\(z\)</span> 的增大，对应的值将逼近于1；而随着 <span class="math inline">\(z\)</span> 的减小，输出值将逼近于0。如果横坐标刻度足够大，函数将看起来很像一个阶跃函数，其输出值在 <span class="math inline">\(z=0\)</span> 附近变化很陡。</p><p>将式(1)代入得到</p><p><span class="math display">\[y=\frac{1}{1+e^{-(w ^ \mathrm{ T }x+b)}}\tag{3}\]</span></p><p><strong>上式就是logistic回归模型的分类函数。</strong>最后， <span class="math inline">\(y\)</span> 是一个范围在0~1之间的数值。结果大于0.5的数据被归入1类，小于0.5的即被归入0类。所以，Logistic回归也可以被看成是一种概率估计。</p><p>(3)式可变化为对数几率形式：</p><p><span class="math display">\[\ln \frac{y}{1-y}=w ^ \mathrm{ T }x+b\tag{4}\]</span> 由此看出，<strong>真实标记 <span class="math inline">\(y\)</span> 的对数几率是输入 <span class="math inline">\(x\)</span> 的线性函数</strong>。 将 <span class="math inline">\(y\)</span> 视为类后验概率估计 <span class="math inline">\(p(y=1|x)\)</span> ，则上式可重写为</p><p><span class="math display">\[\ln \frac{p(y=1|x)}{p(y=0|x)}=w ^ \mathrm{ T }x+b\tag{5}\]</span></p><p>显然有</p><p><span class="math display">\[p(y=1|x)=\frac{e^{w ^ \mathrm{ T }x+b}}{1+e^{w ^ \mathrm{ T }x+b}}\tag{6}\]</span> <span class="math display">\[p(y=0|x)=\frac{1}{1+e^{w ^ \mathrm{ T }x+b}}\tag{7}\]</span> <strong>此时线性函数的值越接近正无穷，概率值就越接近1；线性函数的值越接近负无穷，概率值就越接近0。由此得以分类。</strong></p><p>接下来可通过“极大似然法”来估计 <span class="math inline">\(w\)</span> 和 <span class="math inline">\(b\)</span> 。 # 用优化方法来估计参数 优化方法有很多，这里主要了解梯度下降，牛顿法和BFGS</p><h1 id="参考">参考</h1><ul><li><a href="https://chenrudan.github.io/blog/2016/01/09/logisticregression.html" target="_blank" rel="noopener">浅析Logistic Regression</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原理 </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> Logistic回归 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
